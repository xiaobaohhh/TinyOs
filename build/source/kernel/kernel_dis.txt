
E:/ubuntu/diy-x86os/start/start/build/source/kernel/kernel.elf:     file format elf32-i386
E:/ubuntu/diy-x86os/start/start/build/source/kernel/kernel.elf
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00010000

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x00004a9d memsz 0x00004a9d flags r-x
    LOAD off    0x00006000 vaddr 0x00015000 paddr 0x00015000 align 2**12
         filesz 0x00000044 memsz 0x00027100 flags rw-
    LOAD off    0x00007000 vaddr 0x80000000 paddr 0x0003c100 align 2**12
         filesz 0x000022fe memsz 0x000022fe flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004187  00010000  00010000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       000008fd  000141a0  000141a0  000051a0  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00000044  00015000  00015000  00006000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00026100  00016000  00016000  00006044  2**12
                  ALLOC
  4 .first_task   000022fe  80000000  0003c100  00007000  2**5
                  CONTENTS, ALLOC, LOAD, CODE
  5 .debug_line   000021f9  00000000  00000000  000092fe  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005ffc  00000000  00000000  0000b4f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000017c7  00000000  00000000  000114f3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 00000220  00000000  00000000  00012cc0  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 00000060  00000000  00000000  00012ee0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000016d8  00000000  00000000  00012f40  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      00000011  00000000  00000000  00014618  2**0
                  CONTENTS, READONLY
 12 .debug_frame  000018f0  00000000  00000000  0001462c  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
000141a0 l    d  .rodata	00000000 .rodata
00015000 l    d  .data	00000000 .data
00016000 l    d  .bss	00000000 .bss
80000000 l    d  .first_task	00000000 .first_task
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 source/kernel/CMakeFiles/kernel.dir/init/start.S.obj
00010013 l       .text	00000000 gdt_reload
00010445 l       .text	00000000 skip_save_tss
00010450 l       .text	00000000 switch_to_kernel_task
000104a9 l       .text	00000000 switch_to_user_task
0001045c l       .text	00000000 skip_page_dir_kernel
000104b8 l       .text	00000000 skip_change
000104c4 l       .text	00000000 skip_page_dir_user
00010565 l       .text	00000000 skip_page_dir_int
0001056c l       .text	00000000 modify_for_kernel
0001058f l       .text	00000000 modify_for_user
000105c1 l       .text	00000000 restore_registers
00000000 l    df *ABS*	00000000 memory.c
000105f8 l     F .text	0000000d down2
00010605 l     F .text	00000017 up2
0001061c l     F .text	0000000c write_cr3
00010628 l     F .text	0000000b pde_index
00010633 l     F .text	00000010 pte_index
00010643 l     F .text	00000010 pde_paddr
00010653 l     F .text	00000010 pte_paddr
00010663 l     F .text	00000011 mmu_set_page_dir
00010674 l     F .text	0000000f get_pte_perm
00016000 l     O .bss	00000028 paddr_alloc
00017000 l     O .bss	00001000 kernel_page_dir
00010683 l     F .text	00000055 addr_alloc_init
000106d8 l     F .text	0000005f addr_alloc_page
00010737 l     F .text	0000005a addr_free_page
000107f7 l     F .text	0000003a total_mem_size
00015000 l     O .data	00000040 kernel_map.2349
00010b28 l     F .text	00000010 current_page_dir
00000000 l    df *ABS*	00000000 syscall.c
00014200 l     O .rodata	00000194 sys_handler_table
00000000 l    df *ABS*	00000000 task.c
0001106c l     F .text	0000001b list_node_init
00011087 l     F .text	0000000b list_node_next
00011092 l     F .text	0000000b list_count
0001109d l     F .text	0000000a list_first
000110a7 l     F .text	00000011 read_cr3
000110b8 l     F .text	0000000c write_cr3
000110c4 l     F .text	00000007 hlt
000110cb l     F .text	00000017 write_tr
000110e2 l     F .text	00000011 mmu_set_page_dir
00018020 l     O .bss	00000228 task_manager
00018260 l     O .bss	00001000 idle_task_stack
00019260 l     O .bss	00001000 kernel_stack
0001a260 l     O .bss	00006200 task_table
00020460 l     O .bss	00000004 task_table_mutex
000110f3 l     F .text	00000122 tss_init
0001142d l     F .text	0000000a idle_task_entry
00011437 l     F .text	0000004c global_tss_init
00011483 l     F .text	00000069 task_gdt_init
00011b8f l     F .text	00000069 task_alloc
00011bf8 l     F .text	00000030 task_free
00011d93 l     F .text	000000cb load_phdr
00011e5e l     F .text	000001bb load_elf_file
00012019 l     F .text	000000e5 copy_args
00000000 l    df *ABS*	00000000 cpu.c
000122e2 l     F .text	00000028 lgdt
0001230a l     F .text	0000001a far_jump
00020480 l     O .bss	00000800 gdt_table
00020c80 l     O .bss	00000014 gdt_mutex
00000000 l    df *ABS*	00000000 irq.c
0001258e l     F .text	0000001d inb
000125ab l     F .text	0000001f outb
000125ca l     F .text	00000007 cli
000125d1 l     F .text	00000007 sti
000125d8 l     F .text	00000028 lidt
00012600 l     F .text	00000011 read_cr2
00012611 l     F .text	00000007 hlt
00012618 l     F .text	00000010 read_eflags
00012628 l     F .text	0000000b write_eflags
00020ca0 l     O .bss	00000400 idt_table
00012633 l     F .text	0000010c dump_core_regs
0001273f l     F .text	0000003e do_default_handler
00012b32 l     F .text	00000093 init_pic
00000000 l    df *ABS*	00000000 mmu.c
00000000 l    df *ABS*	00000000 time.c
00012f45 l     F .text	0000001f outb
000210a0 l     O .bss	00000004 sys_tick
00012f8c l     F .text	00000060 init_pit
00000000 l    df *ABS*	00000000 fs.c
00013004 l     F .text	0000001d inb
00013021 l     F .text	0000001f inw
00013040 l     F .text	0000001f outb
000210c0 l     O .bss	00019000 TEMP_ADDR
0003a0c0 l     O .bss	00000004 temp_pos
0001305f l     F .text	0000012d read_disk
00000000 l    df *ABS*	00000000 init.c
0003a0c4 l     O .bss	00000010 sem
0003a0d4 l     O .bss	00000014 mutex
00000000 l    df *ABS*	00000000 mutex.c
0001332f l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 sem.c
000134b0 l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 bitmap.c
00000000 l    df *ABS*	00000000 klib.c
0001383d l     F .text	00000007 hlt
00015040 l     O .data	00000004 num2ch.1928
00000000 l    df *ABS*	00000000 list.c
00013df8 l     F .text	00000013 list_is_empty
00000000 l    df *ABS*	00000000 log.c
00013fee l     F .text	0000001d inb
0001400b l     F .text	0000001f outb
0003a0e8 l     O .bss	00000014 log_mutex
00000000 l    df *ABS*	00000000 first_task.c
80000010 l     F .first_task	0000004c sys_call
8000005c l     F .first_task	0000002a msleep
80000086 l     F .first_task	0000001b getpid
800000a1 l     F .first_task	00000028 print_msg
800000c9 l     F .first_task	0000001b fork
800001c0 l     O .first_task	00001000 init_task_stack
800011c0 l     O .first_task	00001000 init_task_stack_test
800021c0 l     O .first_task	000000c4 init_task
00012ade g     F .text	0000001c do_handler_simd_floating_point
00013656 g     F .text	0000003e bitmap_get_bit
00013996 g     F .text	0000004f kernel_memcpy
00013232 g     F .text	0000000a sys_close
000116ce g     F .text	0000000a task_current
00012ee6 g     F .text	0000000b irq_enable_global
000118eb g     F .text	0000003a mmu_set_page_dir_task
00013e8f g     F .text	00000064 list_insert_last
000128b1 g     F .text	0000001c do_handler_segment_not_present
0001166e g     F .text	00000035 task_set_ready
00013768 g     F .text	0000001b bitmap_is_set
000139e5 g     F .text	0000003a kernel_memset
0001320e g     F .text	00000024 sys_lseek
00010105 g       .text	00000000 exception_handler_nmi
00010fd7 g     F .text	00000095 do_handler_syscall
00013d85 g     F .text	0000002d strings_count
0001255c g     F .text	0000001e cpu_init
0001402a g     F .text	0000009d log_init
00011c28 g     F .text	0000016b sys_fork
000132f5 g     F .text	0000003a init_main
000102ff g       .text	00000000 exception_handler_alignment_check
000103a9 g       .text	00000000 exception_handler_security
00010fbd g     F .text	0000001a sys_print_msg
00011932 g     F .text	0000005c do_schedule_switch
00013844 g     F .text	00000033 kernel_strcpy
00018000 g     O .bss	00000004 need_reschedule
00015000 g       .data	00000000 s_data
00012dc5 g     F .text	0000008b irq_enable
00010084 g       .text	00000000 exception_handler_unknown
00010501 g       .text	00000000 quick_switch
00010130 g       .text	00000000 exception_handler_breakpoint
00012841 g     F .text	0000001c do_handler_invalid_op
00012809 g     F .text	0000001c do_handler_overflow
00010353 g       .text	00000000 exception_handler_simd_floating_point
00012aa6 g     F .text	0000001c do_handler_alignment_check
000108e8 g     F .text	00000063 memory_create_map
000131c5 g     F .text	0000003f sys_read
000102ab g       .text	00000000 exception_handler_general_protection
000128e9 g     F .text	000000b5 do_handler_general_protection
00010518 g       .text	00000000 get_full_context
000135cb g     F .text	00000029 sem_count
800000fc g     F .first_task	000000b4 first_task_main
00012799 g     F .text	0000001c do_handler_divider
00013694 g     F .text	000000d4 bitmap_set_bit
00012879 g     F .text	0000001c do_handler_double_fault
800000e4 g     F .first_task	00000018 init_task_entry
0001299e g     F .text	000000ec do_handler_page_fault
00010207 g       .text	00000000 exception_handler_double_fault
00012ef1 g     F .text	0000002b pic_send_eoi
00011664 g     F .text	0000000a task_first_task
00010000 g       .text	00000000 s_text
000134de g     F .text	0000006b sem_wait
00010c44 g     F .text	00000022 memory_alloc_page_for
00012b16 g     F .text	0000001c do_handler_security
00010282 g       .text	00000000 exception_handler_stack_segment_fault
80000000 g       .first_task	00000000 first_task_entry
0001015b g       .text	00000000 exception_handler_overflow
000103d2 g       .text	00000000 simple_switch
0001002b g       .text	00000000 exception_handler_time
000127b5 g     F .text	0000001c do_handler_debug
0003a100 g     O .bss	00002000 stack
0001165a g     F .text	0000000a task_is_need_reschedule
000119e9 g     F .text	0000005d sys_sleep
00010b38 g     F .text	0000006a memory_free_page
0003c100 g       *ABS*	00000000 s_first_task
00010ce5 g     F .text	00000128 memory_copy_vum
0001133e g     F .text	000000ef user_task_init
00011215 g     F .text	0000003a task_uninit
00010ba2 g     F .text	000000a2 memory_alloc_for_page_dir
00011789 g     F .text	00000013 schedule_switch
000103e9 g       .text	00000000 universal_task_switch
00013549 g     F .text	00000082 sem_notify
00010f3a g     F .text	00000083 memory_copy_uvm_data
00010230 g       .text	00000000 exception_handler_invalid_tss
0001159c g     F .text	000000aa task_first_init
00012ac2 g     F .text	0000001c do_handler_machine_check
0001318c g     F .text	00000039 sys_open
00010c66 g     F .text	0000007f memory_copy
00010791 g     F .text	00000066 show_mem_info
000124a5 g     F .text	0000002f gdt_free_desc
00013e30 g     F .text	0000005f list_insert_first
000119c9 g     F .text	00000020 task_set_wakeup
000100af g       .text	00000000 exception_handler_divider
00013877 g     F .text	0000006a kernel_strncpy
00012edb g     F .text	0000000b irq_disable_global
000116d8 g     F .text	00000061 sys_sched_yield
00013204 g     F .text	0000000a sys_write
0003e3fe g       *ABS*	00000000 mem_free_start
0001323c g     F .text	00000030 kernel_init
000134bb g     F .text	00000023 sem_init
00010000 g       .text	00000000 _start
00013bdb g     F .text	00000151 kernel_vsprintf
00013db2 g     F .text	00000046 get_file_name
00011646 g     F .text	0000000a get_from_task
0003c100 g       .bss	00000000 e_data
00013366 g     F .text	00000090 mutex_lock
00010328 g       .text	00000000 exception_handler_machine_check
00011650 g     F .text	0000000a get_to_task
00012895 g     F .text	0000001c do_handler_invalid_tss
00000000 g       .text	00000000 kernel_base
0003e3fe g       *ABS*	00000000 e_first_task
0001198e g     F .text	0000003b task_set_sleep
00013d2c g     F .text	00000059 panic
00012d85 g     F .text	00000040 irq_install
000124d4 g     F .text	00000088 init_gdt
000127d1 g     F .text	0000001c do_handler_nmi
00012f1c g     F .text	00000018 irq_enter_protection
0001333a g     F .text	0000002c mutex_init
0001037e g       .text	00000000 exception_handler_virtualization
00012324 g     F .text	00000058 show_base
00012e50 g     F .text	0000008b irq_disable
0001285d g     F .text	0000001c do_handler_device_not_available
00010e0d g     F .text	000000e7 memory_destroy_uvm
000135f4 g     F .text	00000016 bitmap_byte_count
0001179c g     F .text	00000065 task_dispatch
0001326c g     F .text	00000089 move_to_first_task
0001257a g     F .text	00000014 switch_to_tss
00012825 g     F .text	0000001c do_handler_bounds
0001124f g     F .text	000000ef kernel_task_init
00011739 g     F .text	00000050 task_next_run
00013a1f g     F .text	00000064 kernel_memcmp
0001094b g     F .text	000000a7 create_kernel_table
00013e0b g     F .text	00000025 list_init
0001005b g       .text	00000000 exception_handler_page_fault
000116a3 g     F .text	0000002b task_set_block
0001277d g     F .text	0000001c do_handler_unknown
00010b0e g     F .text	0000001a memory_alloc_page
00012bc5 g     F .text	000001c0 irq_init
000133f6 g     F .text	000000ba mutex_unlock
00012afa g     F .text	0000001c do_handler_virtualization
00012f34 g     F .text	00000011 irq_leave_protection
00012a8a g     F .text	0000001c do_handler_x87_floating_point
0001395b g     F .text	0000003b kernel_strlen
000100da g       .text	00000000 exception_handler_debug
0001237c g     F .text	00000083 segment_desc_set
000105da g       .text	00000000 exception_handler_syscall
000101b1 g       .text	00000000 exception_handler_invalid_op
00013ef3 g     F .text	00000077 list_remove_first
00014a9d g       .rodata	00000000 e_text
000138e1 g     F .text	0000007a kernel_strncmp
0001360a g     F .text	0000004c bitmap_init
00010259 g       .text	00000000 exception_handler_segment_not_present
00013783 g     F .text	000000ba bitmap_alloc_nbits
000114ec g     F .text	000000b0 task_manager_init
00011801 g     F .text	000000ea task_time_tick
00010a77 g     F .text	00000097 memory_init
000120fe g     F .text	000001e4 sys_execve
00010ef4 g     F .text	00000046 memory_get_paddr
000128cd g     F .text	0000001c do_handler_stack_segment_fault
000127ed g     F .text	0000001c do_handler_breakpoint
00011a46 g     F .text	00000149 schedule_next_task
000109f2 g     F .text	00000085 memory_create_user_space
000140c7 g     F .text	000000c0 log_printf
000102d4 g       .text	00000000 exception_handler_x87_floating_point
00013bb7 g     F .text	00000024 kernel_sprintf
00011925 g     F .text	0000000d sys_getpid
00012446 g     F .text	0000005f gdt_alloc_desc
00013a83 g     F .text	00000134 kernel_itoa
00013f6a g     F .text	00000084 list_remove
00010551 g       .text	00000000 switch_from_interrupt
000123ff g     F .text	00000047 gate_desc_set
00010186 g       .text	00000000 exception_handler_bounds
000101dc g       .text	00000000 exception_handler_device_not_available
00010831 g     F .text	000000b7 find_pte
00012f64 g     F .text	00000028 do_handler_time
00012fec g     F .text	00000018 time_init



Disassembly of section .text:

00010000 <_start>:
    .extern kernel_init
    .global _start
    .extern init_main
    .extern need_reschedule
_start:
    push %ebp
   10000:	55                   	push   %ebp
    mov %esp, %ebp
   10001:	89 e5                	mov    %esp,%ebp
    mov 0x8(%ebp), %eax
   10003:	8b 45 08             	mov    0x8(%ebp),%eax

    # mov 4(%esp), %eax

    push %eax 
   10006:	50                   	push   %eax
    call kernel_init
   10007:	e8 30 32 00 00       	call   1323c <kernel_init>

    jmp $KERNEL_SELECTOR_CS, $gdt_reload
   1000c:	ea 13 00 01 00 08 00 	ljmp   $0x8,$0x10013

00010013 <gdt_reload>:

gdt_reload:
    mov $KERNEL_SELECTOR_DS, %ax
   10013:	66 b8 10 00          	mov    $0x10,%ax
    mov %ax, %ds
   10017:	8e d8                	mov    %eax,%ds
    mov %ax, %es
   10019:	8e c0                	mov    %eax,%es
    mov %ax, %fs
   1001b:	8e e0                	mov    %eax,%fs
    mov %ax, %gs
   1001d:	8e e8                	mov    %eax,%gs
    mov %ax, %ss    
   1001f:	8e d0                	mov    %eax,%ss
    
    mov $(stack + KERNEL_STACK_SIZE), %esp
   10021:	bc 00 c1 03 00       	mov    $0x3c100,%esp
    jmp init_main
   10026:	e9 ca 32 00 00       	jmp    132f5 <init_main>

0001002b <exception_handler_time>:

.text
    .extern do_handler_time
    .global exception_handler_time
exception_handler_time:
    push $0
   1002b:	6a 00                	push   $0x0

    push $0x20
   1002d:	6a 20                	push   $0x20
    pusha
   1002f:	60                   	pusha  
    push %ds
   10030:	1e                   	push   %ds
    push %es
   10031:	06                   	push   %es
    push %fs
   10032:	0f a0                	push   %fs
    push %gs
   10034:	0f a8                	push   %gs
    # 设置内核段寄存器
    mov $KERNEL_SELECTOR_DS, %ax
   10036:	66 b8 10 00          	mov    $0x10,%ax
    mov %ax, %ds
   1003a:	8e d8                	mov    %eax,%ds
    mov %ax, %es
   1003c:	8e c0                	mov    %eax,%es
    mov %ax, %fs
   1003e:	8e e0                	mov    %eax,%fs
    mov %ax, %gs
   10040:	8e e8                	mov    %eax,%gs
    push %esp
   10042:	54                   	push   %esp
    call do_handler_time
   10043:	e8 1c 2f 00 00       	call   12f64 <do_handler_time>
    add $(1*4), %esp
   10048:	83 c4 04             	add    $0x4,%esp
    pop %gs
   1004b:	0f a9                	pop    %gs
    pop %fs
   1004d:	0f a1                	pop    %fs
    pop %es
   1004f:	07                   	pop    %es
    pop %ds
   10050:	1f                   	pop    %ds
    popa
   10051:	61                   	popa   

    add $(2*4), %esp
   10052:	83 c4 08             	add    $0x8,%esp
#   call do_schedule_switch
    call schedule_next_task
   10055:	e8 ec 19 00 00       	call   11a46 <schedule_next_task>
    iret 
   1005a:	cf                   	iret   

0001005b <exception_handler_page_fault>:
    .text
    .extern do_handler_page_fault
    .global exception_handler_page_fault
exception_handler_page_fault:

    push $14
   1005b:	6a 0e                	push   $0xe
    pusha
   1005d:	60                   	pusha  
    push %ds
   1005e:	1e                   	push   %ds
    push %es
   1005f:	06                   	push   %es
    push %fs
   10060:	0f a0                	push   %fs
    push %gs
   10062:	0f a8                	push   %gs
    # 设置内核段寄存器
    mov $KERNEL_SELECTOR_DS, %ax
   10064:	66 b8 10 00          	mov    $0x10,%ax
    mov %ax, %ds
   10068:	8e d8                	mov    %eax,%ds
    mov %ax, %es
   1006a:	8e c0                	mov    %eax,%es
    mov %ax, %fs
   1006c:	8e e0                	mov    %eax,%fs
    mov %ax, %gs
   1006e:	8e e8                	mov    %eax,%gs
    push %esp
   10070:	54                   	push   %esp
    call do_handler_page_fault
   10071:	e8 28 29 00 00       	call   1299e <do_handler_page_fault>
    add $(1*4), %esp
   10076:	83 c4 04             	add    $0x4,%esp
    pop %gs
   10079:	0f a9                	pop    %gs
    pop %fs
   1007b:	0f a1                	pop    %fs
    pop %es
   1007d:	07                   	pop    %es
    pop %ds
   1007e:	1f                   	pop    %ds
    popa
   1007f:	61                   	popa   

    add $(2*4), %esp
   10080:	83 c4 08             	add    $0x8,%esp

    iret 
   10083:	cf                   	iret   

00010084 <exception_handler_unknown>:


    
exception_handler unknown,-1,0
   10084:	6a 00                	push   $0x0
   10086:	6a ff                	push   $0xffffffff
   10088:	60                   	pusha  
   10089:	1e                   	push   %ds
   1008a:	06                   	push   %es
   1008b:	0f a0                	push   %fs
   1008d:	0f a8                	push   %gs
   1008f:	66 b8 10 00          	mov    $0x10,%ax
   10093:	8e d8                	mov    %eax,%ds
   10095:	8e c0                	mov    %eax,%es
   10097:	8e e0                	mov    %eax,%fs
   10099:	8e e8                	mov    %eax,%gs
   1009b:	54                   	push   %esp
   1009c:	e8 dc 26 00 00       	call   1277d <do_handler_unknown>
   100a1:	83 c4 04             	add    $0x4,%esp
   100a4:	0f a9                	pop    %gs
   100a6:	0f a1                	pop    %fs
   100a8:	07                   	pop    %es
   100a9:	1f                   	pop    %ds
   100aa:	61                   	popa   
   100ab:	83 c4 08             	add    $0x8,%esp
   100ae:	cf                   	iret   

000100af <exception_handler_divider>:
exception_handler divider,0,0
   100af:	6a 00                	push   $0x0
   100b1:	6a 00                	push   $0x0
   100b3:	60                   	pusha  
   100b4:	1e                   	push   %ds
   100b5:	06                   	push   %es
   100b6:	0f a0                	push   %fs
   100b8:	0f a8                	push   %gs
   100ba:	66 b8 10 00          	mov    $0x10,%ax
   100be:	8e d8                	mov    %eax,%ds
   100c0:	8e c0                	mov    %eax,%es
   100c2:	8e e0                	mov    %eax,%fs
   100c4:	8e e8                	mov    %eax,%gs
   100c6:	54                   	push   %esp
   100c7:	e8 cd 26 00 00       	call   12799 <do_handler_divider>
   100cc:	83 c4 04             	add    $0x4,%esp
   100cf:	0f a9                	pop    %gs
   100d1:	0f a1                	pop    %fs
   100d3:	07                   	pop    %es
   100d4:	1f                   	pop    %ds
   100d5:	61                   	popa   
   100d6:	83 c4 08             	add    $0x8,%esp
   100d9:	cf                   	iret   

000100da <exception_handler_debug>:
exception_handler debug,1,0
   100da:	6a 00                	push   $0x0
   100dc:	6a 01                	push   $0x1
   100de:	60                   	pusha  
   100df:	1e                   	push   %ds
   100e0:	06                   	push   %es
   100e1:	0f a0                	push   %fs
   100e3:	0f a8                	push   %gs
   100e5:	66 b8 10 00          	mov    $0x10,%ax
   100e9:	8e d8                	mov    %eax,%ds
   100eb:	8e c0                	mov    %eax,%es
   100ed:	8e e0                	mov    %eax,%fs
   100ef:	8e e8                	mov    %eax,%gs
   100f1:	54                   	push   %esp
   100f2:	e8 be 26 00 00       	call   127b5 <do_handler_debug>
   100f7:	83 c4 04             	add    $0x4,%esp
   100fa:	0f a9                	pop    %gs
   100fc:	0f a1                	pop    %fs
   100fe:	07                   	pop    %es
   100ff:	1f                   	pop    %ds
   10100:	61                   	popa   
   10101:	83 c4 08             	add    $0x8,%esp
   10104:	cf                   	iret   

00010105 <exception_handler_nmi>:
exception_handler nmi,2,0
   10105:	6a 00                	push   $0x0
   10107:	6a 02                	push   $0x2
   10109:	60                   	pusha  
   1010a:	1e                   	push   %ds
   1010b:	06                   	push   %es
   1010c:	0f a0                	push   %fs
   1010e:	0f a8                	push   %gs
   10110:	66 b8 10 00          	mov    $0x10,%ax
   10114:	8e d8                	mov    %eax,%ds
   10116:	8e c0                	mov    %eax,%es
   10118:	8e e0                	mov    %eax,%fs
   1011a:	8e e8                	mov    %eax,%gs
   1011c:	54                   	push   %esp
   1011d:	e8 af 26 00 00       	call   127d1 <do_handler_nmi>
   10122:	83 c4 04             	add    $0x4,%esp
   10125:	0f a9                	pop    %gs
   10127:	0f a1                	pop    %fs
   10129:	07                   	pop    %es
   1012a:	1f                   	pop    %ds
   1012b:	61                   	popa   
   1012c:	83 c4 08             	add    $0x8,%esp
   1012f:	cf                   	iret   

00010130 <exception_handler_breakpoint>:
exception_handler breakpoint,3,0
   10130:	6a 00                	push   $0x0
   10132:	6a 03                	push   $0x3
   10134:	60                   	pusha  
   10135:	1e                   	push   %ds
   10136:	06                   	push   %es
   10137:	0f a0                	push   %fs
   10139:	0f a8                	push   %gs
   1013b:	66 b8 10 00          	mov    $0x10,%ax
   1013f:	8e d8                	mov    %eax,%ds
   10141:	8e c0                	mov    %eax,%es
   10143:	8e e0                	mov    %eax,%fs
   10145:	8e e8                	mov    %eax,%gs
   10147:	54                   	push   %esp
   10148:	e8 a0 26 00 00       	call   127ed <do_handler_breakpoint>
   1014d:	83 c4 04             	add    $0x4,%esp
   10150:	0f a9                	pop    %gs
   10152:	0f a1                	pop    %fs
   10154:	07                   	pop    %es
   10155:	1f                   	pop    %ds
   10156:	61                   	popa   
   10157:	83 c4 08             	add    $0x8,%esp
   1015a:	cf                   	iret   

0001015b <exception_handler_overflow>:
exception_handler overflow,4,0
   1015b:	6a 00                	push   $0x0
   1015d:	6a 04                	push   $0x4
   1015f:	60                   	pusha  
   10160:	1e                   	push   %ds
   10161:	06                   	push   %es
   10162:	0f a0                	push   %fs
   10164:	0f a8                	push   %gs
   10166:	66 b8 10 00          	mov    $0x10,%ax
   1016a:	8e d8                	mov    %eax,%ds
   1016c:	8e c0                	mov    %eax,%es
   1016e:	8e e0                	mov    %eax,%fs
   10170:	8e e8                	mov    %eax,%gs
   10172:	54                   	push   %esp
   10173:	e8 91 26 00 00       	call   12809 <do_handler_overflow>
   10178:	83 c4 04             	add    $0x4,%esp
   1017b:	0f a9                	pop    %gs
   1017d:	0f a1                	pop    %fs
   1017f:	07                   	pop    %es
   10180:	1f                   	pop    %ds
   10181:	61                   	popa   
   10182:	83 c4 08             	add    $0x8,%esp
   10185:	cf                   	iret   

00010186 <exception_handler_bounds>:
exception_handler bounds,5,0
   10186:	6a 00                	push   $0x0
   10188:	6a 05                	push   $0x5
   1018a:	60                   	pusha  
   1018b:	1e                   	push   %ds
   1018c:	06                   	push   %es
   1018d:	0f a0                	push   %fs
   1018f:	0f a8                	push   %gs
   10191:	66 b8 10 00          	mov    $0x10,%ax
   10195:	8e d8                	mov    %eax,%ds
   10197:	8e c0                	mov    %eax,%es
   10199:	8e e0                	mov    %eax,%fs
   1019b:	8e e8                	mov    %eax,%gs
   1019d:	54                   	push   %esp
   1019e:	e8 82 26 00 00       	call   12825 <do_handler_bounds>
   101a3:	83 c4 04             	add    $0x4,%esp
   101a6:	0f a9                	pop    %gs
   101a8:	0f a1                	pop    %fs
   101aa:	07                   	pop    %es
   101ab:	1f                   	pop    %ds
   101ac:	61                   	popa   
   101ad:	83 c4 08             	add    $0x8,%esp
   101b0:	cf                   	iret   

000101b1 <exception_handler_invalid_op>:
exception_handler invalid_op,6,0
   101b1:	6a 00                	push   $0x0
   101b3:	6a 06                	push   $0x6
   101b5:	60                   	pusha  
   101b6:	1e                   	push   %ds
   101b7:	06                   	push   %es
   101b8:	0f a0                	push   %fs
   101ba:	0f a8                	push   %gs
   101bc:	66 b8 10 00          	mov    $0x10,%ax
   101c0:	8e d8                	mov    %eax,%ds
   101c2:	8e c0                	mov    %eax,%es
   101c4:	8e e0                	mov    %eax,%fs
   101c6:	8e e8                	mov    %eax,%gs
   101c8:	54                   	push   %esp
   101c9:	e8 73 26 00 00       	call   12841 <do_handler_invalid_op>
   101ce:	83 c4 04             	add    $0x4,%esp
   101d1:	0f a9                	pop    %gs
   101d3:	0f a1                	pop    %fs
   101d5:	07                   	pop    %es
   101d6:	1f                   	pop    %ds
   101d7:	61                   	popa   
   101d8:	83 c4 08             	add    $0x8,%esp
   101db:	cf                   	iret   

000101dc <exception_handler_device_not_available>:
exception_handler device_not_available,7,0
   101dc:	6a 00                	push   $0x0
   101de:	6a 07                	push   $0x7
   101e0:	60                   	pusha  
   101e1:	1e                   	push   %ds
   101e2:	06                   	push   %es
   101e3:	0f a0                	push   %fs
   101e5:	0f a8                	push   %gs
   101e7:	66 b8 10 00          	mov    $0x10,%ax
   101eb:	8e d8                	mov    %eax,%ds
   101ed:	8e c0                	mov    %eax,%es
   101ef:	8e e0                	mov    %eax,%fs
   101f1:	8e e8                	mov    %eax,%gs
   101f3:	54                   	push   %esp
   101f4:	e8 64 26 00 00       	call   1285d <do_handler_device_not_available>
   101f9:	83 c4 04             	add    $0x4,%esp
   101fc:	0f a9                	pop    %gs
   101fe:	0f a1                	pop    %fs
   10200:	07                   	pop    %es
   10201:	1f                   	pop    %ds
   10202:	61                   	popa   
   10203:	83 c4 08             	add    $0x8,%esp
   10206:	cf                   	iret   

00010207 <exception_handler_double_fault>:
exception_handler double_fault,8,1
   10207:	6a 08                	push   $0x8
   10209:	60                   	pusha  
   1020a:	1e                   	push   %ds
   1020b:	06                   	push   %es
   1020c:	0f a0                	push   %fs
   1020e:	0f a8                	push   %gs
   10210:	66 b8 10 00          	mov    $0x10,%ax
   10214:	8e d8                	mov    %eax,%ds
   10216:	8e c0                	mov    %eax,%es
   10218:	8e e0                	mov    %eax,%fs
   1021a:	8e e8                	mov    %eax,%gs
   1021c:	54                   	push   %esp
   1021d:	e8 57 26 00 00       	call   12879 <do_handler_double_fault>
   10222:	83 c4 04             	add    $0x4,%esp
   10225:	0f a9                	pop    %gs
   10227:	0f a1                	pop    %fs
   10229:	07                   	pop    %es
   1022a:	1f                   	pop    %ds
   1022b:	61                   	popa   
   1022c:	83 c4 08             	add    $0x8,%esp
   1022f:	cf                   	iret   

00010230 <exception_handler_invalid_tss>:

exception_handler invalid_tss,10,1
   10230:	6a 0a                	push   $0xa
   10232:	60                   	pusha  
   10233:	1e                   	push   %ds
   10234:	06                   	push   %es
   10235:	0f a0                	push   %fs
   10237:	0f a8                	push   %gs
   10239:	66 b8 10 00          	mov    $0x10,%ax
   1023d:	8e d8                	mov    %eax,%ds
   1023f:	8e c0                	mov    %eax,%es
   10241:	8e e0                	mov    %eax,%fs
   10243:	8e e8                	mov    %eax,%gs
   10245:	54                   	push   %esp
   10246:	e8 4a 26 00 00       	call   12895 <do_handler_invalid_tss>
   1024b:	83 c4 04             	add    $0x4,%esp
   1024e:	0f a9                	pop    %gs
   10250:	0f a1                	pop    %fs
   10252:	07                   	pop    %es
   10253:	1f                   	pop    %ds
   10254:	61                   	popa   
   10255:	83 c4 08             	add    $0x8,%esp
   10258:	cf                   	iret   

00010259 <exception_handler_segment_not_present>:
exception_handler segment_not_present,11,1
   10259:	6a 0b                	push   $0xb
   1025b:	60                   	pusha  
   1025c:	1e                   	push   %ds
   1025d:	06                   	push   %es
   1025e:	0f a0                	push   %fs
   10260:	0f a8                	push   %gs
   10262:	66 b8 10 00          	mov    $0x10,%ax
   10266:	8e d8                	mov    %eax,%ds
   10268:	8e c0                	mov    %eax,%es
   1026a:	8e e0                	mov    %eax,%fs
   1026c:	8e e8                	mov    %eax,%gs
   1026e:	54                   	push   %esp
   1026f:	e8 3d 26 00 00       	call   128b1 <do_handler_segment_not_present>
   10274:	83 c4 04             	add    $0x4,%esp
   10277:	0f a9                	pop    %gs
   10279:	0f a1                	pop    %fs
   1027b:	07                   	pop    %es
   1027c:	1f                   	pop    %ds
   1027d:	61                   	popa   
   1027e:	83 c4 08             	add    $0x8,%esp
   10281:	cf                   	iret   

00010282 <exception_handler_stack_segment_fault>:
exception_handler stack_segment_fault,12,1
   10282:	6a 0c                	push   $0xc
   10284:	60                   	pusha  
   10285:	1e                   	push   %ds
   10286:	06                   	push   %es
   10287:	0f a0                	push   %fs
   10289:	0f a8                	push   %gs
   1028b:	66 b8 10 00          	mov    $0x10,%ax
   1028f:	8e d8                	mov    %eax,%ds
   10291:	8e c0                	mov    %eax,%es
   10293:	8e e0                	mov    %eax,%fs
   10295:	8e e8                	mov    %eax,%gs
   10297:	54                   	push   %esp
   10298:	e8 30 26 00 00       	call   128cd <do_handler_stack_segment_fault>
   1029d:	83 c4 04             	add    $0x4,%esp
   102a0:	0f a9                	pop    %gs
   102a2:	0f a1                	pop    %fs
   102a4:	07                   	pop    %es
   102a5:	1f                   	pop    %ds
   102a6:	61                   	popa   
   102a7:	83 c4 08             	add    $0x8,%esp
   102aa:	cf                   	iret   

000102ab <exception_handler_general_protection>:
exception_handler general_protection,13,1
   102ab:	6a 0d                	push   $0xd
   102ad:	60                   	pusha  
   102ae:	1e                   	push   %ds
   102af:	06                   	push   %es
   102b0:	0f a0                	push   %fs
   102b2:	0f a8                	push   %gs
   102b4:	66 b8 10 00          	mov    $0x10,%ax
   102b8:	8e d8                	mov    %eax,%ds
   102ba:	8e c0                	mov    %eax,%es
   102bc:	8e e0                	mov    %eax,%fs
   102be:	8e e8                	mov    %eax,%gs
   102c0:	54                   	push   %esp
   102c1:	e8 23 26 00 00       	call   128e9 <do_handler_general_protection>
   102c6:	83 c4 04             	add    $0x4,%esp
   102c9:	0f a9                	pop    %gs
   102cb:	0f a1                	pop    %fs
   102cd:	07                   	pop    %es
   102ce:	1f                   	pop    %ds
   102cf:	61                   	popa   
   102d0:	83 c4 08             	add    $0x8,%esp
   102d3:	cf                   	iret   

000102d4 <exception_handler_x87_floating_point>:
# exception_handler page_fault,14,1
exception_handler x87_floating_point,16,0
   102d4:	6a 00                	push   $0x0
   102d6:	6a 10                	push   $0x10
   102d8:	60                   	pusha  
   102d9:	1e                   	push   %ds
   102da:	06                   	push   %es
   102db:	0f a0                	push   %fs
   102dd:	0f a8                	push   %gs
   102df:	66 b8 10 00          	mov    $0x10,%ax
   102e3:	8e d8                	mov    %eax,%ds
   102e5:	8e c0                	mov    %eax,%es
   102e7:	8e e0                	mov    %eax,%fs
   102e9:	8e e8                	mov    %eax,%gs
   102eb:	54                   	push   %esp
   102ec:	e8 99 27 00 00       	call   12a8a <do_handler_x87_floating_point>
   102f1:	83 c4 04             	add    $0x4,%esp
   102f4:	0f a9                	pop    %gs
   102f6:	0f a1                	pop    %fs
   102f8:	07                   	pop    %es
   102f9:	1f                   	pop    %ds
   102fa:	61                   	popa   
   102fb:	83 c4 08             	add    $0x8,%esp
   102fe:	cf                   	iret   

000102ff <exception_handler_alignment_check>:
exception_handler alignment_check,17,1
   102ff:	6a 11                	push   $0x11
   10301:	60                   	pusha  
   10302:	1e                   	push   %ds
   10303:	06                   	push   %es
   10304:	0f a0                	push   %fs
   10306:	0f a8                	push   %gs
   10308:	66 b8 10 00          	mov    $0x10,%ax
   1030c:	8e d8                	mov    %eax,%ds
   1030e:	8e c0                	mov    %eax,%es
   10310:	8e e0                	mov    %eax,%fs
   10312:	8e e8                	mov    %eax,%gs
   10314:	54                   	push   %esp
   10315:	e8 8c 27 00 00       	call   12aa6 <do_handler_alignment_check>
   1031a:	83 c4 04             	add    $0x4,%esp
   1031d:	0f a9                	pop    %gs
   1031f:	0f a1                	pop    %fs
   10321:	07                   	pop    %es
   10322:	1f                   	pop    %ds
   10323:	61                   	popa   
   10324:	83 c4 08             	add    $0x8,%esp
   10327:	cf                   	iret   

00010328 <exception_handler_machine_check>:
exception_handler machine_check,18,0
   10328:	6a 00                	push   $0x0
   1032a:	6a 12                	push   $0x12
   1032c:	60                   	pusha  
   1032d:	1e                   	push   %ds
   1032e:	06                   	push   %es
   1032f:	0f a0                	push   %fs
   10331:	0f a8                	push   %gs
   10333:	66 b8 10 00          	mov    $0x10,%ax
   10337:	8e d8                	mov    %eax,%ds
   10339:	8e c0                	mov    %eax,%es
   1033b:	8e e0                	mov    %eax,%fs
   1033d:	8e e8                	mov    %eax,%gs
   1033f:	54                   	push   %esp
   10340:	e8 7d 27 00 00       	call   12ac2 <do_handler_machine_check>
   10345:	83 c4 04             	add    $0x4,%esp
   10348:	0f a9                	pop    %gs
   1034a:	0f a1                	pop    %fs
   1034c:	07                   	pop    %es
   1034d:	1f                   	pop    %ds
   1034e:	61                   	popa   
   1034f:	83 c4 08             	add    $0x8,%esp
   10352:	cf                   	iret   

00010353 <exception_handler_simd_floating_point>:
exception_handler simd_floating_point,19,0
   10353:	6a 00                	push   $0x0
   10355:	6a 13                	push   $0x13
   10357:	60                   	pusha  
   10358:	1e                   	push   %ds
   10359:	06                   	push   %es
   1035a:	0f a0                	push   %fs
   1035c:	0f a8                	push   %gs
   1035e:	66 b8 10 00          	mov    $0x10,%ax
   10362:	8e d8                	mov    %eax,%ds
   10364:	8e c0                	mov    %eax,%es
   10366:	8e e0                	mov    %eax,%fs
   10368:	8e e8                	mov    %eax,%gs
   1036a:	54                   	push   %esp
   1036b:	e8 6e 27 00 00       	call   12ade <do_handler_simd_floating_point>
   10370:	83 c4 04             	add    $0x4,%esp
   10373:	0f a9                	pop    %gs
   10375:	0f a1                	pop    %fs
   10377:	07                   	pop    %es
   10378:	1f                   	pop    %ds
   10379:	61                   	popa   
   1037a:	83 c4 08             	add    $0x8,%esp
   1037d:	cf                   	iret   

0001037e <exception_handler_virtualization>:
exception_handler virtualization,20,0
   1037e:	6a 00                	push   $0x0
   10380:	6a 14                	push   $0x14
   10382:	60                   	pusha  
   10383:	1e                   	push   %ds
   10384:	06                   	push   %es
   10385:	0f a0                	push   %fs
   10387:	0f a8                	push   %gs
   10389:	66 b8 10 00          	mov    $0x10,%ax
   1038d:	8e d8                	mov    %eax,%ds
   1038f:	8e c0                	mov    %eax,%es
   10391:	8e e0                	mov    %eax,%fs
   10393:	8e e8                	mov    %eax,%gs
   10395:	54                   	push   %esp
   10396:	e8 5f 27 00 00       	call   12afa <do_handler_virtualization>
   1039b:	83 c4 04             	add    $0x4,%esp
   1039e:	0f a9                	pop    %gs
   103a0:	0f a1                	pop    %fs
   103a2:	07                   	pop    %es
   103a3:	1f                   	pop    %ds
   103a4:	61                   	popa   
   103a5:	83 c4 08             	add    $0x8,%esp
   103a8:	cf                   	iret   

000103a9 <exception_handler_security>:
exception_handler security,21,1
   103a9:	6a 15                	push   $0x15
   103ab:	60                   	pusha  
   103ac:	1e                   	push   %ds
   103ad:	06                   	push   %es
   103ae:	0f a0                	push   %fs
   103b0:	0f a8                	push   %gs
   103b2:	66 b8 10 00          	mov    $0x10,%ax
   103b6:	8e d8                	mov    %eax,%ds
   103b8:	8e c0                	mov    %eax,%es
   103ba:	8e e0                	mov    %eax,%fs
   103bc:	8e e8                	mov    %eax,%gs
   103be:	54                   	push   %esp
   103bf:	e8 52 27 00 00       	call   12b16 <do_handler_security>
   103c4:	83 c4 04             	add    $0x4,%esp
   103c7:	0f a9                	pop    %gs
   103c9:	0f a1                	pop    %fs
   103cb:	07                   	pop    %es
   103cc:	1f                   	pop    %ds
   103cd:	61                   	popa   
   103ce:	83 c4 08             	add    $0x8,%esp
   103d1:	cf                   	iret   

000103d2 <simple_switch>:
*/

    .text
    .global simple_switch
simple_switch:
    mov 4(%esp), %eax
   103d2:	8b 44 24 04          	mov    0x4(%esp),%eax
    mov 8(%esp), %edx
   103d6:	8b 54 24 08          	mov    0x8(%esp),%edx

    
    push %ebp
   103da:	55                   	push   %ebp
    push %ebx
   103db:	53                   	push   %ebx
    push %esi
   103dc:	56                   	push   %esi
    push %edi
   103dd:	57                   	push   %edi
    pushf                # 保存EFLAGS寄存器
   103de:	9c                   	pushf  

    mov %esp,(%eax)
   103df:	89 20                	mov    %esp,(%eax)

    mov %edx,%esp
   103e1:	89 d4                	mov    %edx,%esp

    popf                 # 恢复EFLAGS寄存器
   103e3:	9d                   	popf   
    pop %edi
   103e4:	5f                   	pop    %edi
    pop %esi
   103e5:	5e                   	pop    %esi
    pop %ebx
   103e6:	5b                   	pop    %ebx
    pop %ebp
   103e7:	5d                   	pop    %ebp
    

    ret
   103e8:	c3                   	ret    

000103e9 <universal_task_switch>:
# save_tss_ptr: 保存当前TSS的地址 (如果为0则不保存)
# new_task_type: 0=内核任务, 1=用户任务
    .global universal_task_switch
universal_task_switch:
    # 保存当前TSS (如果需要)
    mov 4(%esp), %eax    # save_tss_ptr
   103e9:	8b 44 24 04          	mov    0x4(%esp),%eax
    cmp $0, %eax
   103ed:	83 f8 00             	cmp    $0x0,%eax
    je skip_save_tss
   103f0:	74 53                	je     10445 <skip_save_tss>
    
    # 保存当前TSS到指定地址
    # TSS结构: pre_link(0), esp0(4), ss0(8), esp1(12), ss1(16), esp2(20), ss2(24), cr3(28), eip(32), eflags(36), eax(40), ecx(44), edx(48), ebx(52), esp(56), ebp(60), esi(64), edi(68), es(72), cs(76), ss(80), ds(84), fs(88), gs(92), ldt(96), iomap(100)
    
    # 保存当前寄存器到TSS
    mov %eax, 40(%eax)   # 保存eax到tss.eax
   103f2:	89 40 28             	mov    %eax,0x28(%eax)
    mov %ebx, 52(%eax)   # 保存ebx到tss.ebx
   103f5:	89 58 34             	mov    %ebx,0x34(%eax)
    mov %ecx, 44(%eax)   # 保存ecx到tss.ecx
   103f8:	89 48 2c             	mov    %ecx,0x2c(%eax)
    mov %edx, 48(%eax)   # 保存edx到tss.edx
   103fb:	89 50 30             	mov    %edx,0x30(%eax)
    mov %esi, 64(%eax)   # 保存esi到tss.esi
   103fe:	89 70 40             	mov    %esi,0x40(%eax)
    mov %edi, 68(%eax)   # 保存edi到tss.edi
   10401:	89 78 44             	mov    %edi,0x44(%eax)
    mov %ebp, 60(%eax)   # 保存ebp到tss.ebp
   10404:	89 68 3c             	mov    %ebp,0x3c(%eax)
    mov %esp, 4(%eax)   # 保存esp到tss.esp0，内核栈都用esp0，esp只在第一次跳出到用户栈的时候用到
   10407:	89 60 04             	mov    %esp,0x4(%eax)
    
    # 保存返回地址作为EIP
    mov (%esp), %edx
   1040a:	8b 14 24             	mov    (%esp),%edx
    mov %edx, 32(%eax)   # 保存eip到tss.eip
   1040d:	89 50 20             	mov    %edx,0x20(%eax)
    
    # 保存EFLAGS
    pushf
   10410:	9c                   	pushf  
    pop %edx
   10411:	5a                   	pop    %edx
    mov %edx, 36(%eax)   # 保存eflags到tss.eflags
   10412:	89 50 24             	mov    %edx,0x24(%eax)
    
    # 保存段寄存器
    mov %cs, %dx
   10415:	66 8c ca             	mov    %cs,%dx
    mov %dx, 76(%eax)    # 保存cs到tss.cs
   10418:	66 89 50 4c          	mov    %dx,0x4c(%eax)
    mov %ds, %dx
   1041c:	66 8c da             	mov    %ds,%dx
    mov %dx, 84(%eax)    # 保存ds到tss.ds
   1041f:	66 89 50 54          	mov    %dx,0x54(%eax)
    mov %ss, %dx
   10423:	66 8c d2             	mov    %ss,%dx
    mov %dx, 80(%eax)    # 保存ss到tss.ss
   10426:	66 89 50 50          	mov    %dx,0x50(%eax)
    mov %es, %dx
   1042a:	66 8c c2             	mov    %es,%dx
    mov %dx, 72(%eax)    # 保存es到tss.es
   1042d:	66 89 50 48          	mov    %dx,0x48(%eax)
    mov %fs, %dx
   10431:	66 8c e2             	mov    %fs,%dx
    mov %dx, 88(%eax)    # 保存fs到tss.fs
   10434:	66 89 50 58          	mov    %dx,0x58(%eax)
    mov %gs, %dx
   10438:	66 8c ea             	mov    %gs,%dx
    mov %dx, 92(%eax)    # 保存gs到tss.gs
   1043b:	66 89 50 5c          	mov    %dx,0x5c(%eax)
    # mov %dx, 88(%eax)    # 保存fs到tss.fs
    # mov $USER_SELECTOR_DS, %dx
    # mov %dx, 92(%eax)    # 保存gs到tss.gs
    
    # 保存CR3
    mov %cr3, %edx
   1043f:	0f 20 da             	mov    %cr3,%edx
    mov %edx, 28(%eax)   # 保存cr3到tss.cr3
   10442:	89 50 1c             	mov    %edx,0x1c(%eax)

00010445 <skip_save_tss>:

skip_save_tss:
    # 获取新任务参数
    mov 8(%esp), %eax    # new_task_type
   10445:	8b 44 24 08          	mov    0x8(%esp),%eax
    cmp $0, (%eax)
   10449:	83 38 00             	cmpl   $0x0,(%eax)
    je switch_to_kernel_task
   1044c:	74 02                	je     10450 <switch_to_kernel_task>
    jmp switch_to_user_task
   1044e:	eb 59                	jmp    104a9 <switch_to_user_task>

00010450 <switch_to_kernel_task>:

switch_to_kernel_task:
    # 切换到内核任务
    
    # 切换页目录
    mov 12(%esp), %eax   # new_cr3
   10450:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cmp $0, %eax
   10454:	83 f8 00             	cmp    $0x0,%eax
    je skip_page_dir_kernel
   10457:	74 03                	je     1045c <skip_page_dir_kernel>
    mov %eax, %cr3
   10459:	0f 22 d8             	mov    %eax,%cr3

0001045c <skip_page_dir_kernel>:
skip_page_dir_kernel:
    
    # 设置内核段寄存器
    mov $0x10, %ax
   1045c:	66 b8 10 00          	mov    $0x10,%ax
    mov %ax, %ds
   10460:	8e d8                	mov    %eax,%ds
    mov %ax, %es
   10462:	8e c0                	mov    %eax,%es
    mov %ax, %fs
   10464:	8e e0                	mov    %eax,%fs
    mov %ax, %gs
   10466:	8e e8                	mov    %eax,%gs
    mov %ax, %ss
   10468:	8e d0                	mov    %eax,%ss
    
    # 恢复寄存器
    mov 36(%esp), %eax   # new_eax
   1046a:	8b 44 24 24          	mov    0x24(%esp),%eax
    mov 40(%esp), %ebx   # new_ebx
   1046e:	8b 5c 24 28          	mov    0x28(%esp),%ebx
    mov 44(%esp), %ecx   # new_ecx
   10472:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
    mov 48(%esp), %edx   # new_edx
   10476:	8b 54 24 30          	mov    0x30(%esp),%edx
    mov 52(%esp), %esi   # new_esi
   1047a:	8b 74 24 34          	mov    0x34(%esp),%esi
    mov 56(%esp), %edi   # new_edi
   1047e:	8b 7c 24 38          	mov    0x38(%esp),%edi
    mov 60(%esp), %ebp   # new_ebp
   10482:	8b 6c 24 3c          	mov    0x3c(%esp),%ebp

    # 恢复EFLAGS并跳转
    mov 24(%esp), %eax   # new_eflags
   10486:	8b 44 24 18          	mov    0x18(%esp),%eax
    push %eax
   1048a:	50                   	push   %eax
    popf
   1048b:	9d                   	popf   

    mov 20(%esp),%ebx
   1048c:	8b 5c 24 14          	mov    0x14(%esp),%ebx
    mov %esp, %eax
   10490:	89 e0                	mov    %esp,%eax
    mov 32(%esp), %esp   # new_esp
   10492:	8b 64 24 20          	mov    0x20(%esp),%esp
    add $4, %esp
   10496:	83 c4 04             	add    $0x4,%esp
    push %ebx
   10499:	53                   	push   %ebx
    mov %eax, %esp
   1049a:	89 c4                	mov    %eax,%esp
    mov 36(%esp), %eax   # new_eax
   1049c:	8b 44 24 24          	mov    0x24(%esp),%eax
    mov 40(%esp), %ebx   # new_ebx
   104a0:	8b 5c 24 28          	mov    0x28(%esp),%ebx
    mov 32(%esp), %esp     # 获取原始new_esp
   104a4:	8b 64 24 20          	mov    0x20(%esp),%esp
    
    
    
    
    # 跳转到新任务
    ret       # new_eip
   104a8:	c3                   	ret    

000104a9 <switch_to_user_task>:

switch_to_user_task:
    # 切换到用户任务
    movl 8(%esp), %eax
   104a9:	8b 44 24 08          	mov    0x8(%esp),%eax
    cmpl $0x01, (%eax)        # 比较8(%esp)与TASK_USER
   104ad:	83 38 01             	cmpl   $0x1,(%eax)
    jne  skip_change                # 如果不相等，跳过修改
   104b0:	75 06                	jne    104b8 <skip_change>
    movl $0x00, (%eax)      # 如果相等，设置为TASK_KERNEL
   104b2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

000104b8 <skip_change>:

skip_change:
    # 切换页目录
    mov 12(%esp), %eax   # new_cr3
   104b8:	8b 44 24 0c          	mov    0xc(%esp),%eax
    cmp $0, %eax
   104bc:	83 f8 00             	cmp    $0x0,%eax
    je skip_page_dir_user
   104bf:	74 03                	je     104c4 <skip_page_dir_user>
    mov %eax, %cr3
   104c1:	0f 22 d8             	mov    %eax,%cr3

000104c4 <skip_page_dir_user>:
skip_page_dir_user:
    
    # 构造iret栈帧（特权级切换需要5个值）
    pushl 28(%esp)       # new_ss (原来28+0，因为SS是第7个参数)
   104c4:	ff 74 24 1c          	pushl  0x1c(%esp)
    pushl 36(%esp)       # new_esp (原来32+4)
   104c8:	ff 74 24 24          	pushl  0x24(%esp)
    pushl 32(%esp)       # new_eflags (原来24+8)
   104cc:	ff 74 24 20          	pushl  0x20(%esp)
    pushl 28(%esp)       # new_cs (原来16+12)
   104d0:	ff 74 24 1c          	pushl  0x1c(%esp)
    pushl 36(%esp)       # new_eip (原来20+16)
   104d4:	ff 74 24 24          	pushl  0x24(%esp)
    
    # 设置用户段寄存器
    mov $0x23, %ax
   104d8:	66 b8 23 00          	mov    $0x23,%ax
    mov %ax, %ds
   104dc:	8e d8                	mov    %eax,%ds
    mov %ax, %es
   104de:	8e c0                	mov    %eax,%es
    mov %ax, %fs
   104e0:	8e e0                	mov    %eax,%fs
    mov %ax, %gs
   104e2:	8e e8                	mov    %eax,%gs
    
    # 恢复通用寄存器
    mov 56(%esp), %eax   # new_eax (原来36+20)
   104e4:	8b 44 24 38          	mov    0x38(%esp),%eax
    mov 60(%esp), %ebx   # new_ebx (原来40+20)
   104e8:	8b 5c 24 3c          	mov    0x3c(%esp),%ebx
    mov 64(%esp), %ecx   # new_ecx (原来44+20)
   104ec:	8b 4c 24 40          	mov    0x40(%esp),%ecx
    mov 68(%esp), %edx   # new_edx (原来48+20)
   104f0:	8b 54 24 44          	mov    0x44(%esp),%edx
    mov 72(%esp), %esi   # new_esi (原来52+20)
   104f4:	8b 74 24 48          	mov    0x48(%esp),%esi
    mov 76(%esp), %edi   # new_edi (原来56+20)
   104f8:	8b 7c 24 4c          	mov    0x4c(%esp),%edi
    mov 80(%esp), %ebp   # new_ebp (原来60+20)
   104fc:	8b 6c 24 50          	mov    0x50(%esp),%ebp
    
    # 切换到用户态
    iret
   10500:	cf                   	iret   

00010501 <quick_switch>:

# 快速内核任务切换 (只保存/恢复栈指针)
# 参数: quick_switch(current_esp_ptr, new_esp)
    .global quick_switch
quick_switch:
    mov 4(%esp), %eax    # current_esp_ptr
   10501:	8b 44 24 04          	mov    0x4(%esp),%eax
    mov 8(%esp), %edx    # new_esp
   10505:	8b 54 24 08          	mov    0x8(%esp),%edx
    
    # 保存调用者保存的寄存器
    push %ebp
   10509:	55                   	push   %ebp
    push %ebx
   1050a:	53                   	push   %ebx
    push %esi
   1050b:	56                   	push   %esi
    push %edi
   1050c:	57                   	push   %edi
    pushf
   1050d:	9c                   	pushf  
    
    # 保存当前ESP
    mov %esp, (%eax)
   1050e:	89 20                	mov    %esp,(%eax)
    
    # 切换到新任务
    mov %edx, %esp
   10510:	89 d4                	mov    %edx,%esp
    
    # 恢复新任务寄存器
    popf
   10512:	9d                   	popf   
    pop %edi
   10513:	5f                   	pop    %edi
    pop %esi
   10514:	5e                   	pop    %esi
    pop %ebx
   10515:	5b                   	pop    %ebx
    pop %ebp
   10516:	5d                   	pop    %ebp
    
    ret
   10517:	c3                   	ret    

00010518 <get_full_context>:

# 获取当前完整上下文
# 参数: get_full_context(context_ptr)
    .global get_full_context
get_full_context:
    mov 4(%esp), %eax    # context_ptr
   10518:	8b 44 24 04          	mov    0x4(%esp),%eax
    
    # 保存所有寄存器
    mov %ebx, 0(%eax)
   1051c:	89 18                	mov    %ebx,(%eax)
    mov %ecx, 4(%eax)
   1051e:	89 48 04             	mov    %ecx,0x4(%eax)
    mov %edx, 8(%eax)
   10521:	89 50 08             	mov    %edx,0x8(%eax)
    mov %esi, 12(%eax)
   10524:	89 70 0c             	mov    %esi,0xc(%eax)
    mov %edi, 16(%eax)
   10527:	89 78 10             	mov    %edi,0x10(%eax)
    mov %ebp, 20(%eax)
   1052a:	89 68 14             	mov    %ebp,0x14(%eax)
    mov %esp, 24(%eax)
   1052d:	89 60 18             	mov    %esp,0x18(%eax)
    
    # 保存返回地址作为EIP
    mov (%esp), %edx
   10530:	8b 14 24             	mov    (%esp),%edx
    mov %edx, 28(%eax)
   10533:	89 50 1c             	mov    %edx,0x1c(%eax)
    
    # 保存EFLAGS
    pushf
   10536:	9c                   	pushf  
    pop %edx
   10537:	5a                   	pop    %edx
    mov %edx, 32(%eax)
   10538:	89 50 20             	mov    %edx,0x20(%eax)
    
    # 保存段寄存器
    mov %cs, %dx
   1053b:	66 8c ca             	mov    %cs,%dx
    mov %dx, 36(%eax)
   1053e:	66 89 50 24          	mov    %dx,0x24(%eax)
    mov %ds, %dx
   10542:	66 8c da             	mov    %ds,%dx
    mov %dx, 38(%eax)
   10545:	66 89 50 26          	mov    %dx,0x26(%eax)
    mov %ss, %dx
   10549:	66 8c d2             	mov    %ss,%dx
    mov %dx, 40(%eax)
   1054c:	66 89 50 28          	mov    %dx,0x28(%eax)
    
    ret
   10550:	c3                   	ret    

00010551 <switch_from_interrupt>:

# 从中断中切换任务 (修改中断返回帧)
# 参数: switch_from_interrupt(interrupt_frame_ptr, new_task_type, new_page_dir, new_cs, new_eip, new_eflags, new_ss, new_esp, new_ebx, new_ecx, new_edx, new_esi, new_edi, new_ebp)
    .global switch_from_interrupt
switch_from_interrupt:
    mov 4(%esp), %eax    # interrupt_frame_ptr
   10551:	8b 44 24 04          	mov    0x4(%esp),%eax
    mov 8(%esp), %edx    # new_task_type
   10555:	8b 54 24 08          	mov    0x8(%esp),%edx
    
    # 切换页目录
    mov 12(%esp), %ebx   # new_page_dir
   10559:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
    cmp $0, %ebx
   1055d:	83 fb 00             	cmp    $0x0,%ebx
    je skip_page_dir_int
   10560:	74 03                	je     10565 <skip_page_dir_int>
    mov %ebx, %cr3
   10562:	0f 22 db             	mov    %ebx,%cr3

00010565 <skip_page_dir_int>:
skip_page_dir_int:
    
    cmp $0, %edx         # 检查任务类型
   10565:	83 fa 00             	cmp    $0x0,%edx
    je modify_for_kernel
   10568:	74 02                	je     1056c <modify_for_kernel>
    jmp modify_for_user
   1056a:	eb 23                	jmp    1058f <modify_for_user>

0001056c <modify_for_kernel>:

modify_for_kernel:
    # 修改为内核任务返回
    # 假设中断帧格式: eip, cs, eflags, esp, ss (从低到高)
    mov 20(%esp), %ebx   # new_eip
   1056c:	8b 5c 24 14          	mov    0x14(%esp),%ebx
    mov %ebx, 0(%eax)    # 修改帧中的EIP
   10570:	89 18                	mov    %ebx,(%eax)
    mov $0x08, %bx       # 内核CS
   10572:	66 bb 08 00          	mov    $0x8,%bx
    mov %bx, 4(%eax)     # 修改帧中的CS
   10576:	66 89 58 04          	mov    %bx,0x4(%eax)
    mov 24(%esp), %ebx   # new_eflags
   1057a:	8b 5c 24 18          	mov    0x18(%esp),%ebx
    mov %ebx, 8(%eax)    # 修改帧中的EFLAGS
   1057e:	89 58 08             	mov    %ebx,0x8(%eax)
    
    # 设置内核段
    mov $0x10, %bx
   10581:	66 bb 10 00          	mov    $0x10,%bx
    mov %bx, %ds
   10585:	8e db                	mov    %ebx,%ds
    mov %bx, %es
   10587:	8e c3                	mov    %ebx,%es
    mov %bx, %fs
   10589:	8e e3                	mov    %ebx,%fs
    mov %bx, %gs
   1058b:	8e eb                	mov    %ebx,%gs
    
    jmp restore_registers
   1058d:	eb 32                	jmp    105c1 <restore_registers>

0001058f <modify_for_user>:

modify_for_user:
    # 修改为用户任务返回
    mov 20(%esp), %ebx   # new_eip
   1058f:	8b 5c 24 14          	mov    0x14(%esp),%ebx
    mov %ebx, 0(%eax)    # 修改帧中的EIP
   10593:	89 18                	mov    %ebx,(%eax)
    mov 16(%esp), %bx    # new_cs
   10595:	66 8b 5c 24 10       	mov    0x10(%esp),%bx
    mov %bx, 4(%eax)     # 修改帧中的CS
   1059a:	66 89 58 04          	mov    %bx,0x4(%eax)
    mov 24(%esp), %ebx   # new_eflags
   1059e:	8b 5c 24 18          	mov    0x18(%esp),%ebx
    mov %ebx, 8(%eax)    # 修改帧中的EFLAGS
   105a2:	89 58 08             	mov    %ebx,0x8(%eax)
    mov 32(%esp), %ebx   # new_esp
   105a5:	8b 5c 24 20          	mov    0x20(%esp),%ebx
    mov %ebx, 12(%eax)   # 修改帧中的ESP
   105a9:	89 58 0c             	mov    %ebx,0xc(%eax)
    mov 28(%esp), %bx    # new_ss
   105ac:	66 8b 5c 24 1c       	mov    0x1c(%esp),%bx
    mov %bx, 16(%eax)    # 修改帧中的SS
   105b1:	66 89 58 10          	mov    %bx,0x10(%eax)
    
    # 设置用户段
    mov $0x23, %bx
   105b5:	66 bb 23 00          	mov    $0x23,%bx
    mov %bx, %ds
   105b9:	8e db                	mov    %ebx,%ds
    mov %bx, %es
   105bb:	8e c3                	mov    %ebx,%es
    mov %bx, %fs
   105bd:	8e e3                	mov    %ebx,%fs
    mov %bx, %gs
   105bf:	8e eb                	mov    %ebx,%gs

000105c1 <restore_registers>:

restore_registers:
    # 恢复通用寄存器
    mov 36(%esp), %ebx   # new_ebx
   105c1:	8b 5c 24 24          	mov    0x24(%esp),%ebx
    mov 40(%esp), %ecx   # new_ecx
   105c5:	8b 4c 24 28          	mov    0x28(%esp),%ecx
    mov 44(%esp), %edx   # new_edx
   105c9:	8b 54 24 2c          	mov    0x2c(%esp),%edx
    mov 48(%esp), %esi   # new_esi
   105cd:	8b 74 24 30          	mov    0x30(%esp),%esi
    mov 52(%esp), %edi   # new_edi
   105d1:	8b 7c 24 34          	mov    0x34(%esp),%edi
    mov 56(%esp), %ebp   # new_ebp
   105d5:	8b 6c 24 38          	mov    0x38(%esp),%ebp
    
    ret                  # 返回到中断处理程序，让iret处理剩余工作
   105d9:	c3                   	ret    

000105da <exception_handler_syscall>:


    .global exception_handler_syscall
    .extern do_handler_syscall
exception_handler_syscall:
    pusha
   105da:	60                   	pusha  
    push %ds
   105db:	1e                   	push   %ds
    push %es
   105dc:	06                   	push   %es
    push %fs
   105dd:	0f a0                	push   %fs
    push %gs
   105df:	0f a8                	push   %gs
    pushf
   105e1:	9c                   	pushf  


    mov %esp, %eax
   105e2:	89 e0                	mov    %esp,%eax
    push %eax
   105e4:	50                   	push   %eax
    call do_handler_syscall
   105e5:	e8 ed 09 00 00       	call   10fd7 <do_handler_syscall>
    add $(1*4), %esp
   105ea:	83 c4 04             	add    $0x4,%esp
    popf
   105ed:	9d                   	popf   
    pop %gs
   105ee:	0f a9                	pop    %gs
    pop %fs
   105f0:	0f a1                	pop    %fs
    pop %es
   105f2:	07                   	pop    %es
    pop %ds
   105f3:	1f                   	pop    %ds
    popa
   105f4:	61                   	popa   
    retf $(5 * 4)
   105f5:	ca 14 00             	lret   $0x14

000105f8 <down2>:
#ifndef KLIB_H
#define KLIB_H
#include <stdarg.h>
#include "comm/types.h"
static inline uint32_t down2(uint32_t size, uint32_t bound)
{
   105f8:	55                   	push   %ebp
   105f9:	89 e5                	mov    %esp,%ebp
    return size & ~(bound - 1);
   105fb:	8b 45 0c             	mov    0xc(%ebp),%eax
   105fe:	f7 d8                	neg    %eax
   10600:	23 45 08             	and    0x8(%ebp),%eax
}
   10603:	5d                   	pop    %ebp
   10604:	c3                   	ret    

00010605 <up2>:
static inline uint32_t up2(uint32_t size, uint32_t bound)
{
   10605:	55                   	push   %ebp
   10606:	89 e5                	mov    %esp,%ebp
    return (size + bound - 1) & ~(bound - 1);
   10608:	8b 55 08             	mov    0x8(%ebp),%edx
   1060b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1060e:	01 d0                	add    %edx,%eax
   10610:	8d 50 ff             	lea    -0x1(%eax),%edx
   10613:	8b 45 0c             	mov    0xc(%ebp),%eax
   10616:	f7 d8                	neg    %eax
   10618:	21 d0                	and    %edx,%eax
}
   1061a:	5d                   	pop    %ebp
   1061b:	c3                   	ret    

0001061c <write_cr3>:
    __asm__ __volatile__("mov %%cr3, %[v]":[v]"=r"(cr3));
    return cr3;
}

static inline void write_cr3(uint32_t v)
{
   1061c:	55                   	push   %ebp
   1061d:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("mov %[v], %%cr3"::[v]"r"(v));
   1061f:	8b 45 08             	mov    0x8(%ebp),%eax
   10622:	0f 22 d8             	mov    %eax,%cr3
}
   10625:	90                   	nop
   10626:	5d                   	pop    %ebp
   10627:	c3                   	ret    

00010628 <pde_index>:
        uint32_t phy_page_addr : 20;
    }
}pte_t;

static inline uint32_t pde_index(uint32_t vaddr)
{
   10628:	55                   	push   %ebp
   10629:	89 e5                	mov    %esp,%ebp
    return (vaddr >> 22) & 0x3FF;
   1062b:	8b 45 08             	mov    0x8(%ebp),%eax
   1062e:	c1 e8 16             	shr    $0x16,%eax
}
   10631:	5d                   	pop    %ebp
   10632:	c3                   	ret    

00010633 <pte_index>:

static inline uint32_t pte_index(uint32_t vaddr)
{
   10633:	55                   	push   %ebp
   10634:	89 e5                	mov    %esp,%ebp
    return (vaddr >> 12) & 0x3FF;
   10636:	8b 45 08             	mov    0x8(%ebp),%eax
   10639:	c1 e8 0c             	shr    $0xc,%eax
   1063c:	25 ff 03 00 00       	and    $0x3ff,%eax
}
   10641:	5d                   	pop    %ebp
   10642:	c3                   	ret    

00010643 <pde_paddr>:

static inline uint32_t pde_paddr(pde_t * pde)
{
   10643:	55                   	push   %ebp
   10644:	89 e5                	mov    %esp,%ebp
    return (pde->phy_pt_addr << 12) ;
   10646:	8b 45 08             	mov    0x8(%ebp),%eax
   10649:	8b 00                	mov    (%eax),%eax
   1064b:	c1 e8 0c             	shr    $0xc,%eax
   1064e:	c1 e0 0c             	shl    $0xc,%eax
}
   10651:	5d                   	pop    %ebp
   10652:	c3                   	ret    

00010653 <pte_paddr>:

static inline uint32_t pte_paddr(pte_t * pte)
{
   10653:	55                   	push   %ebp
   10654:	89 e5                	mov    %esp,%ebp
    return (pte->phy_page_addr << 12) ;
   10656:	8b 45 08             	mov    0x8(%ebp),%eax
   10659:	8b 00                	mov    (%eax),%eax
   1065b:	c1 e8 0c             	shr    $0xc,%eax
   1065e:	c1 e0 0c             	shl    $0xc,%eax
}
   10661:	5d                   	pop    %ebp
   10662:	c3                   	ret    

00010663 <mmu_set_page_dir>:
static inline void mmu_set_page_dir(uint32_t paddr)
{
   10663:	55                   	push   %ebp
   10664:	89 e5                	mov    %esp,%ebp
    write_cr3(paddr);
   10666:	ff 75 08             	pushl  0x8(%ebp)
   10669:	e8 ae ff ff ff       	call   1061c <write_cr3>
   1066e:	83 c4 04             	add    $0x4,%esp
}
   10671:	90                   	nop
   10672:	c9                   	leave  
   10673:	c3                   	ret    

00010674 <get_pte_perm>:

static inline uint32_t get_pte_perm(pte_t * pte)
{
   10674:	55                   	push   %ebp
   10675:	89 e5                	mov    %esp,%ebp
    return (pte->v & 0x3ff);
   10677:	8b 45 08             	mov    0x8(%ebp),%eax
   1067a:	8b 00                	mov    (%eax),%eax
   1067c:	25 ff 03 00 00       	and    $0x3ff,%eax
}
   10681:	5d                   	pop    %ebp
   10682:	c3                   	ret    

00010683 <addr_alloc_init>:
static addr_alloc_t paddr_alloc;

static pde_t kernel_page_dir[PDE_CNT] __attribute__((aligned(MEM_PAGE_SIZE)));
static void addr_alloc_init(addr_alloc_t *addr_alloc,uint8_t* bits, 
    uint32_t start, uint32_t size, uint32_t page_size)
{
   10683:	55                   	push   %ebp
   10684:	89 e5                	mov    %esp,%ebp
   10686:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&addr_alloc->mutex);
   10689:	8b 45 08             	mov    0x8(%ebp),%eax
   1068c:	83 ec 0c             	sub    $0xc,%esp
   1068f:	50                   	push   %eax
   10690:	e8 a5 2c 00 00       	call   1333a <mutex_init>
   10695:	83 c4 10             	add    $0x10,%esp
    
    addr_alloc->start = start;
   10698:	8b 45 08             	mov    0x8(%ebp),%eax
   1069b:	8b 55 10             	mov    0x10(%ebp),%edx
   1069e:	89 50 1c             	mov    %edx,0x1c(%eax)
    addr_alloc->size = size;
   106a1:	8b 45 08             	mov    0x8(%ebp),%eax
   106a4:	8b 55 14             	mov    0x14(%ebp),%edx
   106a7:	89 50 20             	mov    %edx,0x20(%eax)
    addr_alloc->page_size = page_size;
   106aa:	8b 45 08             	mov    0x8(%ebp),%eax
   106ad:	8b 55 18             	mov    0x18(%ebp),%edx
   106b0:	89 50 24             	mov    %edx,0x24(%eax)
    bitmap_init(&addr_alloc->bitmap, bits, size / page_size, 0);
   106b3:	8b 45 14             	mov    0x14(%ebp),%eax
   106b6:	ba 00 00 00 00       	mov    $0x0,%edx
   106bb:	f7 75 18             	divl   0x18(%ebp)
   106be:	89 c2                	mov    %eax,%edx
   106c0:	8b 45 08             	mov    0x8(%ebp),%eax
   106c3:	83 c0 14             	add    $0x14,%eax
   106c6:	6a 00                	push   $0x0
   106c8:	52                   	push   %edx
   106c9:	ff 75 0c             	pushl  0xc(%ebp)
   106cc:	50                   	push   %eax
   106cd:	e8 38 2f 00 00       	call   1360a <bitmap_init>
   106d2:	83 c4 10             	add    $0x10,%esp
    
}
   106d5:	90                   	nop
   106d6:	c9                   	leave  
   106d7:	c3                   	ret    

000106d8 <addr_alloc_page>:

static uint32_t addr_alloc_page(addr_alloc_t *addr_alloc, int page_count)
{
   106d8:	55                   	push   %ebp
   106d9:	89 e5                	mov    %esp,%ebp
   106db:	83 ec 18             	sub    $0x18,%esp
    uint32_t  addr = 0;
   106de:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    //mutex_lock(&addr_alloc->mutex);
    irq_state_t state = irq_enter_protection();
   106e5:	e8 32 28 00 00       	call   12f1c <irq_enter_protection>
   106ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int page_index = bitmap_alloc_nbits(&addr_alloc->bitmap, 0, page_count);
   106ed:	8b 45 08             	mov    0x8(%ebp),%eax
   106f0:	83 c0 14             	add    $0x14,%eax
   106f3:	83 ec 04             	sub    $0x4,%esp
   106f6:	ff 75 0c             	pushl  0xc(%ebp)
   106f9:	6a 00                	push   $0x0
   106fb:	50                   	push   %eax
   106fc:	e8 82 30 00 00       	call   13783 <bitmap_alloc_nbits>
   10701:	83 c4 10             	add    $0x10,%esp
   10704:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (page_index >= 0)
   10707:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1070b:	78 17                	js     10724 <addr_alloc_page+0x4c>
    {
        addr = addr_alloc->start + page_index * addr_alloc->page_size;
   1070d:	8b 45 08             	mov    0x8(%ebp),%eax
   10710:	8b 50 1c             	mov    0x1c(%eax),%edx
   10713:	8b 45 08             	mov    0x8(%ebp),%eax
   10716:	8b 48 24             	mov    0x24(%eax),%ecx
   10719:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1071c:	0f af c1             	imul   %ecx,%eax
   1071f:	01 d0                	add    %edx,%eax
   10721:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    irq_leave_protection(state);
   10724:	83 ec 0c             	sub    $0xc,%esp
   10727:	ff 75 f0             	pushl  -0x10(%ebp)
   1072a:	e8 05 28 00 00       	call   12f34 <irq_leave_protection>
   1072f:	83 c4 10             	add    $0x10,%esp
    //mutex_unlock(&addr_alloc->mutex);
    return addr;
   10732:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10735:	c9                   	leave  
   10736:	c3                   	ret    

00010737 <addr_free_page>:

static void addr_free_page(addr_alloc_t *addr_alloc, uint32_t addr, int page_count)
{
   10737:	55                   	push   %ebp
   10738:	89 e5                	mov    %esp,%ebp
   1073a:	53                   	push   %ebx
   1073b:	83 ec 14             	sub    $0x14,%esp
    //mutex_lock(&addr_alloc->mutex);
    irq_state_t state = irq_enter_protection();
   1073e:	e8 d9 27 00 00       	call   12f1c <irq_enter_protection>
   10743:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t page_index = (addr - addr_alloc->start) / addr_alloc->page_size;
   10746:	8b 45 08             	mov    0x8(%ebp),%eax
   10749:	8b 40 1c             	mov    0x1c(%eax),%eax
   1074c:	8b 55 0c             	mov    0xc(%ebp),%edx
   1074f:	89 d1                	mov    %edx,%ecx
   10751:	29 c1                	sub    %eax,%ecx
   10753:	8b 45 08             	mov    0x8(%ebp),%eax
   10756:	8b 58 24             	mov    0x24(%eax),%ebx
   10759:	89 c8                	mov    %ecx,%eax
   1075b:	ba 00 00 00 00       	mov    $0x0,%edx
   10760:	f7 f3                	div    %ebx
   10762:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bitmap_set_bit(&addr_alloc->bitmap, page_index, page_count,0);
   10765:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10768:	8b 55 08             	mov    0x8(%ebp),%edx
   1076b:	83 c2 14             	add    $0x14,%edx
   1076e:	6a 00                	push   $0x0
   10770:	ff 75 10             	pushl  0x10(%ebp)
   10773:	50                   	push   %eax
   10774:	52                   	push   %edx
   10775:	e8 1a 2f 00 00       	call   13694 <bitmap_set_bit>
   1077a:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(state);
   1077d:	83 ec 0c             	sub    $0xc,%esp
   10780:	ff 75 f4             	pushl  -0xc(%ebp)
   10783:	e8 ac 27 00 00       	call   12f34 <irq_leave_protection>
   10788:	83 c4 10             	add    $0x10,%esp
    //mutex_unlock(&addr_alloc->mutex);
}
   1078b:	90                   	nop
   1078c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1078f:	c9                   	leave  
   10790:	c3                   	ret    

00010791 <show_mem_info>:

void show_mem_info(boot_info_t *boot_info)
{
   10791:	55                   	push   %ebp
   10792:	89 e5                	mov    %esp,%ebp
   10794:	53                   	push   %ebx
   10795:	83 ec 14             	sub    $0x14,%esp
    for(int i = 0; i < boot_info->ram_region_count; i++)
   10798:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1079f:	eb 42                	jmp    107e3 <show_mem_info+0x52>
    {
        log_printf("ram region %d: 0x%x - 0x%x, %d\n", i, boot_info->ram_region_cfg[i].start, 
   107a1:	8b 45 08             	mov    0x8(%ebp),%eax
   107a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
   107a7:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
        boot_info->ram_region_cfg[i].start + boot_info->ram_region_cfg[i].size,
   107ab:	8b 45 08             	mov    0x8(%ebp),%eax
   107ae:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   107b1:	8b 1c c8             	mov    (%eax,%ecx,8),%ebx
   107b4:	8b 45 08             	mov    0x8(%ebp),%eax
   107b7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   107ba:	8b 44 c8 04          	mov    0x4(%eax,%ecx,8),%eax
        log_printf("ram region %d: 0x%x - 0x%x, %d\n", i, boot_info->ram_region_cfg[i].start, 
   107be:	01 c3                	add    %eax,%ebx
   107c0:	8b 45 08             	mov    0x8(%ebp),%eax
   107c3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   107c6:	8b 04 c8             	mov    (%eax,%ecx,8),%eax
   107c9:	83 ec 0c             	sub    $0xc,%esp
   107cc:	52                   	push   %edx
   107cd:	53                   	push   %ebx
   107ce:	50                   	push   %eax
   107cf:	ff 75 f4             	pushl  -0xc(%ebp)
   107d2:	68 a0 41 01 00       	push   $0x141a0
   107d7:	e8 eb 38 00 00       	call   140c7 <log_printf>
   107dc:	83 c4 20             	add    $0x20,%esp
    for(int i = 0; i < boot_info->ram_region_count; i++)
   107df:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   107e3:	8b 45 08             	mov    0x8(%ebp),%eax
   107e6:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   107ec:	39 45 f4             	cmp    %eax,-0xc(%ebp)
   107ef:	7c b0                	jl     107a1 <show_mem_info+0x10>
        boot_info->ram_region_cfg[i].size);
    }
}
   107f1:	90                   	nop
   107f2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   107f5:	c9                   	leave  
   107f6:	c3                   	ret    

000107f7 <total_mem_size>:
static uint32_t total_mem_size(boot_info_t *boot_info)
{
   107f7:	55                   	push   %ebp
   107f8:	89 e5                	mov    %esp,%ebp
   107fa:	83 ec 10             	sub    $0x10,%esp
    uint32_t total_size = 0;
   107fd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for(int i = 0; i < boot_info->ram_region_count; i++)
   10804:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1080b:	eb 11                	jmp    1081e <total_mem_size+0x27>
    {
        total_size += boot_info->ram_region_cfg[i].size;
   1080d:	8b 45 08             	mov    0x8(%ebp),%eax
   10810:	8b 55 f8             	mov    -0x8(%ebp),%edx
   10813:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
   10817:	01 45 fc             	add    %eax,-0x4(%ebp)
    for(int i = 0; i < boot_info->ram_region_count; i++)
   1081a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1081e:	8b 45 08             	mov    0x8(%ebp),%eax
   10821:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   10827:	39 45 f8             	cmp    %eax,-0x8(%ebp)
   1082a:	7c e1                	jl     1080d <total_mem_size+0x16>
    }
    return total_size;
   1082c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1082f:	c9                   	leave  
   10830:	c3                   	ret    

00010831 <find_pte>:

pte_t * find_pte(pde_t *page_dir, uint32_t vaddr, int alloc)
{
   10831:	55                   	push   %ebp
   10832:	89 e5                	mov    %esp,%ebp
   10834:	83 ec 18             	sub    $0x18,%esp
    pte_t *page_table = (pte_t *)0;
   10837:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    pde_t *pde = page_dir + pde_index(vaddr);
   1083e:	ff 75 0c             	pushl  0xc(%ebp)
   10841:	e8 e2 fd ff ff       	call   10628 <pde_index>
   10846:	83 c4 04             	add    $0x4,%esp
   10849:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10850:	8b 45 08             	mov    0x8(%ebp),%eax
   10853:	01 d0                	add    %edx,%eax
   10855:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (pde->present)
   10858:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1085b:	0f b6 00             	movzbl (%eax),%eax
   1085e:	83 e0 01             	and    $0x1,%eax
   10861:	84 c0                	test   %al,%al
   10863:	74 10                	je     10875 <find_pte+0x44>
    {
        page_table = (pte_t *)pde_paddr(pde);
   10865:	ff 75 f0             	pushl  -0x10(%ebp)
   10868:	e8 d6 fd ff ff       	call   10643 <pde_paddr>
   1086d:	83 c4 04             	add    $0x4,%esp
   10870:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10873:	eb 57                	jmp    108cc <find_pte+0x9b>
    }
    else
    {
        if (alloc == 0)
   10875:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   10879:	75 07                	jne    10882 <find_pte+0x51>
        {
            return (pte_t *)0;
   1087b:	b8 00 00 00 00       	mov    $0x0,%eax
   10880:	eb 64                	jmp    108e6 <find_pte+0xb5>
        }
        else
        {
            uint32_t pg_paddr = addr_alloc_page(&paddr_alloc, 1);
   10882:	83 ec 08             	sub    $0x8,%esp
   10885:	6a 01                	push   $0x1
   10887:	68 00 60 01 00       	push   $0x16000
   1088c:	e8 47 fe ff ff       	call   106d8 <addr_alloc_page>
   10891:	83 c4 10             	add    $0x10,%esp
   10894:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (pg_paddr == 0)
   10897:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1089b:	75 07                	jne    108a4 <find_pte+0x73>
            {
                return (pte_t *)0;
   1089d:	b8 00 00 00 00       	mov    $0x0,%eax
   108a2:	eb 42                	jmp    108e6 <find_pte+0xb5>
            }
            pde->v = pg_paddr | PDE_P | PDE_W | PDE_U;
   108a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   108a7:	83 c8 07             	or     $0x7,%eax
   108aa:	89 c2                	mov    %eax,%edx
   108ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
   108af:	89 10                	mov    %edx,(%eax)
            page_table = (pte_t *)pg_paddr;
   108b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   108b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
            kernel_memset(page_table, 0, MEM_PAGE_SIZE);        
   108b7:	83 ec 04             	sub    $0x4,%esp
   108ba:	68 00 10 00 00       	push   $0x1000
   108bf:	6a 00                	push   $0x0
   108c1:	ff 75 f4             	pushl  -0xc(%ebp)
   108c4:	e8 1c 31 00 00       	call   139e5 <kernel_memset>
   108c9:	83 c4 10             	add    $0x10,%esp
        }
    }
    return page_table + pte_index(vaddr);
   108cc:	83 ec 0c             	sub    $0xc,%esp
   108cf:	ff 75 0c             	pushl  0xc(%ebp)
   108d2:	e8 5c fd ff ff       	call   10633 <pte_index>
   108d7:	83 c4 10             	add    $0x10,%esp
   108da:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   108e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   108e4:	01 d0                	add    %edx,%eax
    
    
}
   108e6:	c9                   	leave  
   108e7:	c3                   	ret    

000108e8 <memory_create_map>:
int memory_create_map(pde_t *page_dir, uint32_t vaddr, uint32_t paddr, int count, uint32_t perm)
{
   108e8:	55                   	push   %ebp
   108e9:	89 e5                	mov    %esp,%ebp
   108eb:	83 ec 18             	sub    $0x18,%esp
    for(int i = 0; i < count; i++)
   108ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   108f5:	eb 45                	jmp    1093c <memory_create_map+0x54>
    {
        //log_printf("create map %d: 0x%x - 0x%x, 0x%x, perm :%d\n", i, vaddr, vaddr + MEM_PAGE_SIZE, paddr,perm);
        pte_t * pte = find_pte(page_dir, vaddr,1);
   108f7:	83 ec 04             	sub    $0x4,%esp
   108fa:	6a 01                	push   $0x1
   108fc:	ff 75 0c             	pushl  0xc(%ebp)
   108ff:	ff 75 08             	pushl  0x8(%ebp)
   10902:	e8 2a ff ff ff       	call   10831 <find_pte>
   10907:	83 c4 10             	add    $0x10,%esp
   1090a:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (pte == (pte_t *)0)
   1090d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10911:	75 07                	jne    1091a <memory_create_map+0x32>
        {
            return -1;
   10913:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10918:	eb 2f                	jmp    10949 <memory_create_map+0x61>
        }
        //log_printf("pte addr: 0x%x\n", pte);
        ASSERT(pte->present == 0);
        pte->v = paddr | perm | PTE_P;
   1091a:	8b 45 10             	mov    0x10(%ebp),%eax
   1091d:	0b 45 18             	or     0x18(%ebp),%eax
   10920:	83 c8 01             	or     $0x1,%eax
   10923:	89 c2                	mov    %eax,%edx
   10925:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10928:	89 10                	mov    %edx,(%eax)

        vaddr += MEM_PAGE_SIZE;
   1092a:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
        paddr += MEM_PAGE_SIZE;
   10931:	81 45 10 00 10 00 00 	addl   $0x1000,0x10(%ebp)
    for(int i = 0; i < count; i++)
   10938:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1093c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1093f:	3b 45 14             	cmp    0x14(%ebp),%eax
   10942:	7c b3                	jl     108f7 <memory_create_map+0xf>
    }
    return 0;
   10944:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10949:	c9                   	leave  
   1094a:	c3                   	ret    

0001094b <create_kernel_table>:
void create_kernel_table(void)
{
   1094b:	55                   	push   %ebp
   1094c:	89 e5                	mov    %esp,%ebp
   1094e:	83 ec 28             	sub    $0x28,%esp
        {kernel_base,s_text,kernel_base,PTE_W},
        {s_text,e_text,s_text,0},
        {s_data,(void *)MEM_EBDA_START,s_data,PTE_W},
        {(void *)MEM_EXT_START,(void *)MEM_EXT_END,(void *)MEM_EXT_START,PTE_W}
    };
    for(int i = 0; i < sizeof(kernel_map) / sizeof(memory_map_t); i++)
   10951:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10958:	e9 86 00 00 00       	jmp    109e3 <create_kernel_table+0x98>
    {
        memory_map_t *map = &kernel_map[i];
   1095d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10960:	c1 e0 04             	shl    $0x4,%eax
   10963:	05 00 50 01 00       	add    $0x15000,%eax
   10968:	89 45 f0             	mov    %eax,-0x10(%ebp)
        uint32_t vstart = down2((uint32_t)map->vstart, MEM_PAGE_SIZE);
   1096b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1096e:	8b 00                	mov    (%eax),%eax
   10970:	68 00 10 00 00       	push   $0x1000
   10975:	50                   	push   %eax
   10976:	e8 7d fc ff ff       	call   105f8 <down2>
   1097b:	83 c4 08             	add    $0x8,%esp
   1097e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        uint32_t vend = up2((uint32_t)map->vend, MEM_PAGE_SIZE);
   10981:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10984:	8b 40 04             	mov    0x4(%eax),%eax
   10987:	68 00 10 00 00       	push   $0x1000
   1098c:	50                   	push   %eax
   1098d:	e8 73 fc ff ff       	call   10605 <up2>
   10992:	83 c4 08             	add    $0x8,%esp
   10995:	89 45 e8             	mov    %eax,-0x18(%ebp)
        uint32_t pstart = down2((uint32_t)map->pstart, MEM_PAGE_SIZE);
   10998:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1099b:	8b 40 08             	mov    0x8(%eax),%eax
   1099e:	68 00 10 00 00       	push   $0x1000
   109a3:	50                   	push   %eax
   109a4:	e8 4f fc ff ff       	call   105f8 <down2>
   109a9:	83 c4 08             	add    $0x8,%esp
   109ac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int page_count = (vend - vstart) / MEM_PAGE_SIZE;
   109af:	8b 45 e8             	mov    -0x18(%ebp),%eax
   109b2:	2b 45 ec             	sub    -0x14(%ebp),%eax
   109b5:	c1 e8 0c             	shr    $0xc,%eax
   109b8:	89 45 e0             	mov    %eax,-0x20(%ebp)
        memory_create_map(kernel_page_dir,vstart, (uint32_t)map->pstart,page_count,map->perm);
   109bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   109be:	8b 40 0c             	mov    0xc(%eax),%eax
   109c1:	8b 55 f0             	mov    -0x10(%ebp),%edx
   109c4:	8b 52 08             	mov    0x8(%edx),%edx
   109c7:	83 ec 0c             	sub    $0xc,%esp
   109ca:	50                   	push   %eax
   109cb:	ff 75 e0             	pushl  -0x20(%ebp)
   109ce:	52                   	push   %edx
   109cf:	ff 75 ec             	pushl  -0x14(%ebp)
   109d2:	68 00 70 01 00       	push   $0x17000
   109d7:	e8 0c ff ff ff       	call   108e8 <memory_create_map>
   109dc:	83 c4 20             	add    $0x20,%esp
    for(int i = 0; i < sizeof(kernel_map) / sizeof(memory_map_t); i++)
   109df:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   109e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   109e6:	83 f8 03             	cmp    $0x3,%eax
   109e9:	0f 86 6e ff ff ff    	jbe    1095d <create_kernel_table+0x12>
    }
}
   109ef:	90                   	nop
   109f0:	c9                   	leave  
   109f1:	c3                   	ret    

000109f2 <memory_create_user_space>:

uint32_t memory_create_user_space()
{
   109f2:	55                   	push   %ebp
   109f3:	89 e5                	mov    %esp,%ebp
   109f5:	83 ec 18             	sub    $0x18,%esp
    pde_t * page_dir = (pde_t *)addr_alloc_page(&paddr_alloc, 1);
   109f8:	83 ec 08             	sub    $0x8,%esp
   109fb:	6a 01                	push   $0x1
   109fd:	68 00 60 01 00       	push   $0x16000
   10a02:	e8 d1 fc ff ff       	call   106d8 <addr_alloc_page>
   10a07:	83 c4 10             	add    $0x10,%esp
   10a0a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(page_dir == (pde_t *)0)
   10a0d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10a11:	75 07                	jne    10a1a <memory_create_user_space+0x28>
    {
        return 0;
   10a13:	b8 00 00 00 00       	mov    $0x0,%eax
   10a18:	eb 5b                	jmp    10a75 <memory_create_user_space+0x83>
    }
    kernel_memset((void *)page_dir, 0, MEM_PAGE_SIZE);
   10a1a:	83 ec 04             	sub    $0x4,%esp
   10a1d:	68 00 10 00 00       	push   $0x1000
   10a22:	6a 00                	push   $0x0
   10a24:	ff 75 f0             	pushl  -0x10(%ebp)
   10a27:	e8 b9 2f 00 00       	call   139e5 <kernel_memset>
   10a2c:	83 c4 10             	add    $0x10,%esp
    uint32_t user_pde_start = pde_index(MEMORY_TASK_BASE);
   10a2f:	83 ec 0c             	sub    $0xc,%esp
   10a32:	68 00 00 00 80       	push   $0x80000000
   10a37:	e8 ec fb ff ff       	call   10628 <pde_index>
   10a3c:	83 c4 10             	add    $0x10,%esp
   10a3f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(int i = 0; i < user_pde_start; i++)
   10a42:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10a49:	eb 1f                	jmp    10a6a <memory_create_user_space+0x78>
    {
        page_dir[i].v = kernel_page_dir[i].v;
   10a4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10a4e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10a55:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10a58:	01 c2                	add    %eax,%edx
   10a5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10a5d:	8b 04 85 00 70 01 00 	mov    0x17000(,%eax,4),%eax
   10a64:	89 02                	mov    %eax,(%edx)
    for(int i = 0; i < user_pde_start; i++)
   10a66:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10a6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10a6d:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   10a70:	77 d9                	ja     10a4b <memory_create_user_space+0x59>
    }
    return (uint32_t)page_dir;
   10a72:	8b 45 f0             	mov    -0x10(%ebp),%eax
    
}
   10a75:	c9                   	leave  
   10a76:	c3                   	ret    

00010a77 <memory_init>:
void memory_init(boot_info_t *boot_info)
{
   10a77:	55                   	push   %ebp
   10a78:	89 e5                	mov    %esp,%ebp
   10a7a:	83 ec 18             	sub    $0x18,%esp
    extern uint8_t *mem_free_start;
    //log_printf("mem init\n");
    show_mem_info(boot_info);
   10a7d:	83 ec 0c             	sub    $0xc,%esp
   10a80:	ff 75 08             	pushl  0x8(%ebp)
   10a83:	e8 09 fd ff ff       	call   10791 <show_mem_info>
   10a88:	83 c4 10             	add    $0x10,%esp

    uint8_t *mem_free = (uint8_t *)&mem_free_start;
   10a8b:	c7 45 f4 fe e3 03 00 	movl   $0x3e3fe,-0xc(%ebp)
    uint32_t mem_up1MB_free_size = total_mem_size(boot_info) - MEM_EXT_START;
   10a92:	83 ec 0c             	sub    $0xc,%esp
   10a95:	ff 75 08             	pushl  0x8(%ebp)
   10a98:	e8 5a fd ff ff       	call   107f7 <total_mem_size>
   10a9d:	83 c4 10             	add    $0x10,%esp
   10aa0:	2d 00 00 10 00       	sub    $0x100000,%eax
   10aa5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    mem_up1MB_free_size = down2(mem_up1MB_free_size,MEM_PAGE_SIZE);
   10aa8:	83 ec 08             	sub    $0x8,%esp
   10aab:	68 00 10 00 00       	push   $0x1000
   10ab0:	ff 75 f0             	pushl  -0x10(%ebp)
   10ab3:	e8 40 fb ff ff       	call   105f8 <down2>
   10ab8:	83 c4 10             	add    $0x10,%esp
   10abb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    //log_printf("free memory begin addr: 0x%x ,size 0x%x\n", MEM_EXT_START, mem_up1MB_free_size);
    
    addr_alloc_init(&paddr_alloc, mem_free, MEM_EXT_START, mem_up1MB_free_size, MEM_PAGE_SIZE);
   10abe:	83 ec 0c             	sub    $0xc,%esp
   10ac1:	68 00 10 00 00       	push   $0x1000
   10ac6:	ff 75 f0             	pushl  -0x10(%ebp)
   10ac9:	68 00 00 10 00       	push   $0x100000
   10ace:	ff 75 f4             	pushl  -0xc(%ebp)
   10ad1:	68 00 60 01 00       	push   $0x16000
   10ad6:	e8 a8 fb ff ff       	call   10683 <addr_alloc_init>
   10adb:	83 c4 20             	add    $0x20,%esp
    mem_free += bitmap_byte_count(paddr_alloc.size / MEM_PAGE_SIZE);
   10ade:	a1 20 60 01 00       	mov    0x16020,%eax
   10ae3:	c1 e8 0c             	shr    $0xc,%eax
   10ae6:	83 ec 0c             	sub    $0xc,%esp
   10ae9:	50                   	push   %eax
   10aea:	e8 05 2b 00 00       	call   135f4 <bitmap_byte_count>
   10aef:	83 c4 10             	add    $0x10,%esp
   10af2:	01 45 f4             	add    %eax,-0xc(%ebp)
    
    ASSERT(mem_free < (uint8_t *)MEM_EBDA_START);

    create_kernel_table();
   10af5:	e8 51 fe ff ff       	call   1094b <create_kernel_table>
    mmu_set_page_dir((uint32_t)kernel_page_dir);
   10afa:	b8 00 70 01 00       	mov    $0x17000,%eax
   10aff:	83 ec 0c             	sub    $0xc,%esp
   10b02:	50                   	push   %eax
   10b03:	e8 5b fb ff ff       	call   10663 <mmu_set_page_dir>
   10b08:	83 c4 10             	add    $0x10,%esp
}
   10b0b:	90                   	nop
   10b0c:	c9                   	leave  
   10b0d:	c3                   	ret    

00010b0e <memory_alloc_page>:

uint32_t memory_alloc_page (void) {
   10b0e:	55                   	push   %ebp
   10b0f:	89 e5                	mov    %esp,%ebp
   10b11:	83 ec 08             	sub    $0x8,%esp
    // 内核空间虚拟地址与物理地址相同
    return addr_alloc_page(&paddr_alloc, 1);
   10b14:	83 ec 08             	sub    $0x8,%esp
   10b17:	6a 01                	push   $0x1
   10b19:	68 00 60 01 00       	push   $0x16000
   10b1e:	e8 b5 fb ff ff       	call   106d8 <addr_alloc_page>
   10b23:	83 c4 10             	add    $0x10,%esp
}
   10b26:	c9                   	leave  
   10b27:	c3                   	ret    

00010b28 <current_page_dir>:
static pde_t * current_page_dir(void)
{
   10b28:	55                   	push   %ebp
   10b29:	89 e5                	mov    %esp,%ebp
   10b2b:	83 ec 08             	sub    $0x8,%esp
    return (pde_t *)(task_current()->tss.cr3);
   10b2e:	e8 9b 0b 00 00       	call   116ce <task_current>
   10b33:	8b 40 78             	mov    0x78(%eax),%eax
}
   10b36:	c9                   	leave  
   10b37:	c3                   	ret    

00010b38 <memory_free_page>:
void memory_free_page (uint32_t addr) {
   10b38:	55                   	push   %ebp
   10b39:	89 e5                	mov    %esp,%ebp
   10b3b:	83 ec 18             	sub    $0x18,%esp
    if (addr < MEMORY_TASK_BASE) {
   10b3e:	8b 45 08             	mov    0x8(%ebp),%eax
   10b41:	85 c0                	test   %eax,%eax
   10b43:	78 17                	js     10b5c <memory_free_page+0x24>
        // 内核空间，直接释放
        addr_free_page(&paddr_alloc, addr, 1);
   10b45:	83 ec 04             	sub    $0x4,%esp
   10b48:	6a 01                	push   $0x1
   10b4a:	ff 75 08             	pushl  0x8(%ebp)
   10b4d:	68 00 60 01 00       	push   $0x16000
   10b52:	e8 e0 fb ff ff       	call   10737 <addr_free_page>
   10b57:	83 c4 10             	add    $0x10,%esp
        addr_free_page(&paddr_alloc, pte_paddr(pte), 1);

        // 释放页表
        pte->v = 0;
    }
}
   10b5a:	eb 43                	jmp    10b9f <memory_free_page+0x67>
        pte_t * pte = find_pte(current_page_dir(), addr, 0);
   10b5c:	e8 c7 ff ff ff       	call   10b28 <current_page_dir>
   10b61:	83 ec 04             	sub    $0x4,%esp
   10b64:	6a 00                	push   $0x0
   10b66:	ff 75 08             	pushl  0x8(%ebp)
   10b69:	50                   	push   %eax
   10b6a:	e8 c2 fc ff ff       	call   10831 <find_pte>
   10b6f:	83 c4 10             	add    $0x10,%esp
   10b72:	89 45 f4             	mov    %eax,-0xc(%ebp)
        addr_free_page(&paddr_alloc, pte_paddr(pte), 1);
   10b75:	83 ec 0c             	sub    $0xc,%esp
   10b78:	ff 75 f4             	pushl  -0xc(%ebp)
   10b7b:	e8 d3 fa ff ff       	call   10653 <pte_paddr>
   10b80:	83 c4 10             	add    $0x10,%esp
   10b83:	83 ec 04             	sub    $0x4,%esp
   10b86:	6a 01                	push   $0x1
   10b88:	50                   	push   %eax
   10b89:	68 00 60 01 00       	push   $0x16000
   10b8e:	e8 a4 fb ff ff       	call   10737 <addr_free_page>
   10b93:	83 c4 10             	add    $0x10,%esp
        pte->v = 0;
   10b96:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10b99:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
   10b9f:	90                   	nop
   10ba0:	c9                   	leave  
   10ba1:	c3                   	ret    

00010ba2 <memory_alloc_for_page_dir>:



int memory_alloc_for_page_dir(uint32_t page_dir,uint32_t vaddr,uint32_t size,int perm)
{
   10ba2:	55                   	push   %ebp
   10ba3:	89 e5                	mov    %esp,%ebp
   10ba5:	83 ec 28             	sub    $0x28,%esp
    uint32_t current_vaddr = vaddr;
   10ba8:	8b 45 0c             	mov    0xc(%ebp),%eax
   10bab:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int page_count = up2(size,MEM_PAGE_SIZE) / MEM_PAGE_SIZE;
   10bae:	68 00 10 00 00       	push   $0x1000
   10bb3:	ff 75 10             	pushl  0x10(%ebp)
   10bb6:	e8 4a fa ff ff       	call   10605 <up2>
   10bbb:	83 c4 08             	add    $0x8,%esp
   10bbe:	c1 e8 0c             	shr    $0xc,%eax
   10bc1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(int i = 0; i < page_count; i++)
   10bc4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   10bcb:	eb 68                	jmp    10c35 <memory_alloc_for_page_dir+0x93>
    {
        uint32_t paddr = addr_alloc_page(&paddr_alloc,1);
   10bcd:	83 ec 08             	sub    $0x8,%esp
   10bd0:	6a 01                	push   $0x1
   10bd2:	68 00 60 01 00       	push   $0x16000
   10bd7:	e8 fc fa ff ff       	call   106d8 <addr_alloc_page>
   10bdc:	83 c4 10             	add    $0x10,%esp
   10bdf:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(paddr == 0)
   10be2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   10be6:	75 07                	jne    10bef <memory_alloc_for_page_dir+0x4d>
        {
            return 0;
   10be8:	b8 00 00 00 00       	mov    $0x0,%eax
   10bed:	eb 53                	jmp    10c42 <memory_alloc_for_page_dir+0xa0>
        }
        int err = memory_create_map((pde_t *)page_dir,current_vaddr,paddr,1,perm);
   10bef:	8b 55 14             	mov    0x14(%ebp),%edx
   10bf2:	8b 45 08             	mov    0x8(%ebp),%eax
   10bf5:	83 ec 0c             	sub    $0xc,%esp
   10bf8:	52                   	push   %edx
   10bf9:	6a 01                	push   $0x1
   10bfb:	ff 75 e8             	pushl  -0x18(%ebp)
   10bfe:	ff 75 f4             	pushl  -0xc(%ebp)
   10c01:	50                   	push   %eax
   10c02:	e8 e1 fc ff ff       	call   108e8 <memory_create_map>
   10c07:	83 c4 20             	add    $0x20,%esp
   10c0a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(err < 0)
   10c0d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10c11:	79 17                	jns    10c2a <memory_alloc_for_page_dir+0x88>
        {
            log_printf("memory_alloc_for_page_dir error\n");
   10c13:	83 ec 0c             	sub    $0xc,%esp
   10c16:	68 c0 41 01 00       	push   $0x141c0
   10c1b:	e8 a7 34 00 00       	call   140c7 <log_printf>
   10c20:	83 c4 10             	add    $0x10,%esp
            return 0;
   10c23:	b8 00 00 00 00       	mov    $0x0,%eax
   10c28:	eb 18                	jmp    10c42 <memory_alloc_for_page_dir+0xa0>
        }
        current_vaddr += MEM_PAGE_SIZE;
   10c2a:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
    for(int i = 0; i < page_count; i++)
   10c31:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10c35:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10c38:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   10c3b:	7c 90                	jl     10bcd <memory_alloc_for_page_dir+0x2b>
    }
    return 0;
   10c3d:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10c42:	c9                   	leave  
   10c43:	c3                   	ret    

00010c44 <memory_alloc_page_for>:

int memory_alloc_page_for(uint32_t addr,uint32_t size,int perm)
{
   10c44:	55                   	push   %ebp
   10c45:	89 e5                	mov    %esp,%ebp
   10c47:	83 ec 08             	sub    $0x8,%esp
    return memory_alloc_for_page_dir(task_current()->tss.cr3,addr,size,perm);
   10c4a:	e8 7f 0a 00 00       	call   116ce <task_current>
   10c4f:	8b 40 78             	mov    0x78(%eax),%eax
   10c52:	ff 75 10             	pushl  0x10(%ebp)
   10c55:	ff 75 0c             	pushl  0xc(%ebp)
   10c58:	ff 75 08             	pushl  0x8(%ebp)
   10c5b:	50                   	push   %eax
   10c5c:	e8 41 ff ff ff       	call   10ba2 <memory_alloc_for_page_dir>
   10c61:	83 c4 10             	add    $0x10,%esp
}
   10c64:	c9                   	leave  
   10c65:	c3                   	ret    

00010c66 <memory_copy>:


uint32_t memory_copy(task_t * from,task_t * to)
{
   10c66:	55                   	push   %ebp
   10c67:	89 e5                	mov    %esp,%ebp
   10c69:	83 ec 20             	sub    $0x20,%esp
    pde_t * from_page_dir = (pde_t *)from->tss.cr3;
   10c6c:	8b 45 08             	mov    0x8(%ebp),%eax
   10c6f:	8b 40 78             	mov    0x78(%eax),%eax
   10c72:	89 45 f8             	mov    %eax,-0x8(%ebp)
    pde_t * to_page_dir = (pde_t *)to->tss.cr3;
   10c75:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c78:	8b 40 78             	mov    0x78(%eax),%eax
   10c7b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    uint32_t user_pde_start = pde_index(MEMORY_TASK_BASE);
   10c7e:	68 00 00 00 80       	push   $0x80000000
   10c83:	e8 a0 f9 ff ff       	call   10628 <pde_index>
   10c88:	83 c4 04             	add    $0x4,%esp
   10c8b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(int i = user_pde_start; i < 1024; i++)
   10c8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10c91:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10c94:	eb 3f                	jmp    10cd5 <memory_copy+0x6f>
    {
        pde_t * from_pde = from_page_dir + i;
   10c96:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10c99:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10ca0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10ca3:	01 d0                	add    %edx,%eax
   10ca5:	89 45 ec             	mov    %eax,-0x14(%ebp)
        pde_t * to_pde = to_page_dir + i;
   10ca8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10cab:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10cb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10cb5:	01 d0                	add    %edx,%eax
   10cb7:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(from_pde->present)
   10cba:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10cbd:	0f b6 00             	movzbl (%eax),%eax
   10cc0:	83 e0 01             	and    $0x1,%eax
   10cc3:	84 c0                	test   %al,%al
   10cc5:	74 0a                	je     10cd1 <memory_copy+0x6b>
        {
            to_pde->v = from_pde->v;
   10cc7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10cca:	8b 10                	mov    (%eax),%edx
   10ccc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ccf:	89 10                	mov    %edx,(%eax)
    for(int i = user_pde_start; i < 1024; i++)
   10cd1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10cd5:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%ebp)
   10cdc:	7e b8                	jle    10c96 <memory_copy+0x30>
        }
    }
    return 0;
   10cde:	b8 00 00 00 00       	mov    $0x0,%eax
    
}
   10ce3:	c9                   	leave  
   10ce4:	c3                   	ret    

00010ce5 <memory_copy_vum>:

uint32_t memory_copy_vum(uint32_t page_dir,uint32_t to_page_dir)
{
   10ce5:	55                   	push   %ebp
   10ce6:	89 e5                	mov    %esp,%ebp
   10ce8:	83 ec 28             	sub    $0x28,%esp
    // 复制用户空间的各项
    uint32_t user_pde_start = pde_index(MEMORY_TASK_BASE);
   10ceb:	68 00 00 00 80       	push   $0x80000000
   10cf0:	e8 33 f9 ff ff       	call   10628 <pde_index>
   10cf5:	83 c4 04             	add    $0x4,%esp
   10cf8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    pde_t * pde = (pde_t *)page_dir + user_pde_start;
   10cfb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10cfe:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10d05:	8b 45 08             	mov    0x8(%ebp),%eax
   10d08:	01 d0                	add    %edx,%eax
   10d0a:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // 遍历用户空间页目录项
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++) {
   10d0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d10:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10d13:	e9 d6 00 00 00       	jmp    10dee <memory_copy_vum+0x109>
        if (!pde->present) {
   10d18:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d1b:	0f b6 00             	movzbl (%eax),%eax
   10d1e:	83 e0 01             	and    $0x1,%eax
   10d21:	84 c0                	test   %al,%al
   10d23:	0f 84 bc 00 00 00    	je     10de5 <memory_copy_vum+0x100>
            continue;
        }

        // 遍历页表
        pte_t * pte = (pte_t *)pde_paddr(pde);
   10d29:	ff 75 f4             	pushl  -0xc(%ebp)
   10d2c:	e8 12 f9 ff ff       	call   10643 <pde_paddr>
   10d31:	83 c4 04             	add    $0x4,%esp
   10d34:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for (int j = 0; j < PTE_CNT; j++, pte++) {
   10d37:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   10d3e:	e9 93 00 00 00       	jmp    10dd6 <memory_copy_vum+0xf1>
            if (!pte->present) {
   10d43:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10d46:	0f b6 00             	movzbl (%eax),%eax
   10d49:	83 e0 01             	and    $0x1,%eax
   10d4c:	84 c0                	test   %al,%al
   10d4e:	74 7d                	je     10dcd <memory_copy_vum+0xe8>
                continue;
            }

            // 分配物理内存
            uint32_t page = addr_alloc_page(&paddr_alloc, 1);
   10d50:	83 ec 08             	sub    $0x8,%esp
   10d53:	6a 01                	push   $0x1
   10d55:	68 00 60 01 00       	push   $0x16000
   10d5a:	e8 79 f9 ff ff       	call   106d8 <addr_alloc_page>
   10d5f:	83 c4 10             	add    $0x10,%esp
   10d62:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if (page == 0) {
   10d65:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   10d69:	0f 84 93 00 00 00    	je     10e02 <memory_copy_vum+0x11d>
                goto copy_failed;
            }

            // 建立映射关系
            uint32_t vaddr = (i << 22) | (j << 12);
   10d6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d72:	c1 e0 16             	shl    $0x16,%eax
   10d75:	89 c2                	mov    %eax,%edx
   10d77:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d7a:	c1 e0 0c             	shl    $0xc,%eax
   10d7d:	09 d0                	or     %edx,%eax
   10d7f:	89 45 dc             	mov    %eax,-0x24(%ebp)
            int err = memory_create_map((pde_t *)to_page_dir, vaddr, page, 1, get_pte_perm(pte));
   10d82:	83 ec 0c             	sub    $0xc,%esp
   10d85:	ff 75 ec             	pushl  -0x14(%ebp)
   10d88:	e8 e7 f8 ff ff       	call   10674 <get_pte_perm>
   10d8d:	83 c4 10             	add    $0x10,%esp
   10d90:	89 c2                	mov    %eax,%edx
   10d92:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d95:	83 ec 0c             	sub    $0xc,%esp
   10d98:	52                   	push   %edx
   10d99:	6a 01                	push   $0x1
   10d9b:	ff 75 e0             	pushl  -0x20(%ebp)
   10d9e:	ff 75 dc             	pushl  -0x24(%ebp)
   10da1:	50                   	push   %eax
   10da2:	e8 41 fb ff ff       	call   108e8 <memory_create_map>
   10da7:	83 c4 20             	add    $0x20,%esp
   10daa:	89 45 d8             	mov    %eax,-0x28(%ebp)
            if (err < 0) {
   10dad:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   10db1:	78 52                	js     10e05 <memory_copy_vum+0x120>
                goto copy_failed;
            }

            // 复制内容。
            kernel_memcpy((void *)page, (void *)vaddr, MEM_PAGE_SIZE);
   10db3:	8b 55 dc             	mov    -0x24(%ebp),%edx
   10db6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10db9:	83 ec 04             	sub    $0x4,%esp
   10dbc:	68 00 10 00 00       	push   $0x1000
   10dc1:	52                   	push   %edx
   10dc2:	50                   	push   %eax
   10dc3:	e8 ce 2b 00 00       	call   13996 <kernel_memcpy>
   10dc8:	83 c4 10             	add    $0x10,%esp
   10dcb:	eb 01                	jmp    10dce <memory_copy_vum+0xe9>
                continue;
   10dcd:	90                   	nop
        for (int j = 0; j < PTE_CNT; j++, pte++) {
   10dce:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   10dd2:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   10dd6:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   10ddd:	0f 8e 60 ff ff ff    	jle    10d43 <memory_copy_vum+0x5e>
   10de3:	eb 01                	jmp    10de6 <memory_copy_vum+0x101>
            continue;
   10de5:	90                   	nop
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++) {
   10de6:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10dea:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   10dee:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   10df5:	0f 8e 1d ff ff ff    	jle    10d18 <memory_copy_vum+0x33>
        }
    }

    return 0;
   10dfb:	b8 00 00 00 00       	mov    $0x0,%eax
   10e00:	eb 09                	jmp    10e0b <memory_copy_vum+0x126>
                goto copy_failed;
   10e02:	90                   	nop
   10e03:	eb 01                	jmp    10e06 <memory_copy_vum+0x121>
                goto copy_failed;
   10e05:	90                   	nop
copy_failed:
    return -1;
   10e06:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   10e0b:	c9                   	leave  
   10e0c:	c3                   	ret    

00010e0d <memory_destroy_uvm>:

void memory_destroy_uvm(uint32_t page_dir)
{
   10e0d:	55                   	push   %ebp
   10e0e:	89 e5                	mov    %esp,%ebp
   10e10:	83 ec 28             	sub    $0x28,%esp
     uint32_t user_pde_start = pde_index(MEMORY_TASK_BASE);
   10e13:	68 00 00 00 80       	push   $0x80000000
   10e18:	e8 0b f8 ff ff       	call   10628 <pde_index>
   10e1d:	83 c4 04             	add    $0x4,%esp
   10e20:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    pde_t * pde = (pde_t *)page_dir + user_pde_start;
   10e23:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10e26:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10e2d:	8b 45 08             	mov    0x8(%ebp),%eax
   10e30:	01 d0                	add    %edx,%eax
   10e32:	89 45 f4             	mov    %eax,-0xc(%ebp)

    ASSERT(page_dir != 0);

    // 释放页表中对应的各项，不包含映射的内核页面
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++) {
   10e35:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10e38:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10e3b:	e9 8f 00 00 00       	jmp    10ecf <memory_destroy_uvm+0xc2>
        if (!pde->present) {
   10e40:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10e43:	0f b6 00             	movzbl (%eax),%eax
   10e46:	83 e0 01             	and    $0x1,%eax
   10e49:	84 c0                	test   %al,%al
   10e4b:	74 79                	je     10ec6 <memory_destroy_uvm+0xb9>
            continue;
        }

        // 释放页表对应的物理页 + 页表
        pte_t * pte = (pte_t *)pde_paddr(pde);
   10e4d:	ff 75 f4             	pushl  -0xc(%ebp)
   10e50:	e8 ee f7 ff ff       	call   10643 <pde_paddr>
   10e55:	83 c4 04             	add    $0x4,%esp
   10e58:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for (int j = 0; j < PTE_CNT; j++, pte++) {
   10e5b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   10e62:	eb 36                	jmp    10e9a <memory_destroy_uvm+0x8d>
            if (!pte->present) {
   10e64:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e67:	0f b6 00             	movzbl (%eax),%eax
   10e6a:	83 e0 01             	and    $0x1,%eax
   10e6d:	84 c0                	test   %al,%al
   10e6f:	74 20                	je     10e91 <memory_destroy_uvm+0x84>
                continue;
            }

            addr_free_page(&paddr_alloc, pte_paddr(pte), 1);
   10e71:	ff 75 ec             	pushl  -0x14(%ebp)
   10e74:	e8 da f7 ff ff       	call   10653 <pte_paddr>
   10e79:	83 c4 04             	add    $0x4,%esp
   10e7c:	83 ec 04             	sub    $0x4,%esp
   10e7f:	6a 01                	push   $0x1
   10e81:	50                   	push   %eax
   10e82:	68 00 60 01 00       	push   $0x16000
   10e87:	e8 ab f8 ff ff       	call   10737 <addr_free_page>
   10e8c:	83 c4 10             	add    $0x10,%esp
   10e8f:	eb 01                	jmp    10e92 <memory_destroy_uvm+0x85>
                continue;
   10e91:	90                   	nop
        for (int j = 0; j < PTE_CNT; j++, pte++) {
   10e92:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   10e96:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   10e9a:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   10ea1:	7e c1                	jle    10e64 <memory_destroy_uvm+0x57>
        }

        addr_free_page(&paddr_alloc, (uint32_t)pde_paddr(pde), 1);
   10ea3:	83 ec 0c             	sub    $0xc,%esp
   10ea6:	ff 75 f4             	pushl  -0xc(%ebp)
   10ea9:	e8 95 f7 ff ff       	call   10643 <pde_paddr>
   10eae:	83 c4 10             	add    $0x10,%esp
   10eb1:	83 ec 04             	sub    $0x4,%esp
   10eb4:	6a 01                	push   $0x1
   10eb6:	50                   	push   %eax
   10eb7:	68 00 60 01 00       	push   $0x16000
   10ebc:	e8 76 f8 ff ff       	call   10737 <addr_free_page>
   10ec1:	83 c4 10             	add    $0x10,%esp
   10ec4:	eb 01                	jmp    10ec7 <memory_destroy_uvm+0xba>
            continue;
   10ec6:	90                   	nop
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++) {
   10ec7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10ecb:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   10ecf:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   10ed6:	0f 8e 64 ff ff ff    	jle    10e40 <memory_destroy_uvm+0x33>
    }

    // 页目录表
    addr_free_page(&paddr_alloc, page_dir, 1);
   10edc:	83 ec 04             	sub    $0x4,%esp
   10edf:	6a 01                	push   $0x1
   10ee1:	ff 75 08             	pushl  0x8(%ebp)
   10ee4:	68 00 60 01 00       	push   $0x16000
   10ee9:	e8 49 f8 ff ff       	call   10737 <addr_free_page>
   10eee:	83 c4 10             	add    $0x10,%esp
}
   10ef1:	90                   	nop
   10ef2:	c9                   	leave  
   10ef3:	c3                   	ret    

00010ef4 <memory_get_paddr>:

uint32_t memory_get_paddr(uint32_t page_dir,uint32_t vaddr)
{
   10ef4:	55                   	push   %ebp
   10ef5:	89 e5                	mov    %esp,%ebp
   10ef7:	83 ec 18             	sub    $0x18,%esp
    pte_t * pte = find_pte((pde_t *)page_dir,vaddr,0);
   10efa:	8b 45 08             	mov    0x8(%ebp),%eax
   10efd:	83 ec 04             	sub    $0x4,%esp
   10f00:	6a 00                	push   $0x0
   10f02:	ff 75 0c             	pushl  0xc(%ebp)
   10f05:	50                   	push   %eax
   10f06:	e8 26 f9 ff ff       	call   10831 <find_pte>
   10f0b:	83 c4 10             	add    $0x10,%esp
   10f0e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(pte == (pte_t *)0)
   10f11:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10f15:	75 07                	jne    10f1e <memory_get_paddr+0x2a>
    {
        return 0;
   10f17:	b8 00 00 00 00       	mov    $0x0,%eax
   10f1c:	eb 1a                	jmp    10f38 <memory_get_paddr+0x44>
    }
    return pte_paddr(pte) + (vaddr & (MEM_PAGE_SIZE - 1));
   10f1e:	83 ec 0c             	sub    $0xc,%esp
   10f21:	ff 75 f4             	pushl  -0xc(%ebp)
   10f24:	e8 2a f7 ff ff       	call   10653 <pte_paddr>
   10f29:	83 c4 10             	add    $0x10,%esp
   10f2c:	89 c2                	mov    %eax,%edx
   10f2e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f31:	25 ff 0f 00 00       	and    $0xfff,%eax
   10f36:	01 d0                	add    %edx,%eax
}
   10f38:	c9                   	leave  
   10f39:	c3                   	ret    

00010f3a <memory_copy_uvm_data>:

int memory_copy_uvm_data(uint32_t to, uint32_t page_dir, uint32_t from, uint32_t size) {
   10f3a:	55                   	push   %ebp
   10f3b:	89 e5                	mov    %esp,%ebp
   10f3d:	83 ec 18             	sub    $0x18,%esp
    char *buf, *pa0;

    while(size > 0){
   10f40:	eb 6e                	jmp    10fb0 <memory_copy_uvm_data+0x76>
        // 获取目标的物理地址, 也即其另一个虚拟地址
        uint32_t to_paddr = memory_get_paddr(page_dir, to);
   10f42:	83 ec 08             	sub    $0x8,%esp
   10f45:	ff 75 08             	pushl  0x8(%ebp)
   10f48:	ff 75 0c             	pushl  0xc(%ebp)
   10f4b:	e8 a4 ff ff ff       	call   10ef4 <memory_get_paddr>
   10f50:	83 c4 10             	add    $0x10,%esp
   10f53:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (to_paddr == 0) {
   10f56:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10f5a:	75 07                	jne    10f63 <memory_copy_uvm_data+0x29>
            return -1;
   10f5c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10f61:	eb 58                	jmp    10fbb <memory_copy_uvm_data+0x81>
        }

        // 计算当前可拷贝的大小
        uint32_t offset_in_page = to_paddr & (MEM_PAGE_SIZE - 1);
   10f63:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10f66:	25 ff 0f 00 00       	and    $0xfff,%eax
   10f6b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        uint32_t curr_size = MEM_PAGE_SIZE - offset_in_page;
   10f6e:	b8 00 10 00 00       	mov    $0x1000,%eax
   10f73:	2b 45 ec             	sub    -0x14(%ebp),%eax
   10f76:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (curr_size > size) {
   10f79:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10f7c:	3b 45 14             	cmp    0x14(%ebp),%eax
   10f7f:	76 06                	jbe    10f87 <memory_copy_uvm_data+0x4d>
            curr_size = size;       // 如果比较大，超过页边界，则只拷贝此页内的
   10f81:	8b 45 14             	mov    0x14(%ebp),%eax
   10f84:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }

        kernel_memcpy((void *)to_paddr, (void *)from, curr_size);
   10f87:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   10f8a:	8b 55 10             	mov    0x10(%ebp),%edx
   10f8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10f90:	83 ec 04             	sub    $0x4,%esp
   10f93:	51                   	push   %ecx
   10f94:	52                   	push   %edx
   10f95:	50                   	push   %eax
   10f96:	e8 fb 29 00 00       	call   13996 <kernel_memcpy>
   10f9b:	83 c4 10             	add    $0x10,%esp

        size -= curr_size;
   10f9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10fa1:	29 45 14             	sub    %eax,0x14(%ebp)
        to += curr_size;
   10fa4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10fa7:	01 45 08             	add    %eax,0x8(%ebp)
        from += curr_size;
   10faa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10fad:	01 45 10             	add    %eax,0x10(%ebp)
    while(size > 0){
   10fb0:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   10fb4:	75 8c                	jne    10f42 <memory_copy_uvm_data+0x8>
  }

  return 0;
   10fb6:	b8 00 00 00 00       	mov    $0x0,%eax
   10fbb:	c9                   	leave  
   10fbc:	c3                   	ret    

00010fbd <sys_print_msg>:
extern void sys_sleep(uint32_t ms);
extern int sys_getpid(void);
extern int sys_fork(void);
extern int sys_execve(char *name, char **argv, char **env);
void sys_print_msg(const char *msg,int arg)
{
   10fbd:	55                   	push   %ebp
   10fbe:	89 e5                	mov    %esp,%ebp
   10fc0:	83 ec 08             	sub    $0x8,%esp
    log_printf(msg,arg);
   10fc3:	83 ec 08             	sub    $0x8,%esp
   10fc6:	ff 75 0c             	pushl  0xc(%ebp)
   10fc9:	ff 75 08             	pushl  0x8(%ebp)
   10fcc:	e8 f6 30 00 00       	call   140c7 <log_printf>
   10fd1:	83 c4 10             	add    $0x10,%esp
}
   10fd4:	90                   	nop
   10fd5:	c9                   	leave  
   10fd6:	c3                   	ret    

00010fd7 <do_handler_syscall>:
    [SYS_print_msg] = (sys_handler_t)sys_print_msg,
    [SYS_fork] = (sys_handler_t)sys_fork,
    [SYS_execve] = (sys_handler_t)sys_execve,
};
void do_handler_syscall(syscall_frame_t *frame)
{
   10fd7:	55                   	push   %ebp
   10fd8:	89 e5                	mov    %esp,%ebp
   10fda:	53                   	push   %ebx
   10fdb:	83 ec 14             	sub    $0x14,%esp
    if(frame->func_id < sizeof(sys_handler_table) / sizeof(sys_handler_t))
   10fde:	8b 45 08             	mov    0x8(%ebp),%eax
   10fe1:	8b 40 3c             	mov    0x3c(%eax),%eax
   10fe4:	83 f8 64             	cmp    $0x64,%eax
   10fe7:	77 4e                	ja     11037 <do_handler_syscall+0x60>
    {
        sys_handler_t handler = sys_handler_table[frame->func_id];
   10fe9:	8b 45 08             	mov    0x8(%ebp),%eax
   10fec:	8b 40 3c             	mov    0x3c(%eax),%eax
   10fef:	8b 04 85 00 42 01 00 	mov    0x14200(,%eax,4),%eax
   10ff6:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(handler)
   10ff9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10ffd:	74 38                	je     11037 <do_handler_syscall+0x60>
        {
            int ret = handler(frame->arg0,frame->arg1,frame->arg2,frame->arg3);
   10fff:	8b 45 08             	mov    0x8(%ebp),%eax
   11002:	8b 40 4c             	mov    0x4c(%eax),%eax
   11005:	89 c3                	mov    %eax,%ebx
   11007:	8b 45 08             	mov    0x8(%ebp),%eax
   1100a:	8b 40 48             	mov    0x48(%eax),%eax
   1100d:	89 c1                	mov    %eax,%ecx
   1100f:	8b 45 08             	mov    0x8(%ebp),%eax
   11012:	8b 40 44             	mov    0x44(%eax),%eax
   11015:	89 c2                	mov    %eax,%edx
   11017:	8b 45 08             	mov    0x8(%ebp),%eax
   1101a:	8b 40 40             	mov    0x40(%eax),%eax
   1101d:	53                   	push   %ebx
   1101e:	51                   	push   %ecx
   1101f:	52                   	push   %edx
   11020:	50                   	push   %eax
   11021:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11024:	ff d0                	call   *%eax
   11026:	83 c4 10             	add    $0x10,%esp
   11029:	89 45 f0             	mov    %eax,-0x10(%ebp)
            frame->eax = ret;
   1102c:	8b 45 08             	mov    0x8(%ebp),%eax
   1102f:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11032:	89 50 30             	mov    %edx,0x30(%eax)
            return;
   11035:	eb 30                	jmp    11067 <do_handler_syscall+0x90>
        }
    }

    task_t *task = task_current();
   11037:	e8 92 06 00 00       	call   116ce <task_current>
   1103c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    log_printf("task: %s, unknow syscall: %d\n",task->name,frame->func_id);
   1103f:	8b 45 08             	mov    0x8(%ebp),%eax
   11042:	8b 40 3c             	mov    0x3c(%eax),%eax
   11045:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11048:	83 c2 20             	add    $0x20,%edx
   1104b:	83 ec 04             	sub    $0x4,%esp
   1104e:	50                   	push   %eax
   1104f:	52                   	push   %edx
   11050:	68 94 43 01 00       	push   $0x14394
   11055:	e8 6d 30 00 00       	call   140c7 <log_printf>
   1105a:	83 c4 10             	add    $0x10,%esp
    frame->eax = -1;
   1105d:	8b 45 08             	mov    0x8(%ebp),%eax
   11060:	c7 40 30 ff ff ff ff 	movl   $0xffffffff,0x30(%eax)
   11067:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1106a:	c9                   	leave  
   1106b:	c3                   	ret    

0001106c <list_node_init>:
    struct _list_node_t* next;
}list_node_t;


static inline void list_node_init(list_node_t *node)
{
   1106c:	55                   	push   %ebp
   1106d:	89 e5                	mov    %esp,%ebp
    node->pre = node->next = (list_node_t *)0;
   1106f:	8b 45 08             	mov    0x8(%ebp),%eax
   11072:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   11079:	8b 45 08             	mov    0x8(%ebp),%eax
   1107c:	8b 50 04             	mov    0x4(%eax),%edx
   1107f:	8b 45 08             	mov    0x8(%ebp),%eax
   11082:	89 10                	mov    %edx,(%eax)
}
   11084:	90                   	nop
   11085:	5d                   	pop    %ebp
   11086:	c3                   	ret    

00011087 <list_node_next>:
static inline list_node_t* list_node_pre(list_node_t* node)
{
    return node->pre;
} 
static inline list_node_t* list_node_next(list_node_t* node)
{
   11087:	55                   	push   %ebp
   11088:	89 e5                	mov    %esp,%ebp
    return node->next;
   1108a:	8b 45 08             	mov    0x8(%ebp),%eax
   1108d:	8b 40 04             	mov    0x4(%eax),%eax
}
   11090:	5d                   	pop    %ebp
   11091:	c3                   	ret    

00011092 <list_count>:
{
    return list->count == 0;
}

static inline int list_count(list_t * list)
{
   11092:	55                   	push   %ebp
   11093:	89 e5                	mov    %esp,%ebp
    return list->count;
   11095:	8b 45 08             	mov    0x8(%ebp),%eax
   11098:	8b 40 08             	mov    0x8(%eax),%eax
}
   1109b:	5d                   	pop    %ebp
   1109c:	c3                   	ret    

0001109d <list_first>:
static inline list_node_t* list_first(list_t * list)
{
   1109d:	55                   	push   %ebp
   1109e:	89 e5                	mov    %esp,%ebp
    return list->first;
   110a0:	8b 45 08             	mov    0x8(%ebp),%eax
   110a3:	8b 00                	mov    (%eax),%eax
}
   110a5:	5d                   	pop    %ebp
   110a6:	c3                   	ret    

000110a7 <read_cr3>:
{
   110a7:	55                   	push   %ebp
   110a8:	89 e5                	mov    %esp,%ebp
   110aa:	83 ec 10             	sub    $0x10,%esp
    __asm__ __volatile__("mov %%cr3, %[v]":[v]"=r"(cr3));
   110ad:	0f 20 d8             	mov    %cr3,%eax
   110b0:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return cr3;
   110b3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   110b6:	c9                   	leave  
   110b7:	c3                   	ret    

000110b8 <write_cr3>:
{
   110b8:	55                   	push   %ebp
   110b9:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("mov %[v], %%cr3"::[v]"r"(v));
   110bb:	8b 45 08             	mov    0x8(%ebp),%eax
   110be:	0f 22 d8             	mov    %eax,%cr3
}
   110c1:	90                   	nop
   110c2:	5d                   	pop    %ebp
   110c3:	c3                   	ret    

000110c4 <hlt>:
    uint32_t addr[] = {offset ,selector};
    __asm__ __volatile__("ljmpl *(%[a])"::[a]"r"(addr));
}

static inline void hlt(void)
{
   110c4:	55                   	push   %ebp
   110c5:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   110c7:	f4                   	hlt    
}
   110c8:	90                   	nop
   110c9:	5d                   	pop    %ebp
   110ca:	c3                   	ret    

000110cb <write_tr>:

static inline void write_tr(uint16_t selector)
{
   110cb:	55                   	push   %ebp
   110cc:	89 e5                	mov    %esp,%ebp
   110ce:	83 ec 04             	sub    $0x4,%esp
   110d1:	8b 45 08             	mov    0x8(%ebp),%eax
   110d4:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    __asm__ __volatile__("ltr %%ax"::"a"(selector));
   110d8:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
   110dc:	0f 00 d8             	ltr    %ax
}
   110df:	90                   	nop
   110e0:	c9                   	leave  
   110e1:	c3                   	ret    

000110e2 <mmu_set_page_dir>:
{
   110e2:	55                   	push   %ebp
   110e3:	89 e5                	mov    %esp,%ebp
    write_cr3(paddr);
   110e5:	ff 75 08             	pushl  0x8(%ebp)
   110e8:	e8 cb ff ff ff       	call   110b8 <write_cr3>
   110ed:	83 c4 04             	add    $0x4,%esp
}
   110f0:	90                   	nop
   110f1:	c9                   	leave  
   110f2:	c3                   	ret    

000110f3 <tss_init>:
static uint32_t kernel_stack[1024];

static task_t task_table[TASK_COUNT];
static int task_table_mutex;     
static int tss_init(task_t *task,uint32_t entry,uint32_t esp, int kernel_or_user)
{
   110f3:	55                   	push   %ebp
   110f4:	89 e5                	mov    %esp,%ebp
   110f6:	83 ec 18             	sub    $0x18,%esp
    kernel_memset(&task->tss,0,sizeof(tss_t));
   110f9:	8b 45 08             	mov    0x8(%ebp),%eax
   110fc:	83 c0 5c             	add    $0x5c,%eax
   110ff:	83 ec 04             	sub    $0x4,%esp
   11102:	6a 68                	push   $0x68
   11104:	6a 00                	push   $0x0
   11106:	50                   	push   %eax
   11107:	e8 d9 28 00 00       	call   139e5 <kernel_memset>
   1110c:	83 c4 10             	add    $0x10,%esp

    uint32_t kernel_stack= memory_alloc_page();
   1110f:	e8 fa f9 ff ff       	call   10b0e <memory_alloc_page>
   11114:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(kernel_stack == 0)
   11117:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1111b:	0f 84 c1 00 00 00    	je     111e2 <tss_init+0xef>
    {
        goto tss_init_failed;
    }
    task->tss.esp0 = kernel_stack + MEM_PAGE_SIZE;
   11121:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11124:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
   1112a:	8b 45 08             	mov    0x8(%ebp),%eax
   1112d:	89 50 60             	mov    %edx,0x60(%eax)
    task->esp0_start = kernel_stack + MEM_PAGE_SIZE;
   11130:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11133:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
   11139:	8b 45 08             	mov    0x8(%ebp),%eax
   1113c:	89 50 58             	mov    %edx,0x58(%eax)
    
    //0表示内核任务，1表示用户任务
    if(kernel_or_user == 0)
   1113f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   11143:	75 36                	jne    1117b <tss_init+0x88>
    {
        task->tss.cs = KERNEL_SELECTOR_CS;    // 内核代码段
   11145:	8b 45 08             	mov    0x8(%ebp),%eax
   11148:	c7 80 a8 00 00 00 08 	movl   $0x8,0xa8(%eax)
   1114f:	00 00 00 
        task->tss.ds = KERNEL_SELECTOR_DS;    // 内核数据段
   11152:	8b 45 08             	mov    0x8(%ebp),%eax
   11155:	c7 80 b0 00 00 00 10 	movl   $0x10,0xb0(%eax)
   1115c:	00 00 00 
        task->tss.ss = KERNEL_SELECTOR_DS;    // 内核栈段
   1115f:	8b 45 08             	mov    0x8(%ebp),%eax
   11162:	c7 80 ac 00 00 00 10 	movl   $0x10,0xac(%eax)
   11169:	00 00 00 
        task->tss.eflags = EFLAGS_DEFAULT| EFLAGS_IF; // 开启中断
   1116c:	8b 45 08             	mov    0x8(%ebp),%eax
   1116f:	c7 80 80 00 00 00 02 	movl   $0x202,0x80(%eax)
   11176:	02 00 00 
   11179:	eb 34                	jmp    111af <tss_init+0xbc>
    }
    else
    {
        task->tss.cs = USER_SELECTOR_CS;    // 用户代码段
   1117b:	8b 45 08             	mov    0x8(%ebp),%eax
   1117e:	c7 80 a8 00 00 00 1b 	movl   $0x1b,0xa8(%eax)
   11185:	00 00 00 
        task->tss.ds = USER_SELECTOR_DS;    // 用户数据段
   11188:	8b 45 08             	mov    0x8(%ebp),%eax
   1118b:	c7 80 b0 00 00 00 23 	movl   $0x23,0xb0(%eax)
   11192:	00 00 00 
        task->tss.ss = USER_SELECTOR_DS;    // 用户栈段
   11195:	8b 45 08             	mov    0x8(%ebp),%eax
   11198:	c7 80 ac 00 00 00 23 	movl   $0x23,0xac(%eax)
   1119f:	00 00 00 
        task->tss.eflags = EFLAGS_DEFAULT| EFLAGS_IF; // 开启中断
   111a2:	8b 45 08             	mov    0x8(%ebp),%eax
   111a5:	c7 80 80 00 00 00 02 	movl   $0x202,0x80(%eax)
   111ac:	02 00 00 
    }
    task->tss.esp = esp;
   111af:	8b 45 08             	mov    0x8(%ebp),%eax
   111b2:	8b 55 10             	mov    0x10(%ebp),%edx
   111b5:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
    task->tss.eip = entry;
   111bb:	8b 45 08             	mov    0x8(%ebp),%eax
   111be:	8b 55 0c             	mov    0xc(%ebp),%edx
   111c1:	89 50 7c             	mov    %edx,0x7c(%eax)
    uint32_t page_dir = memory_create_user_space();
   111c4:	e8 29 f8 ff ff       	call   109f2 <memory_create_user_space>
   111c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(page_dir == 0)
   111cc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   111d0:	74 13                	je     111e5 <tss_init+0xf2>
    {
        //memory_destroy_uvm(page_dir);
        goto tss_init_failed;
    }
    task->tss.cr3 = page_dir;
   111d2:	8b 45 08             	mov    0x8(%ebp),%eax
   111d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
   111d8:	89 50 78             	mov    %edx,0x78(%eax)
    return 0;
   111db:	b8 00 00 00 00       	mov    $0x0,%eax
   111e0:	eb 31                	jmp    11213 <tss_init+0x120>
        goto tss_init_failed;
   111e2:	90                   	nop
   111e3:	eb 01                	jmp    111e6 <tss_init+0xf3>
        goto tss_init_failed;
   111e5:	90                   	nop
tss_init_failed:
    if(kernel_stack)
   111e6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   111ea:	74 0e                	je     111fa <tss_init+0x107>
    {
        memory_free_page(kernel_stack);
   111ec:	83 ec 0c             	sub    $0xc,%esp
   111ef:	ff 75 f0             	pushl  -0x10(%ebp)
   111f2:	e8 41 f9 ff ff       	call   10b38 <memory_free_page>
   111f7:	83 c4 10             	add    $0x10,%esp
    }
    if(page_dir)
   111fa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   111fe:	74 0e                	je     1120e <tss_init+0x11b>
    {
        memory_destroy_uvm(page_dir);
   11200:	83 ec 0c             	sub    $0xc,%esp
   11203:	ff 75 f4             	pushl  -0xc(%ebp)
   11206:	e8 02 fc ff ff       	call   10e0d <memory_destroy_uvm>
   1120b:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   1120e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11213:	c9                   	leave  
   11214:	c3                   	ret    

00011215 <task_uninit>:

void task_uninit(task_t *task)
{
   11215:	55                   	push   %ebp
   11216:	89 e5                	mov    %esp,%ebp
   11218:	83 ec 08             	sub    $0x8,%esp
    if(task->tss.cr3)
   1121b:	8b 45 08             	mov    0x8(%ebp),%eax
   1121e:	8b 40 78             	mov    0x78(%eax),%eax
   11221:	85 c0                	test   %eax,%eax
   11223:	74 12                	je     11237 <task_uninit+0x22>
    {
        memory_destroy_uvm(task->tss.cr3);
   11225:	8b 45 08             	mov    0x8(%ebp),%eax
   11228:	8b 40 78             	mov    0x78(%eax),%eax
   1122b:	83 ec 0c             	sub    $0xc,%esp
   1122e:	50                   	push   %eax
   1122f:	e8 d9 fb ff ff       	call   10e0d <memory_destroy_uvm>
   11234:	83 c4 10             	add    $0x10,%esp
    }
    kernel_memset(task,0,sizeof(task_t));
   11237:	83 ec 04             	sub    $0x4,%esp
   1123a:	68 c4 00 00 00       	push   $0xc4
   1123f:	6a 00                	push   $0x0
   11241:	ff 75 08             	pushl  0x8(%ebp)
   11244:	e8 9c 27 00 00       	call   139e5 <kernel_memset>
   11249:	83 c4 10             	add    $0x10,%esp
}
   1124c:	90                   	nop
   1124d:	c9                   	leave  
   1124e:	c3                   	ret    

0001124f <kernel_task_init>:
int kernel_task_init(task_t *task,const char *name,uint32_t entry,uint32_t esp)
{
   1124f:	55                   	push   %ebp
   11250:	89 e5                	mov    %esp,%ebp
   11252:	83 ec 18             	sub    $0x18,%esp
    ASSERT(task != (task *)0);
    tss_init(task,entry,esp,0);
   11255:	6a 00                	push   $0x0
   11257:	ff 75 14             	pushl  0x14(%ebp)
   1125a:	ff 75 10             	pushl  0x10(%ebp)
   1125d:	ff 75 08             	pushl  0x8(%ebp)
   11260:	e8 8e fe ff ff       	call   110f3 <tss_init>
   11265:	83 c4 10             	add    $0x10,%esp

    task->task_type = TASK_KERNEL;
   11268:	8b 45 08             	mov    0x8(%ebp),%eax
   1126b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    kernel_strncpy(task->name,name,TASK_NAME_SIZE);
   11272:	8b 45 08             	mov    0x8(%ebp),%eax
   11275:	83 c0 20             	add    $0x20,%eax
   11278:	83 ec 04             	sub    $0x4,%esp
   1127b:	6a 20                	push   $0x20
   1127d:	ff 75 0c             	pushl  0xc(%ebp)
   11280:	50                   	push   %eax
   11281:	e8 f1 25 00 00       	call   13877 <kernel_strncpy>
   11286:	83 c4 10             	add    $0x10,%esp
    task->time_ticks = TASK_TIME_SLICE_DEFAULT;
   11289:	8b 45 08             	mov    0x8(%ebp),%eax
   1128c:	c7 40 1c 0a 00 00 00 	movl   $0xa,0x1c(%eax)
    task->slice_ticks = task->time_ticks;
   11293:	8b 45 08             	mov    0x8(%ebp),%eax
   11296:	8b 50 1c             	mov    0x1c(%eax),%edx
   11299:	8b 45 08             	mov    0x8(%ebp),%eax
   1129c:	89 50 18             	mov    %edx,0x18(%eax)
    task->sleep_ticks = 0;
   1129f:	8b 45 08             	mov    0x8(%ebp),%eax
   112a2:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
    task->state = TASK_CREATED;
   112a9:	8b 45 08             	mov    0x8(%ebp),%eax
   112ac:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    task->parent = (task_t *)0;
   112b3:	8b 45 08             	mov    0x8(%ebp),%eax
   112b6:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    task->pid = (uint32_t)task;
   112bd:	8b 55 08             	mov    0x8(%ebp),%edx
   112c0:	8b 45 08             	mov    0x8(%ebp),%eax
   112c3:	89 50 0c             	mov    %edx,0xc(%eax)
    list_node_init(&task->run_node);
   112c6:	8b 45 08             	mov    0x8(%ebp),%eax
   112c9:	83 c0 40             	add    $0x40,%eax
   112cc:	83 ec 0c             	sub    $0xc,%esp
   112cf:	50                   	push   %eax
   112d0:	e8 97 fd ff ff       	call   1106c <list_node_init>
   112d5:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->all_node);
   112d8:	8b 45 08             	mov    0x8(%ebp),%eax
   112db:	83 c0 48             	add    $0x48,%eax
   112de:	83 ec 0c             	sub    $0xc,%esp
   112e1:	50                   	push   %eax
   112e2:	e8 85 fd ff ff       	call   1106c <list_node_init>
   112e7:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->wait_node);
   112ea:	8b 45 08             	mov    0x8(%ebp),%eax
   112ed:	83 c0 50             	add    $0x50,%eax
   112f0:	83 ec 0c             	sub    $0xc,%esp
   112f3:	50                   	push   %eax
   112f4:	e8 73 fd ff ff       	call   1106c <list_node_init>
   112f9:	83 c4 10             	add    $0x10,%esp
    irq_state_t state = irq_enter_protection();
   112fc:	e8 1b 1c 00 00       	call   12f1c <irq_enter_protection>
   11301:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_set_ready(task);
   11304:	83 ec 0c             	sub    $0xc,%esp
   11307:	ff 75 08             	pushl  0x8(%ebp)
   1130a:	e8 5f 03 00 00       	call   1166e <task_set_ready>
   1130f:	83 c4 10             	add    $0x10,%esp
    list_insert_last(&task_manager.task_list,&task->all_node);
   11312:	8b 45 08             	mov    0x8(%ebp),%eax
   11315:	83 c0 48             	add    $0x48,%eax
   11318:	83 ec 08             	sub    $0x8,%esp
   1131b:	50                   	push   %eax
   1131c:	68 48 80 01 00       	push   $0x18048
   11321:	e8 69 2b 00 00       	call   13e8f <list_insert_last>
   11326:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(state);
   11329:	83 ec 0c             	sub    $0xc,%esp
   1132c:	ff 75 f4             	pushl  -0xc(%ebp)
   1132f:	e8 00 1c 00 00       	call   12f34 <irq_leave_protection>
   11334:	83 c4 10             	add    $0x10,%esp
    return 0;
   11337:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1133c:	c9                   	leave  
   1133d:	c3                   	ret    

0001133e <user_task_init>:


int user_task_init(task_t *task,const char *name,uint32_t entry,uint32_t esp)
{
   1133e:	55                   	push   %ebp
   1133f:	89 e5                	mov    %esp,%ebp
   11341:	83 ec 18             	sub    $0x18,%esp
    ASSERT(task != (task *)0);
    task->task_type = TASK_USER;
   11344:	8b 45 08             	mov    0x8(%ebp),%eax
   11347:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
    tss_init(task,entry,esp,1);
   1134e:	6a 01                	push   $0x1
   11350:	ff 75 14             	pushl  0x14(%ebp)
   11353:	ff 75 10             	pushl  0x10(%ebp)
   11356:	ff 75 08             	pushl  0x8(%ebp)
   11359:	e8 95 fd ff ff       	call   110f3 <tss_init>
   1135e:	83 c4 10             	add    $0x10,%esp
    kernel_strncpy(task->name,name,TASK_NAME_SIZE);
   11361:	8b 45 08             	mov    0x8(%ebp),%eax
   11364:	83 c0 20             	add    $0x20,%eax
   11367:	83 ec 04             	sub    $0x4,%esp
   1136a:	6a 20                	push   $0x20
   1136c:	ff 75 0c             	pushl  0xc(%ebp)
   1136f:	50                   	push   %eax
   11370:	e8 02 25 00 00       	call   13877 <kernel_strncpy>
   11375:	83 c4 10             	add    $0x10,%esp
    task->time_ticks = TASK_TIME_SLICE_DEFAULT;
   11378:	8b 45 08             	mov    0x8(%ebp),%eax
   1137b:	c7 40 1c 0a 00 00 00 	movl   $0xa,0x1c(%eax)
    task->slice_ticks = task->time_ticks;
   11382:	8b 45 08             	mov    0x8(%ebp),%eax
   11385:	8b 50 1c             	mov    0x1c(%eax),%edx
   11388:	8b 45 08             	mov    0x8(%ebp),%eax
   1138b:	89 50 18             	mov    %edx,0x18(%eax)
    task->sleep_ticks = 0;
   1138e:	8b 45 08             	mov    0x8(%ebp),%eax
   11391:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
    task->state = TASK_CREATED;
   11398:	8b 45 08             	mov    0x8(%ebp),%eax
   1139b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    task->parent = (task_t *)0;
   113a2:	8b 45 08             	mov    0x8(%ebp),%eax
   113a5:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    task->pid = (uint32_t)task;
   113ac:	8b 55 08             	mov    0x8(%ebp),%edx
   113af:	8b 45 08             	mov    0x8(%ebp),%eax
   113b2:	89 50 0c             	mov    %edx,0xc(%eax)
    list_node_init(&task->run_node);
   113b5:	8b 45 08             	mov    0x8(%ebp),%eax
   113b8:	83 c0 40             	add    $0x40,%eax
   113bb:	83 ec 0c             	sub    $0xc,%esp
   113be:	50                   	push   %eax
   113bf:	e8 a8 fc ff ff       	call   1106c <list_node_init>
   113c4:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->all_node);
   113c7:	8b 45 08             	mov    0x8(%ebp),%eax
   113ca:	83 c0 48             	add    $0x48,%eax
   113cd:	83 ec 0c             	sub    $0xc,%esp
   113d0:	50                   	push   %eax
   113d1:	e8 96 fc ff ff       	call   1106c <list_node_init>
   113d6:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->wait_node);
   113d9:	8b 45 08             	mov    0x8(%ebp),%eax
   113dc:	83 c0 50             	add    $0x50,%eax
   113df:	83 ec 0c             	sub    $0xc,%esp
   113e2:	50                   	push   %eax
   113e3:	e8 84 fc ff ff       	call   1106c <list_node_init>
   113e8:	83 c4 10             	add    $0x10,%esp
    irq_state_t state = irq_enter_protection();
   113eb:	e8 2c 1b 00 00       	call   12f1c <irq_enter_protection>
   113f0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_set_ready(task);
   113f3:	83 ec 0c             	sub    $0xc,%esp
   113f6:	ff 75 08             	pushl  0x8(%ebp)
   113f9:	e8 70 02 00 00       	call   1166e <task_set_ready>
   113fe:	83 c4 10             	add    $0x10,%esp
    list_insert_last(&task_manager.task_list,&task->all_node);
   11401:	8b 45 08             	mov    0x8(%ebp),%eax
   11404:	83 c0 48             	add    $0x48,%eax
   11407:	83 ec 08             	sub    $0x8,%esp
   1140a:	50                   	push   %eax
   1140b:	68 48 80 01 00       	push   $0x18048
   11410:	e8 7a 2a 00 00       	call   13e8f <list_insert_last>
   11415:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(state);
   11418:	83 ec 0c             	sub    $0xc,%esp
   1141b:	ff 75 f4             	pushl  -0xc(%ebp)
   1141e:	e8 11 1b 00 00       	call   12f34 <irq_leave_protection>
   11423:	83 c4 10             	add    $0x10,%esp
    return 0;
   11426:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1142b:	c9                   	leave  
   1142c:	c3                   	ret    

0001142d <idle_task_entry>:
void simple_switch(uint32_t ** from,uint32_t *to);
void interrupt_switch(uint32_t ** from,uint32_t *to);
static void idle_task_entry(void)
{
   1142d:	55                   	push   %ebp
   1142e:	89 e5                	mov    %esp,%ebp
    while(1)
    {
        hlt();
   11430:	e8 8f fc ff ff       	call   110c4 <hlt>
   11435:	eb f9                	jmp    11430 <idle_task_entry+0x3>

00011437 <global_tss_init>:
    }
}
static void global_tss_init()
{
   11437:	55                   	push   %ebp
   11438:	89 e5                	mov    %esp,%ebp
    task_manager.global_tss.ss0 = KERNEL_SELECTOR_DS;
   1143a:	c7 05 e4 81 01 00 10 	movl   $0x10,0x181e4
   11441:	00 00 00 
    task_manager.global_tss.esp0 = 0;
   11444:	c7 05 e0 81 01 00 00 	movl   $0x0,0x181e0
   1144b:	00 00 00 
    task_manager.global_tss.cs = KERNEL_SELECTOR_CS;
   1144e:	c7 05 28 82 01 00 08 	movl   $0x8,0x18228
   11455:	00 00 00 
    task_manager.global_tss.ds = KERNEL_SELECTOR_DS;
   11458:	c7 05 30 82 01 00 10 	movl   $0x10,0x18230
   1145f:	00 00 00 
    task_manager.global_tss.es = KERNEL_SELECTOR_DS;
   11462:	c7 05 24 82 01 00 10 	movl   $0x10,0x18224
   11469:	00 00 00 
    task_manager.global_tss.fs = KERNEL_SELECTOR_DS;
   1146c:	c7 05 34 82 01 00 10 	movl   $0x10,0x18234
   11473:	00 00 00 
    task_manager.global_tss.gs = KERNEL_SELECTOR_DS;
   11476:	c7 05 38 82 01 00 10 	movl   $0x10,0x18238
   1147d:	00 00 00 
}
   11480:	90                   	nop
   11481:	5d                   	pop    %ebp
   11482:	c3                   	ret    

00011483 <task_gdt_init>:
static void task_gdt_init()
{
   11483:	55                   	push   %ebp
   11484:	89 e5                	mov    %esp,%ebp
   11486:	83 ec 18             	sub    $0x18,%esp
    // 直接配置用户段到对应的GDT表项，确保段基址为0  
    int sel = gdt_alloc_desc();
   11489:	e8 b8 0f 00 00       	call   12446 <gdt_alloc_desc>
   1148e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    segment_desc_set(sel, 0, 0xFFFFFFFF, SEG_P_PRESENT | SEG_DPL_3 | SEG_S_NORMAL |
   11491:	68 fa 40 00 00       	push   $0x40fa
   11496:	6a ff                	push   $0xffffffff
   11498:	6a 00                	push   $0x0
   1149a:	ff 75 f4             	pushl  -0xc(%ebp)
   1149d:	e8 da 0e 00 00       	call   1237c <segment_desc_set>
   114a2:	83 c4 10             	add    $0x10,%esp
        SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D);  // 索引3，对应选择子0x1B (0x18+RPL_3)
    sel = gdt_alloc_desc();
   114a5:	e8 9c 0f 00 00       	call   12446 <gdt_alloc_desc>
   114aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    segment_desc_set(sel, 0, 0xFFFFFFFF, SEG_P_PRESENT | SEG_DPL_3 | SEG_S_NORMAL |
   114ad:	68 f2 40 00 00       	push   $0x40f2
   114b2:	6a ff                	push   $0xffffffff
   114b4:	6a 00                	push   $0x0
   114b6:	ff 75 f4             	pushl  -0xc(%ebp)
   114b9:	e8 be 0e 00 00       	call   1237c <segment_desc_set>
   114be:	83 c4 10             	add    $0x10,%esp
        SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D);  // 索引4，对应选择子0x23 (0x20+RPL_3)
    sel = gdt_alloc_desc();
   114c1:	e8 80 0f 00 00       	call   12446 <gdt_alloc_desc>
   114c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    segment_desc_set(sel, (uint32_t)&task_manager.global_tss, sizeof(tss_t),
   114c9:	b8 dc 81 01 00       	mov    $0x181dc,%eax
   114ce:	68 89 00 00 00       	push   $0x89
   114d3:	6a 68                	push   $0x68
   114d5:	50                   	push   %eax
   114d6:	ff 75 f4             	pushl  -0xc(%ebp)
   114d9:	e8 9e 0e 00 00       	call   1237c <segment_desc_set>
   114de:	83 c4 10             	add    $0x10,%esp
            SEG_P_PRESENT | SEG_DPL_0 | SEG_TYPE_TSS);
    task_manager.tss_sel = sel;
   114e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   114e4:	a3 44 82 01 00       	mov    %eax,0x18244
}
   114e9:	90                   	nop
   114ea:	c9                   	leave  
   114eb:	c3                   	ret    

000114ec <task_manager_init>:
void task_manager_init()
{
   114ec:	55                   	push   %ebp
   114ed:	89 e5                	mov    %esp,%ebp
   114ef:	83 ec 08             	sub    $0x8,%esp

    kernel_memset(&task_table,0,sizeof(task_table));
   114f2:	83 ec 04             	sub    $0x4,%esp
   114f5:	68 00 62 00 00       	push   $0x6200
   114fa:	6a 00                	push   $0x0
   114fc:	68 60 a2 01 00       	push   $0x1a260
   11501:	e8 df 24 00 00       	call   139e5 <kernel_memset>
   11506:	83 c4 10             	add    $0x10,%esp
    mutex_init(&task_table_mutex);
   11509:	83 ec 0c             	sub    $0xc,%esp
   1150c:	68 60 04 02 00       	push   $0x20460
   11511:	e8 24 1e 00 00       	call   1333a <mutex_init>
   11516:	83 c4 10             	add    $0x10,%esp
    task_gdt_init();
   11519:	e8 65 ff ff ff       	call   11483 <task_gdt_init>
    global_tss_init();
   1151e:	e8 14 ff ff ff       	call   11437 <global_tss_init>
    
    
    // show_base(3);
    // show_base(4);
    list_init(&task_manager.ready_list);
   11523:	83 ec 0c             	sub    $0xc,%esp
   11526:	68 30 80 01 00       	push   $0x18030
   1152b:	e8 db 28 00 00       	call   13e0b <list_init>
   11530:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.task_list);     
   11533:	83 ec 0c             	sub    $0xc,%esp
   11536:	68 48 80 01 00       	push   $0x18048
   1153b:	e8 cb 28 00 00       	call   13e0b <list_init>
   11540:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.sleep_list);
   11543:	83 ec 0c             	sub    $0xc,%esp
   11546:	68 3c 80 01 00       	push   $0x1803c
   1154b:	e8 bb 28 00 00       	call   13e0b <list_init>
   11550:	83 c4 10             	add    $0x10,%esp
    task_manager.current_task = (task_t *)0;
   11553:	c7 05 2c 80 01 00 00 	movl   $0x0,0x1802c
   1155a:	00 00 00 
    task_manager.from_task = (task_t *)0;
   1155d:	c7 05 24 80 01 00 00 	movl   $0x0,0x18024
   11564:	00 00 00 
    task_manager.to_task = (task_t *)0;
   11567:	c7 05 28 80 01 00 00 	movl   $0x0,0x18028
   1156e:	00 00 00 
    task_manager.need_reschedule = TASK_NOT_NEED_RESCHEDULE ;
   11571:	c7 05 20 80 01 00 00 	movl   $0x0,0x18020
   11578:	00 00 00 

    kernel_task_init(&task_manager.idle_task,"idle_task",idle_task_entry,(uint32_t)&idle_task_stack[1024]);
   1157b:	ba 60 92 01 00       	mov    $0x19260,%edx
   11580:	b8 2d 14 01 00       	mov    $0x1142d,%eax
   11585:	52                   	push   %edx
   11586:	50                   	push   %eax
   11587:	68 b4 43 01 00       	push   $0x143b4
   1158c:	68 18 81 01 00       	push   $0x18118
   11591:	e8 b9 fc ff ff       	call   1124f <kernel_task_init>
   11596:	83 c4 10             	add    $0x10,%esp
}
   11599:	90                   	nop
   1159a:	c9                   	leave  
   1159b:	c3                   	ret    

0001159c <task_first_init>:

void task_first_init()
{
   1159c:	55                   	push   %ebp
   1159d:	89 e5                	mov    %esp,%ebp
   1159f:	83 ec 18             	sub    $0x18,%esp
    void first_task_entry(void);
    extern uint8_t s_first_task[];
    extern uint8_t e_first_task[];

    uint32_t copy_size = (uint32_t)(e_first_task - s_first_task);
   115a2:	ba fe e3 03 00       	mov    $0x3e3fe,%edx
   115a7:	b8 00 c1 03 00       	mov    $0x3c100,%eax
   115ac:	29 c2                	sub    %eax,%edx
   115ae:	89 d0                	mov    %edx,%eax
   115b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t alloc_size = 10 * MEM_PAGE_SIZE;
   115b3:	c7 45 f0 00 a0 00 00 	movl   $0xa000,-0x10(%ebp)
    
    uint32_t first_start = (uint32_t)first_task_entry;
   115ba:	c7 45 ec 00 00 00 80 	movl   $0x80000000,-0x14(%ebp)
    kernel_task_init(&task_manager.first_task,"first_task",first_start,first_start + alloc_size);
   115c1:	8b 55 ec             	mov    -0x14(%ebp),%edx
   115c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   115c7:	01 d0                	add    %edx,%eax
   115c9:	50                   	push   %eax
   115ca:	ff 75 ec             	pushl  -0x14(%ebp)
   115cd:	68 be 43 01 00       	push   $0x143be
   115d2:	68 54 80 01 00       	push   $0x18054
   115d7:	e8 73 fc ff ff       	call   1124f <kernel_task_init>
   115dc:	83 c4 10             	add    $0x10,%esp
    task_manager.global_tss.esp0 = task_manager.first_task.tss.esp0;
   115df:	a1 b4 80 01 00       	mov    0x180b4,%eax
   115e4:	a3 e0 81 01 00       	mov    %eax,0x181e0
    write_tr(task_manager.tss_sel);
   115e9:	a1 44 82 01 00       	mov    0x18244,%eax
   115ee:	0f b7 c0             	movzwl %ax,%eax
   115f1:	83 ec 0c             	sub    $0xc,%esp
   115f4:	50                   	push   %eax
   115f5:	e8 d1 fa ff ff       	call   110cb <write_tr>
   115fa:	83 c4 10             	add    $0x10,%esp
    task_manager.current_task = &task_manager.first_task;
   115fd:	c7 05 2c 80 01 00 54 	movl   $0x18054,0x1802c
   11604:	80 01 00 
    mmu_set_page_dir_task(task_manager.current_task);
   11607:	a1 2c 80 01 00       	mov    0x1802c,%eax
   1160c:	83 ec 0c             	sub    $0xc,%esp
   1160f:	50                   	push   %eax
   11610:	e8 d6 02 00 00       	call   118eb <mmu_set_page_dir_task>
   11615:	83 c4 10             	add    $0x10,%esp
  
    memory_alloc_page_for(first_start,alloc_size,PTE_P | PTE_W | PTE_U);
   11618:	83 ec 04             	sub    $0x4,%esp
   1161b:	6a 07                	push   $0x7
   1161d:	ff 75 f0             	pushl  -0x10(%ebp)
   11620:	ff 75 ec             	pushl  -0x14(%ebp)
   11623:	e8 1c f6 ff ff       	call   10c44 <memory_alloc_page_for>
   11628:	83 c4 10             	add    $0x10,%esp
    kernel_memcpy((void *)first_start,s_first_task,copy_size);
   1162b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1162e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11631:	83 ec 04             	sub    $0x4,%esp
   11634:	52                   	push   %edx
   11635:	68 00 c1 03 00       	push   $0x3c100
   1163a:	50                   	push   %eax
   1163b:	e8 56 23 00 00       	call   13996 <kernel_memcpy>
   11640:	83 c4 10             	add    $0x10,%esp

}
   11643:	90                   	nop
   11644:	c9                   	leave  
   11645:	c3                   	ret    

00011646 <get_from_task>:
task_t * get_from_task()
{
   11646:	55                   	push   %ebp
   11647:	89 e5                	mov    %esp,%ebp
    return task_manager.from_task;
   11649:	a1 24 80 01 00       	mov    0x18024,%eax
}
   1164e:	5d                   	pop    %ebp
   1164f:	c3                   	ret    

00011650 <get_to_task>:
task_t * get_to_task()
{
   11650:	55                   	push   %ebp
   11651:	89 e5                	mov    %esp,%ebp
    return task_manager.to_task;
   11653:	a1 28 80 01 00       	mov    0x18028,%eax
}
   11658:	5d                   	pop    %ebp
   11659:	c3                   	ret    

0001165a <task_is_need_reschedule>:
uint32_t task_is_need_reschedule()
{
   1165a:	55                   	push   %ebp
   1165b:	89 e5                	mov    %esp,%ebp
    return task_manager.need_reschedule;
   1165d:	a1 20 80 01 00       	mov    0x18020,%eax
}
   11662:	5d                   	pop    %ebp
   11663:	c3                   	ret    

00011664 <task_first_task>:
task_t * task_first_task()
{
   11664:	55                   	push   %ebp
   11665:	89 e5                	mov    %esp,%ebp
    return &task_manager.first_task;
   11667:	b8 54 80 01 00       	mov    $0x18054,%eax
}
   1166c:	5d                   	pop    %ebp
   1166d:	c3                   	ret    

0001166e <task_set_ready>:

void task_set_ready(task_t *task)
{
   1166e:	55                   	push   %ebp
   1166f:	89 e5                	mov    %esp,%ebp
   11671:	83 ec 08             	sub    $0x8,%esp
    if(task == &task_manager.idle_task)
   11674:	81 7d 08 18 81 01 00 	cmpl   $0x18118,0x8(%ebp)
   1167b:	74 23                	je     116a0 <task_set_ready+0x32>
    {
        return;
    }
    list_insert_last(&task_manager.ready_list,&task->run_node);
   1167d:	8b 45 08             	mov    0x8(%ebp),%eax
   11680:	83 c0 40             	add    $0x40,%eax
   11683:	83 ec 08             	sub    $0x8,%esp
   11686:	50                   	push   %eax
   11687:	68 30 80 01 00       	push   $0x18030
   1168c:	e8 fe 27 00 00       	call   13e8f <list_insert_last>
   11691:	83 c4 10             	add    $0x10,%esp
    task->state = TASK_READY;  
   11694:	8b 45 08             	mov    0x8(%ebp),%eax
   11697:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
   1169e:	eb 01                	jmp    116a1 <task_set_ready+0x33>
        return;
   116a0:	90                   	nop
}
   116a1:	c9                   	leave  
   116a2:	c3                   	ret    

000116a3 <task_set_block>:

void task_set_block(task_t *task)
{
   116a3:	55                   	push   %ebp
   116a4:	89 e5                	mov    %esp,%ebp
   116a6:	83 ec 08             	sub    $0x8,%esp
    if(task == &task_manager.idle_task)
   116a9:	81 7d 08 18 81 01 00 	cmpl   $0x18118,0x8(%ebp)
   116b0:	74 19                	je     116cb <task_set_block+0x28>
    {
        return;
    }
    list_remove(&task_manager.ready_list,&task->run_node);
   116b2:	8b 45 08             	mov    0x8(%ebp),%eax
   116b5:	83 c0 40             	add    $0x40,%eax
   116b8:	83 ec 08             	sub    $0x8,%esp
   116bb:	50                   	push   %eax
   116bc:	68 30 80 01 00       	push   $0x18030
   116c1:	e8 a4 28 00 00       	call   13f6a <list_remove>
   116c6:	83 c4 10             	add    $0x10,%esp
   116c9:	eb 01                	jmp    116cc <task_set_block+0x29>
        return;
   116cb:	90                   	nop
}
   116cc:	c9                   	leave  
   116cd:	c3                   	ret    

000116ce <task_current>:

task_t * task_current()
{
   116ce:	55                   	push   %ebp
   116cf:	89 e5                	mov    %esp,%ebp
    return task_manager.current_task;
   116d1:	a1 2c 80 01 00       	mov    0x1802c,%eax
}
   116d6:	5d                   	pop    %ebp
   116d7:	c3                   	ret    

000116d8 <sys_sched_yield>:
int sys_sched_yield()
{
   116d8:	55                   	push   %ebp
   116d9:	89 e5                	mov    %esp,%ebp
   116db:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   116de:	e8 39 18 00 00       	call   12f1c <irq_enter_protection>
   116e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(list_count(&task_manager.ready_list) > 1)
   116e6:	83 ec 0c             	sub    $0xc,%esp
   116e9:	68 30 80 01 00       	push   $0x18030
   116ee:	e8 9f f9 ff ff       	call   11092 <list_count>
   116f3:	83 c4 10             	add    $0x10,%esp
   116f6:	83 f8 01             	cmp    $0x1,%eax
   116f9:	7e 29                	jle    11724 <sys_sched_yield+0x4c>
    {
        task_t * current_task = task_current();
   116fb:	e8 ce ff ff ff       	call   116ce <task_current>
   11700:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_set_block(current_task);
   11703:	83 ec 0c             	sub    $0xc,%esp
   11706:	ff 75 f0             	pushl  -0x10(%ebp)
   11709:	e8 95 ff ff ff       	call   116a3 <task_set_block>
   1170e:	83 c4 10             	add    $0x10,%esp
        task_set_ready(current_task);
   11711:	83 ec 0c             	sub    $0xc,%esp
   11714:	ff 75 f0             	pushl  -0x10(%ebp)
   11717:	e8 52 ff ff ff       	call   1166e <task_set_ready>
   1171c:	83 c4 10             	add    $0x10,%esp

        task_dispatch();
   1171f:	e8 78 00 00 00       	call   1179c <task_dispatch>
    }
    irq_leave_protection(state);
   11724:	83 ec 0c             	sub    $0xc,%esp
   11727:	ff 75 f4             	pushl  -0xc(%ebp)
   1172a:	e8 05 18 00 00       	call   12f34 <irq_leave_protection>
   1172f:	83 c4 10             	add    $0x10,%esp
    return 0;
   11732:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11737:	c9                   	leave  
   11738:	c3                   	ret    

00011739 <task_next_run>:

task_t * task_next_run()
{
   11739:	55                   	push   %ebp
   1173a:	89 e5                	mov    %esp,%ebp
   1173c:	83 ec 10             	sub    $0x10,%esp
    if(list_count(&task_manager.ready_list) == 0)
   1173f:	68 30 80 01 00       	push   $0x18030
   11744:	e8 49 f9 ff ff       	call   11092 <list_count>
   11749:	83 c4 04             	add    $0x4,%esp
   1174c:	85 c0                	test   %eax,%eax
   1174e:	75 07                	jne    11757 <task_next_run+0x1e>
    {
        return &task_manager.idle_task;
   11750:	b8 18 81 01 00       	mov    $0x18118,%eax
   11755:	eb 30                	jmp    11787 <task_next_run+0x4e>
    }
    list_node_t * node = list_first(&task_manager.ready_list);
   11757:	68 30 80 01 00       	push   $0x18030
   1175c:	e8 3c f9 ff ff       	call   1109d <list_first>
   11761:	83 c4 04             	add    $0x4,%esp
   11764:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(node)
   11767:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1176b:	74 15                	je     11782 <task_next_run+0x49>
    {
        return list_node_parent(node,task_t,run_node);
   1176d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11771:	74 08                	je     1177b <task_next_run+0x42>
   11773:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11776:	83 e8 40             	sub    $0x40,%eax
   11779:	eb 0c                	jmp    11787 <task_next_run+0x4e>
   1177b:	b8 00 00 00 00       	mov    $0x0,%eax
   11780:	eb 05                	jmp    11787 <task_next_run+0x4e>
    }
    return (task_t *)0;
   11782:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11787:	c9                   	leave  
   11788:	c3                   	ret    

00011789 <schedule_switch>:

void schedule_switch()
{
   11789:	55                   	push   %ebp
   1178a:	89 e5                	mov    %esp,%ebp
   1178c:	83 ec 08             	sub    $0x8,%esp
    task_dispatch();
   1178f:	e8 08 00 00 00       	call   1179c <task_dispatch>
    //do_schedule_switch();
    schedule_next_task();
   11794:	e8 ad 02 00 00       	call   11a46 <schedule_next_task>
}
   11799:	90                   	nop
   1179a:	c9                   	leave  
   1179b:	c3                   	ret    

0001179c <task_dispatch>:
void task_dispatch()
{
   1179c:	55                   	push   %ebp
   1179d:	89 e5                	mov    %esp,%ebp
   1179f:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   117a2:	e8 75 17 00 00       	call   12f1c <irq_enter_protection>
   117a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t * next_task = task_next_run();
   117aa:	e8 8a ff ff ff       	call   11739 <task_next_run>
   117af:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(next_task != task_current())
   117b2:	e8 17 ff ff ff       	call   116ce <task_current>
   117b7:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   117ba:	74 34                	je     117f0 <task_dispatch+0x54>
    {
        task_t * from = task_current();
   117bc:	e8 0d ff ff ff       	call   116ce <task_current>
   117c1:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_manager.current_task = next_task;
   117c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   117c7:	a3 2c 80 01 00       	mov    %eax,0x1802c
        next_task->state = TASK_RUNNING;
   117cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   117cf:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
        task_manager.need_reschedule = TASK_NEED_RESCHEDULE;
   117d6:	c7 05 20 80 01 00 01 	movl   $0x1,0x18020
   117dd:	00 00 00 
        task_manager.from_task = from;
   117e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   117e3:	a3 24 80 01 00       	mov    %eax,0x18024
        task_manager.to_task = next_task;
   117e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   117eb:	a3 28 80 01 00       	mov    %eax,0x18028
    }
    irq_leave_protection(state);
   117f0:	83 ec 0c             	sub    $0xc,%esp
   117f3:	ff 75 f4             	pushl  -0xc(%ebp)
   117f6:	e8 39 17 00 00       	call   12f34 <irq_leave_protection>
   117fb:	83 c4 10             	add    $0x10,%esp
}
   117fe:	90                   	nop
   117ff:	c9                   	leave  
   11800:	c3                   	ret    

00011801 <task_time_tick>:

void task_time_tick()
{
   11801:	55                   	push   %ebp
   11802:	89 e5                	mov    %esp,%ebp
   11804:	83 ec 18             	sub    $0x18,%esp
    if(task_manager.need_reschedule || task_current() == (task_t *)0 )
   11807:	a1 20 80 01 00       	mov    0x18020,%eax
   1180c:	85 c0                	test   %eax,%eax
   1180e:	0f 85 d4 00 00 00    	jne    118e8 <task_time_tick+0xe7>
   11814:	e8 b5 fe ff ff       	call   116ce <task_current>
   11819:	85 c0                	test   %eax,%eax
   1181b:	0f 84 c7 00 00 00    	je     118e8 <task_time_tick+0xe7>
    {
        return; 
    }
    list_node_t * curr = list_first(&task_manager.sleep_list);
   11821:	68 3c 80 01 00       	push   $0x1803c
   11826:	e8 72 f8 ff ff       	call   1109d <list_first>
   1182b:	83 c4 04             	add    $0x4,%esp
   1182e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(curr)
   11831:	eb 5f                	jmp    11892 <task_time_tick+0x91>
    {
        list_node_t * next = list_node_next(curr);
   11833:	ff 75 f4             	pushl  -0xc(%ebp)
   11836:	e8 4c f8 ff ff       	call   11087 <list_node_next>
   1183b:	83 c4 04             	add    $0x4,%esp
   1183e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_t * task = list_node_parent(curr,task_t,run_node);
   11841:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11845:	74 08                	je     1184f <task_time_tick+0x4e>
   11847:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1184a:	83 e8 40             	sub    $0x40,%eax
   1184d:	eb 05                	jmp    11854 <task_time_tick+0x53>
   1184f:	b8 00 00 00 00       	mov    $0x0,%eax
   11854:	89 45 e8             	mov    %eax,-0x18(%ebp)
        task->sleep_ticks--;
   11857:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1185a:	8b 40 14             	mov    0x14(%eax),%eax
   1185d:	8d 50 ff             	lea    -0x1(%eax),%edx
   11860:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11863:	89 50 14             	mov    %edx,0x14(%eax)
        if(task->sleep_ticks <= 0)
   11866:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11869:	8b 40 14             	mov    0x14(%eax),%eax
   1186c:	85 c0                	test   %eax,%eax
   1186e:	7f 1c                	jg     1188c <task_time_tick+0x8b>
        {
            task_set_wakeup(task);
   11870:	83 ec 0c             	sub    $0xc,%esp
   11873:	ff 75 e8             	pushl  -0x18(%ebp)
   11876:	e8 4e 01 00 00       	call   119c9 <task_set_wakeup>
   1187b:	83 c4 10             	add    $0x10,%esp
            task_set_ready(task);
   1187e:	83 ec 0c             	sub    $0xc,%esp
   11881:	ff 75 e8             	pushl  -0x18(%ebp)
   11884:	e8 e5 fd ff ff       	call   1166e <task_set_ready>
   11889:	83 c4 10             	add    $0x10,%esp
        }
        curr = next;
   1188c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1188f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(curr)
   11892:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11896:	75 9b                	jne    11833 <task_time_tick+0x32>
    }
    task_t * current_task = task_current();
   11898:	e8 31 fe ff ff       	call   116ce <task_current>
   1189d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    current_task->slice_ticks--;
   118a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   118a3:	8b 40 18             	mov    0x18(%eax),%eax
   118a6:	8d 50 ff             	lea    -0x1(%eax),%edx
   118a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   118ac:	89 50 18             	mov    %edx,0x18(%eax)
    if(current_task->slice_ticks <= 0)
   118af:	8b 45 f0             	mov    -0x10(%ebp),%eax
   118b2:	8b 40 18             	mov    0x18(%eax),%eax
   118b5:	85 c0                	test   %eax,%eax
   118b7:	7f 30                	jg     118e9 <task_time_tick+0xe8>
    {
        current_task->slice_ticks = current_task->time_ticks;
   118b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   118bc:	8b 50 1c             	mov    0x1c(%eax),%edx
   118bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   118c2:	89 50 18             	mov    %edx,0x18(%eax)
        task_set_block(current_task);
   118c5:	83 ec 0c             	sub    $0xc,%esp
   118c8:	ff 75 f0             	pushl  -0x10(%ebp)
   118cb:	e8 d3 fd ff ff       	call   116a3 <task_set_block>
   118d0:	83 c4 10             	add    $0x10,%esp
        task_set_ready(current_task);
   118d3:	83 ec 0c             	sub    $0xc,%esp
   118d6:	ff 75 f0             	pushl  -0x10(%ebp)
   118d9:	e8 90 fd ff ff       	call   1166e <task_set_ready>
   118de:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   118e1:	e8 b6 fe ff ff       	call   1179c <task_dispatch>
   118e6:	eb 01                	jmp    118e9 <task_time_tick+0xe8>
        return; 
   118e8:	90                   	nop
    }
}
   118e9:	c9                   	leave  
   118ea:	c3                   	ret    

000118eb <mmu_set_page_dir_task>:

void mmu_set_page_dir_task(task_t * to_task)
{
   118eb:	55                   	push   %ebp
   118ec:	89 e5                	mov    %esp,%ebp
   118ee:	53                   	push   %ebx
    if(to_task == (task_t *)0)
   118ef:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   118f3:	74 2a                	je     1191f <mmu_set_page_dir_task+0x34>
    {
        return;
    }
    if(to_task->tss.cr3 != read_cr3() && to_task->tss.cr3 != 0)
   118f5:	8b 45 08             	mov    0x8(%ebp),%eax
   118f8:	8b 58 78             	mov    0x78(%eax),%ebx
   118fb:	e8 a7 f7 ff ff       	call   110a7 <read_cr3>
   11900:	39 c3                	cmp    %eax,%ebx
   11902:	74 1c                	je     11920 <mmu_set_page_dir_task+0x35>
   11904:	8b 45 08             	mov    0x8(%ebp),%eax
   11907:	8b 40 78             	mov    0x78(%eax),%eax
   1190a:	85 c0                	test   %eax,%eax
   1190c:	74 12                	je     11920 <mmu_set_page_dir_task+0x35>
    {
        write_cr3(to_task->tss.cr3);
   1190e:	8b 45 08             	mov    0x8(%ebp),%eax
   11911:	8b 40 78             	mov    0x78(%eax),%eax
   11914:	50                   	push   %eax
   11915:	e8 9e f7 ff ff       	call   110b8 <write_cr3>
   1191a:	83 c4 04             	add    $0x4,%esp
   1191d:	eb 01                	jmp    11920 <mmu_set_page_dir_task+0x35>
        return;
   1191f:	90                   	nop
    }
}
   11920:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11923:	c9                   	leave  
   11924:	c3                   	ret    

00011925 <sys_getpid>:

int sys_getpid()
{
   11925:	55                   	push   %ebp
   11926:	89 e5                	mov    %esp,%ebp
    return task_current()->pid;
   11928:	e8 a1 fd ff ff       	call   116ce <task_current>
   1192d:	8b 40 0c             	mov    0xc(%eax),%eax
}
   11930:	5d                   	pop    %ebp
   11931:	c3                   	ret    

00011932 <do_schedule_switch>:
void do_schedule_switch(void)
{
   11932:	55                   	push   %ebp
   11933:	89 e5                	mov    %esp,%ebp
   11935:	83 ec 08             	sub    $0x8,%esp
    if (task_manager.need_reschedule) {
   11938:	a1 20 80 01 00       	mov    0x18020,%eax
   1193d:	85 c0                	test   %eax,%eax
   1193f:	74 4a                	je     1198b <do_schedule_switch+0x59>
        task_manager.need_reschedule = TASK_NOT_NEED_RESCHEDULE;
   11941:	c7 05 20 80 01 00 00 	movl   $0x0,0x18020
   11948:	00 00 00 
        if (task_manager.from_task && task_manager.from_task != task_manager.to_task) {
   1194b:	a1 24 80 01 00       	mov    0x18024,%eax
   11950:	85 c0                	test   %eax,%eax
   11952:	74 37                	je     1198b <do_schedule_switch+0x59>
   11954:	8b 15 24 80 01 00    	mov    0x18024,%edx
   1195a:	a1 28 80 01 00       	mov    0x18028,%eax
   1195f:	39 c2                	cmp    %eax,%edx
   11961:	74 28                	je     1198b <do_schedule_switch+0x59>
            // 在这里进行任务切换
            // 使用简单的栈切换，避免复杂的中断上下文切换
            mmu_set_page_dir_task(task_manager.to_task);
   11963:	a1 28 80 01 00       	mov    0x18028,%eax
   11968:	50                   	push   %eax
   11969:	e8 7d ff ff ff       	call   118eb <mmu_set_page_dir_task>
   1196e:	83 c4 04             	add    $0x4,%esp
            simple_switch(&task_manager.from_task->stack, task_manager.to_task->stack);
   11971:	a1 28 80 01 00       	mov    0x18028,%eax
   11976:	8b 00                	mov    (%eax),%eax
   11978:	8b 15 24 80 01 00    	mov    0x18024,%edx
   1197e:	83 ec 08             	sub    $0x8,%esp
   11981:	50                   	push   %eax
   11982:	52                   	push   %edx
   11983:	e8 4a ea ff ff       	call   103d2 <simple_switch>
   11988:	83 c4 10             	add    $0x10,%esp
        }
    }
}
   1198b:	90                   	nop
   1198c:	c9                   	leave  
   1198d:	c3                   	ret    

0001198e <task_set_sleep>:

void task_set_sleep(task_t *task,uint32_t ticks)
{
   1198e:	55                   	push   %ebp
   1198f:	89 e5                	mov    %esp,%ebp
   11991:	83 ec 08             	sub    $0x8,%esp
    if(ticks == 0)
   11994:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11998:	74 2c                	je     119c6 <task_set_sleep+0x38>
    {
        return;
    }
    task->sleep_ticks = ticks;
   1199a:	8b 55 0c             	mov    0xc(%ebp),%edx
   1199d:	8b 45 08             	mov    0x8(%ebp),%eax
   119a0:	89 50 14             	mov    %edx,0x14(%eax)
    task->state = TASK_SLEEP;
   119a3:	8b 45 08             	mov    0x8(%ebp),%eax
   119a6:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
    list_insert_last(&task_manager.sleep_list,&task->run_node);
   119ad:	8b 45 08             	mov    0x8(%ebp),%eax
   119b0:	83 c0 40             	add    $0x40,%eax
   119b3:	83 ec 08             	sub    $0x8,%esp
   119b6:	50                   	push   %eax
   119b7:	68 3c 80 01 00       	push   $0x1803c
   119bc:	e8 ce 24 00 00       	call   13e8f <list_insert_last>
   119c1:	83 c4 10             	add    $0x10,%esp
   119c4:	eb 01                	jmp    119c7 <task_set_sleep+0x39>
        return;
   119c6:	90                   	nop
}
   119c7:	c9                   	leave  
   119c8:	c3                   	ret    

000119c9 <task_set_wakeup>:

void task_set_wakeup(task_t *task)
{
   119c9:	55                   	push   %ebp
   119ca:	89 e5                	mov    %esp,%ebp
   119cc:	83 ec 08             	sub    $0x8,%esp
    list_remove(&task_manager.sleep_list,&task->run_node);
   119cf:	8b 45 08             	mov    0x8(%ebp),%eax
   119d2:	83 c0 40             	add    $0x40,%eax
   119d5:	83 ec 08             	sub    $0x8,%esp
   119d8:	50                   	push   %eax
   119d9:	68 3c 80 01 00       	push   $0x1803c
   119de:	e8 87 25 00 00       	call   13f6a <list_remove>
   119e3:	83 c4 10             	add    $0x10,%esp

    //task->state = TASK_READY;
}
   119e6:	90                   	nop
   119e7:	c9                   	leave  
   119e8:	c3                   	ret    

000119e9 <sys_sleep>:

void sys_sleep(uint32_t ms)
{
   119e9:	55                   	push   %ebp
   119ea:	89 e5                	mov    %esp,%ebp
   119ec:	53                   	push   %ebx
   119ed:	83 ec 14             	sub    $0x14,%esp
    irq_state_t state = irq_enter_protection();
   119f0:	e8 27 15 00 00       	call   12f1c <irq_enter_protection>
   119f5:	89 45 f4             	mov    %eax,-0xc(%ebp)

    
    task_set_block(task_current());
   119f8:	e8 d1 fc ff ff       	call   116ce <task_current>
   119fd:	83 ec 0c             	sub    $0xc,%esp
   11a00:	50                   	push   %eax
   11a01:	e8 9d fc ff ff       	call   116a3 <task_set_block>
   11a06:	83 c4 10             	add    $0x10,%esp

    task_set_sleep(task_current(),(ms + (OS_TICK_MS - 1)) / OS_TICK_MS);
   11a09:	8b 45 08             	mov    0x8(%ebp),%eax
   11a0c:	83 c0 13             	add    $0x13,%eax
   11a0f:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
   11a14:	f7 e2                	mul    %edx
   11a16:	89 d3                	mov    %edx,%ebx
   11a18:	c1 eb 04             	shr    $0x4,%ebx
   11a1b:	e8 ae fc ff ff       	call   116ce <task_current>
   11a20:	83 ec 08             	sub    $0x8,%esp
   11a23:	53                   	push   %ebx
   11a24:	50                   	push   %eax
   11a25:	e8 64 ff ff ff       	call   1198e <task_set_sleep>
   11a2a:	83 c4 10             	add    $0x10,%esp

    //task_dispatch();
    schedule_switch();
   11a2d:	e8 57 fd ff ff       	call   11789 <schedule_switch>
    irq_leave_protection(state);
   11a32:	83 ec 0c             	sub    $0xc,%esp
   11a35:	ff 75 f4             	pushl  -0xc(%ebp)
   11a38:	e8 f7 14 00 00       	call   12f34 <irq_leave_protection>
   11a3d:	83 c4 10             	add    $0x10,%esp
}
   11a40:	90                   	nop
   11a41:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11a44:	c9                   	leave  
   11a45:	c3                   	ret    

00011a46 <schedule_next_task>:

void universal_task_switch();
void schedule_next_task() {
   11a46:	55                   	push   %ebp
   11a47:	89 e5                	mov    %esp,%ebp
   11a49:	57                   	push   %edi
   11a4a:	56                   	push   %esi
   11a4b:	53                   	push   %ebx
   11a4c:	83 ec 3c             	sub    $0x3c,%esp
    
        task_t *old =  task_manager.from_task;
   11a4f:	a1 24 80 01 00       	mov    0x18024,%eax
   11a54:	89 45 e0             	mov    %eax,-0x20(%ebp)
        task_t *next_task = task_manager.to_task;
   11a57:	a1 28 80 01 00       	mov    0x18028,%eax
   11a5c:	89 45 dc             	mov    %eax,-0x24(%ebp)
        if(task_manager.need_reschedule == TASK_NEED_RESCHEDULE)
   11a5f:	a1 20 80 01 00       	mov    0x18020,%eax
   11a64:	83 f8 01             	cmp    $0x1,%eax
   11a67:	0f 85 19 01 00 00    	jne    11b86 <schedule_next_task+0x140>
        {
            task_manager.need_reschedule = TASK_NOT_NEED_RESCHEDULE;
   11a6d:	c7 05 20 80 01 00 00 	movl   $0x0,0x18020
   11a74:	00 00 00 
        }
        else
        {
            return;
        }
        if (next_task && next_task != old ) {
   11a77:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   11a7b:	0f 84 06 01 00 00    	je     11b87 <schedule_next_task+0x141>
   11a81:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11a84:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   11a87:	0f 84 fa 00 00 00    	je     11b87 <schedule_next_task+0x141>
            uint32_t sesp = 0;
   11a8d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
            if(next_task->task_type == TASK_USER)
   11a94:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11a97:	8b 40 08             	mov    0x8(%eax),%eax
   11a9a:	83 f8 01             	cmp    $0x1,%eax
   11a9d:	75 0e                	jne    11aad <schedule_next_task+0x67>
            {
                sesp = next_task->tss.esp;
   11a9f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11aa2:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   11aa8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   11aab:	eb 09                	jmp    11ab6 <schedule_next_task+0x70>
            }
            else
            {
                sesp = next_task->tss.esp0;
   11aad:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11ab0:	8b 40 60             	mov    0x60(%eax),%eax
   11ab3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            }
            task_manager.global_tss.esp0 = next_task->esp0_start;
   11ab6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11ab9:	8b 40 58             	mov    0x58(%eax),%eax
   11abc:	a3 e0 81 01 00       	mov    %eax,0x181e0
        // 一个函数搞定所有切换！
        universal_task_switch(
   11ac1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11ac4:	8b b0 98 00 00 00    	mov    0x98(%eax),%esi
   11aca:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11acd:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11ad3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   11ad6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11ad9:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   11adf:	89 45 d0             	mov    %eax,-0x30(%ebp)
   11ae2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11ae5:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   11aeb:	89 45 cc             	mov    %eax,-0x34(%ebp)
   11aee:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11af1:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
   11af7:	89 45 c8             	mov    %eax,-0x38(%ebp)
   11afa:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11afd:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
   11b03:	89 45 c4             	mov    %eax,-0x3c(%ebp)
   11b06:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11b09:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   11b0f:	89 45 c0             	mov    %eax,-0x40(%ebp)
   11b12:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11b15:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   11b1b:	89 45 bc             	mov    %eax,-0x44(%ebp)
   11b1e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11b21:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   11b27:	89 45 b8             	mov    %eax,-0x48(%ebp)
   11b2a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11b2d:	8b 78 7c             	mov    0x7c(%eax),%edi
   11b30:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11b33:	8b 98 a8 00 00 00    	mov    0xa8(%eax),%ebx
   11b39:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11b3c:	8b 50 78             	mov    0x78(%eax),%edx
   11b3f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11b42:	8d 48 08             	lea    0x8(%eax),%ecx
   11b45:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11b49:	74 08                	je     11b53 <schedule_next_task+0x10d>
   11b4b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11b4e:	83 c0 5c             	add    $0x5c,%eax
   11b51:	eb 05                	jmp    11b58 <schedule_next_task+0x112>
   11b53:	b8 00 00 00 00       	mov    $0x0,%eax
   11b58:	83 ec 04             	sub    $0x4,%esp
   11b5b:	56                   	push   %esi
   11b5c:	ff 75 d4             	pushl  -0x2c(%ebp)
   11b5f:	ff 75 d0             	pushl  -0x30(%ebp)
   11b62:	ff 75 cc             	pushl  -0x34(%ebp)
   11b65:	ff 75 c8             	pushl  -0x38(%ebp)
   11b68:	ff 75 c4             	pushl  -0x3c(%ebp)
   11b6b:	ff 75 c0             	pushl  -0x40(%ebp)
   11b6e:	ff 75 e4             	pushl  -0x1c(%ebp)
   11b71:	ff 75 bc             	pushl  -0x44(%ebp)
   11b74:	ff 75 b8             	pushl  -0x48(%ebp)
   11b77:	57                   	push   %edi
   11b78:	53                   	push   %ebx
   11b79:	52                   	push   %edx
   11b7a:	51                   	push   %ecx
   11b7b:	50                   	push   %eax
   11b7c:	e8 68 e8 ff ff       	call   103e9 <universal_task_switch>
   11b81:	83 c4 40             	add    $0x40,%esp
   11b84:	eb 01                	jmp    11b87 <schedule_next_task+0x141>
            return;
   11b86:	90                   	nop
            next_task->tss.edi,                         // 新任务EDI寄存器
            next_task->tss.ebp                          // 新任务EBP寄存器

        );
    }
}
   11b87:	8d 65 f4             	lea    -0xc(%ebp),%esp
   11b8a:	5b                   	pop    %ebx
   11b8b:	5e                   	pop    %esi
   11b8c:	5f                   	pop    %edi
   11b8d:	5d                   	pop    %ebp
   11b8e:	c3                   	ret    

00011b8f <task_alloc>:


static task_t * task_alloc()
{
   11b8f:	55                   	push   %ebp
   11b90:	89 e5                	mov    %esp,%ebp
   11b92:	83 ec 18             	sub    $0x18,%esp
    mutex_lock(&task_table_mutex);
   11b95:	83 ec 0c             	sub    $0xc,%esp
   11b98:	68 60 04 02 00       	push   $0x20460
   11b9d:	e8 c4 17 00 00       	call   13366 <mutex_lock>
   11ba2:	83 c4 10             	add    $0x10,%esp
    task_t *task = (task_t *)0;
   11ba5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    for(int i = 0; i < TASK_COUNT; i++)
   11bac:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11bb3:	eb 28                	jmp    11bdd <task_alloc+0x4e>
    {
        task_t * curr = task_table + i;
   11bb5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11bb8:	69 c0 c4 00 00 00    	imul   $0xc4,%eax,%eax
   11bbe:	05 60 a2 01 00       	add    $0x1a260,%eax
   11bc3:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(curr->name[0] == '\0')
   11bc6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11bc9:	0f b6 40 20          	movzbl 0x20(%eax),%eax
   11bcd:	84 c0                	test   %al,%al
   11bcf:	75 08                	jne    11bd9 <task_alloc+0x4a>
        {
            task = curr;
   11bd1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11bd4:	89 45 f4             	mov    %eax,-0xc(%ebp)
            break;
   11bd7:	eb 0a                	jmp    11be3 <task_alloc+0x54>
    for(int i = 0; i < TASK_COUNT; i++)
   11bd9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11bdd:	83 7d f0 7f          	cmpl   $0x7f,-0x10(%ebp)
   11be1:	7e d2                	jle    11bb5 <task_alloc+0x26>
        }
    }
    mutex_unlock(&task_table_mutex);
   11be3:	83 ec 0c             	sub    $0xc,%esp
   11be6:	68 60 04 02 00       	push   $0x20460
   11beb:	e8 06 18 00 00       	call   133f6 <mutex_unlock>
   11bf0:	83 c4 10             	add    $0x10,%esp
    return task;
   11bf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11bf6:	c9                   	leave  
   11bf7:	c3                   	ret    

00011bf8 <task_free>:

static void task_free(task_t *task)
{
   11bf8:	55                   	push   %ebp
   11bf9:	89 e5                	mov    %esp,%ebp
   11bfb:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&task_table_mutex);
   11bfe:	83 ec 0c             	sub    $0xc,%esp
   11c01:	68 60 04 02 00       	push   $0x20460
   11c06:	e8 5b 17 00 00       	call   13366 <mutex_lock>
   11c0b:	83 c4 10             	add    $0x10,%esp
    task->name[0] = '\0';
   11c0e:	8b 45 08             	mov    0x8(%ebp),%eax
   11c11:	c6 40 20 00          	movb   $0x0,0x20(%eax)
    mutex_unlock(&task_table_mutex);
   11c15:	83 ec 0c             	sub    $0xc,%esp
   11c18:	68 60 04 02 00       	push   $0x20460
   11c1d:	e8 d4 17 00 00       	call   133f6 <mutex_unlock>
   11c22:	83 c4 10             	add    $0x10,%esp
}
   11c25:	90                   	nop
   11c26:	c9                   	leave  
   11c27:	c3                   	ret    

00011c28 <sys_fork>:

int sys_fork()
{
   11c28:	55                   	push   %ebp
   11c29:	89 e5                	mov    %esp,%ebp
   11c2b:	83 ec 28             	sub    $0x28,%esp
    task_t * parent = task_current();
   11c2e:	e8 9b fa ff ff       	call   116ce <task_current>
   11c33:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t * child = task_alloc();
   11c36:	e8 54 ff ff ff       	call   11b8f <task_alloc>
   11c3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(child == (task_t *)0)
   11c3e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11c42:	0f 84 1e 01 00 00    	je     11d66 <sys_fork+0x13e>
    {
        goto fork_failed;
    }
    syscall_frame_t * frame = (syscall_frame_t *)(task_manager.global_tss.esp0 - sizeof(syscall_frame_t));
   11c48:	a1 e0 81 01 00       	mov    0x181e0,%eax
   11c4d:	83 e8 58             	sub    $0x58,%eax
   11c50:	89 45 ec             	mov    %eax,-0x14(%ebp)
    
    
    int err = user_task_init(child,parent->name,frame->eip,frame->esp + sizeof(uint32_t) * SYSCALL_PARAM_COUNT);
   11c53:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11c56:	8b 40 50             	mov    0x50(%eax),%eax
   11c59:	8d 50 14             	lea    0x14(%eax),%edx
   11c5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11c5f:	8b 40 34             	mov    0x34(%eax),%eax
   11c62:	89 c1                	mov    %eax,%ecx
   11c64:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c67:	83 c0 20             	add    $0x20,%eax
   11c6a:	52                   	push   %edx
   11c6b:	51                   	push   %ecx
   11c6c:	50                   	push   %eax
   11c6d:	ff 75 f0             	pushl  -0x10(%ebp)
   11c70:	e8 c9 f6 ff ff       	call   1133e <user_task_init>
   11c75:	83 c4 10             	add    $0x10,%esp
   11c78:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(err < 0)
   11c7b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11c7f:	0f 88 e4 00 00 00    	js     11d69 <sys_fork+0x141>
    {
        goto fork_failed;
    }
    tss_t * tss = &child->tss;
   11c85:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c88:	83 c0 5c             	add    $0x5c,%eax
   11c8b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tss->eax = 0;
   11c8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11c91:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
    tss->ebx = frame->ebx;
   11c98:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11c9b:	8b 40 24             	mov    0x24(%eax),%eax
   11c9e:	89 c2                	mov    %eax,%edx
   11ca0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11ca3:	89 50 34             	mov    %edx,0x34(%eax)
    tss->ecx = frame->ecx;
   11ca6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11ca9:	8b 40 2c             	mov    0x2c(%eax),%eax
   11cac:	89 c2                	mov    %eax,%edx
   11cae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11cb1:	89 50 2c             	mov    %edx,0x2c(%eax)
    tss->edx = frame->edx;
   11cb4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11cb7:	8b 40 28             	mov    0x28(%eax),%eax
   11cba:	89 c2                	mov    %eax,%edx
   11cbc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11cbf:	89 50 30             	mov    %edx,0x30(%eax)
    tss->esi = frame->esi;
   11cc2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11cc5:	8b 40 18             	mov    0x18(%eax),%eax
   11cc8:	89 c2                	mov    %eax,%edx
   11cca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11ccd:	89 50 40             	mov    %edx,0x40(%eax)
    tss->edi = frame->edi;
   11cd0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11cd3:	8b 40 14             	mov    0x14(%eax),%eax
   11cd6:	89 c2                	mov    %eax,%edx
   11cd8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11cdb:	89 50 44             	mov    %edx,0x44(%eax)
    tss->ebp = frame->ebp;
   11cde:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11ce1:	8b 40 1c             	mov    0x1c(%eax),%eax
   11ce4:	89 c2                	mov    %eax,%edx
   11ce6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11ce9:	89 50 3c             	mov    %edx,0x3c(%eax)
    tss->cs = frame->cs;
   11cec:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11cef:	8b 40 38             	mov    0x38(%eax),%eax
   11cf2:	89 c2                	mov    %eax,%edx
   11cf4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11cf7:	89 50 4c             	mov    %edx,0x4c(%eax)
    tss->ds = frame->ds;
   11cfa:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11cfd:	8b 40 10             	mov    0x10(%eax),%eax
   11d00:	89 c2                	mov    %eax,%edx
   11d02:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d05:	89 50 54             	mov    %edx,0x54(%eax)
    tss->es = frame->es;
   11d08:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d0b:	8b 40 0c             	mov    0xc(%eax),%eax
   11d0e:	89 c2                	mov    %eax,%edx
   11d10:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d13:	89 50 48             	mov    %edx,0x48(%eax)
    tss->fs = frame->fs;
   11d16:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d19:	8b 40 08             	mov    0x8(%eax),%eax
   11d1c:	89 c2                	mov    %eax,%edx
   11d1e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d21:	89 50 58             	mov    %edx,0x58(%eax)
    tss->gs = frame->gs;
   11d24:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d27:	8b 40 04             	mov    0x4(%eax),%eax
   11d2a:	89 c2                	mov    %eax,%edx
   11d2c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d2f:	89 50 5c             	mov    %edx,0x5c(%eax)
    tss->eflags = frame->eflags;
   11d32:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d35:	8b 00                	mov    (%eax),%eax
   11d37:	89 c2                	mov    %eax,%edx
   11d39:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d3c:	89 50 24             	mov    %edx,0x24(%eax)

    if(memory_copy_vum(parent->tss.cr3,child->tss.cr3)<0)
   11d3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d42:	8b 50 78             	mov    0x78(%eax),%edx
   11d45:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11d48:	8b 40 78             	mov    0x78(%eax),%eax
   11d4b:	83 ec 08             	sub    $0x8,%esp
   11d4e:	52                   	push   %edx
   11d4f:	50                   	push   %eax
   11d50:	e8 90 ef ff ff       	call   10ce5 <memory_copy_vum>
   11d55:	83 c4 10             	add    $0x10,%esp
    {
        goto fork_failed;
    }
    child->parent = parent;
   11d58:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d5b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11d5e:	89 50 10             	mov    %edx,0x10(%eax)
    // tss->cr3 = parent->tss.cr3;
    return (uint32_t)child;
   11d61:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d64:	eb 2b                	jmp    11d91 <sys_fork+0x169>
        goto fork_failed;
   11d66:	90                   	nop
   11d67:	eb 01                	jmp    11d6a <sys_fork+0x142>
        goto fork_failed;
   11d69:	90                   	nop

    
fork_failed: 
    if(child)
   11d6a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11d6e:	74 1c                	je     11d8c <sys_fork+0x164>
    {
        task_uninit(child);
   11d70:	83 ec 0c             	sub    $0xc,%esp
   11d73:	ff 75 f0             	pushl  -0x10(%ebp)
   11d76:	e8 9a f4 ff ff       	call   11215 <task_uninit>
   11d7b:	83 c4 10             	add    $0x10,%esp
        task_free(child);
   11d7e:	83 ec 0c             	sub    $0xc,%esp
   11d81:	ff 75 f0             	pushl  -0x10(%ebp)
   11d84:	e8 6f fe ff ff       	call   11bf8 <task_free>
   11d89:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   11d8c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11d91:	c9                   	leave  
   11d92:	c3                   	ret    

00011d93 <load_phdr>:
static int load_phdr(int file,Elf32_Phdr *elf_phdr,uint32_t new_page_dir)
{
   11d93:	55                   	push   %ebp
   11d94:	89 e5                	mov    %esp,%ebp
   11d96:	83 ec 28             	sub    $0x28,%esp
    int err = memory_alloc_for_page_dir(new_page_dir,elf_phdr->p_vaddr,elf_phdr->p_memsz,PTE_P | PTE_W | PTE_U);
   11d99:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d9c:	8b 50 14             	mov    0x14(%eax),%edx
   11d9f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11da2:	8b 40 08             	mov    0x8(%eax),%eax
   11da5:	6a 07                	push   $0x7
   11da7:	52                   	push   %edx
   11da8:	50                   	push   %eax
   11da9:	ff 75 10             	pushl  0x10(%ebp)
   11dac:	e8 f1 ed ff ff       	call   10ba2 <memory_alloc_for_page_dir>
   11db1:	83 c4 10             	add    $0x10,%esp
   11db4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(err < 0)
   11db7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11dbb:	79 0a                	jns    11dc7 <load_phdr+0x34>
    {
        return -1;
   11dbd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11dc2:	e9 95 00 00 00       	jmp    11e5c <load_phdr+0xc9>
    }
    if(sys_lseek(file,elf_phdr->p_offset,0) < 0)
   11dc7:	8b 45 0c             	mov    0xc(%ebp),%eax
   11dca:	8b 40 04             	mov    0x4(%eax),%eax
   11dcd:	83 ec 04             	sub    $0x4,%esp
   11dd0:	6a 00                	push   $0x0
   11dd2:	50                   	push   %eax
   11dd3:	ff 75 08             	pushl  0x8(%ebp)
   11dd6:	e8 33 14 00 00       	call   1320e <sys_lseek>
   11ddb:	83 c4 10             	add    $0x10,%esp
   11dde:	85 c0                	test   %eax,%eax
   11de0:	79 07                	jns    11de9 <load_phdr+0x56>
    {
        return -1;
   11de2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11de7:	eb 73                	jmp    11e5c <load_phdr+0xc9>
    }
    uint32_t vaddr = elf_phdr->p_vaddr;
   11de9:	8b 45 0c             	mov    0xc(%ebp),%eax
   11dec:	8b 40 08             	mov    0x8(%eax),%eax
   11def:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t size = elf_phdr->p_filesz;
   11df2:	8b 45 0c             	mov    0xc(%ebp),%eax
   11df5:	8b 40 10             	mov    0x10(%eax),%eax
   11df8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(size > 0)
   11dfb:	eb 54                	jmp    11e51 <load_phdr+0xbe>
    {
        int cnt_size = size > MEM_PAGE_SIZE ? MEM_PAGE_SIZE : size;
   11dfd:	b8 00 10 00 00       	mov    $0x1000,%eax
   11e02:	81 7d f0 00 10 00 00 	cmpl   $0x1000,-0x10(%ebp)
   11e09:	0f 46 45 f0          	cmovbe -0x10(%ebp),%eax
   11e0d:	89 45 e8             	mov    %eax,-0x18(%ebp)
        uint32_t paddr = memory_get_paddr(new_page_dir,vaddr);
   11e10:	83 ec 08             	sub    $0x8,%esp
   11e13:	ff 75 f4             	pushl  -0xc(%ebp)
   11e16:	ff 75 10             	pushl  0x10(%ebp)
   11e19:	e8 d6 f0 ff ff       	call   10ef4 <memory_get_paddr>
   11e1e:	83 c4 10             	add    $0x10,%esp
   11e21:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(sys_read(file,(char *)paddr,cnt_size) < cnt_size)
   11e24:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11e27:	83 ec 04             	sub    $0x4,%esp
   11e2a:	ff 75 e8             	pushl  -0x18(%ebp)
   11e2d:	50                   	push   %eax
   11e2e:	ff 75 08             	pushl  0x8(%ebp)
   11e31:	e8 8f 13 00 00       	call   131c5 <sys_read>
   11e36:	83 c4 10             	add    $0x10,%esp
   11e39:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   11e3c:	7e 07                	jle    11e45 <load_phdr+0xb2>
        {
            return -1;
   11e3e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11e43:	eb 17                	jmp    11e5c <load_phdr+0xc9>
        }
        vaddr += cnt_size;
   11e45:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11e48:	01 45 f4             	add    %eax,-0xc(%ebp)
        size -= cnt_size;
   11e4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11e4e:	29 45 f0             	sub    %eax,-0x10(%ebp)
    while(size > 0)
   11e51:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11e55:	75 a6                	jne    11dfd <load_phdr+0x6a>
    }
    return 0;
   11e57:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11e5c:	c9                   	leave  
   11e5d:	c3                   	ret    

00011e5e <load_elf_file>:
static uint32_t load_elf_file(task_t *task,char *name,uint32_t new_page_dir)
{
   11e5e:	55                   	push   %ebp
   11e5f:	89 e5                	mov    %esp,%ebp
   11e61:	53                   	push   %ebx
   11e62:	83 ec 74             	sub    $0x74,%esp
    Elf32_Ehdr elf_hdr;
    Elf32_Phdr elf_phdr;
    int file = sys_open(name,0);
   11e65:	83 ec 08             	sub    $0x8,%esp
   11e68:	6a 00                	push   $0x0
   11e6a:	ff 75 0c             	pushl  0xc(%ebp)
   11e6d:	e8 1a 13 00 00       	call   1318c <sys_open>
   11e72:	83 c4 10             	add    $0x10,%esp
   11e75:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(file < 0)
   11e78:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11e7c:	79 0a                	jns    11e88 <load_elf_file+0x2a>
    {
        return 0;
   11e7e:	b8 00 00 00 00       	mov    $0x0,%eax
   11e83:	e9 8c 01 00 00       	jmp    12014 <load_elf_file+0x1b6>
        goto load_failed;
    }
    int cnt = sys_read(file,(char *)&elf_hdr,sizeof(Elf32_Ehdr));
   11e88:	83 ec 04             	sub    $0x4,%esp
   11e8b:	6a 34                	push   $0x34
   11e8d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   11e90:	50                   	push   %eax
   11e91:	ff 75 ec             	pushl  -0x14(%ebp)
   11e94:	e8 2c 13 00 00       	call   131c5 <sys_read>
   11e99:	83 c4 10             	add    $0x10,%esp
   11e9c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(cnt < sizeof(Elf32_Ehdr))
   11e9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11ea2:	83 f8 33             	cmp    $0x33,%eax
   11ea5:	77 18                	ja     11ebf <load_elf_file+0x61>
    {
        log_printf("load elf file failed,read cnt = %d",cnt);
   11ea7:	83 ec 08             	sub    $0x8,%esp
   11eaa:	ff 75 e8             	pushl  -0x18(%ebp)
   11ead:	68 cc 43 01 00       	push   $0x143cc
   11eb2:	e8 10 22 00 00       	call   140c7 <log_printf>
   11eb7:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   11eba:	e9 3c 01 00 00       	jmp    11ffb <load_elf_file+0x19d>
    }
    if(elf_hdr.e_ident[0] != 0x7f || elf_hdr.e_ident[1] != 'E' 
   11ebf:	0f b6 45 b0          	movzbl -0x50(%ebp),%eax
   11ec3:	3c 7f                	cmp    $0x7f,%al
   11ec5:	75 18                	jne    11edf <load_elf_file+0x81>
   11ec7:	0f b6 45 b1          	movzbl -0x4f(%ebp),%eax
   11ecb:	3c 45                	cmp    $0x45,%al
   11ecd:	75 10                	jne    11edf <load_elf_file+0x81>
        || elf_hdr.e_ident[2] != 'L' 
   11ecf:	0f b6 45 b2          	movzbl -0x4e(%ebp),%eax
   11ed3:	3c 4c                	cmp    $0x4c,%al
   11ed5:	75 08                	jne    11edf <load_elf_file+0x81>
        || elf_hdr.e_ident[3] != 'F')
   11ed7:	0f b6 45 b3          	movzbl -0x4d(%ebp),%eax
   11edb:	3c 46                	cmp    $0x46,%al
   11edd:	74 35                	je     11f14 <load_elf_file+0xb6>
    {
        log_printf("load elf file failed,elf_hdr.e_ident[0] = %d,elf_hdr.e_ident[1] = %d,elf_hdr.e_ident[2] = %d,elf_hdr.e_ident[3] = %d",elf_hdr.e_ident[0],elf_hdr.e_ident[1],elf_hdr.e_ident[2],elf_hdr.e_ident[3]);
   11edf:	0f b6 45 b3          	movzbl -0x4d(%ebp),%eax
   11ee3:	0f be d8             	movsbl %al,%ebx
   11ee6:	0f b6 45 b2          	movzbl -0x4e(%ebp),%eax
   11eea:	0f be c8             	movsbl %al,%ecx
   11eed:	0f b6 45 b1          	movzbl -0x4f(%ebp),%eax
   11ef1:	0f be d0             	movsbl %al,%edx
   11ef4:	0f b6 45 b0          	movzbl -0x50(%ebp),%eax
   11ef8:	0f be c0             	movsbl %al,%eax
   11efb:	83 ec 0c             	sub    $0xc,%esp
   11efe:	53                   	push   %ebx
   11eff:	51                   	push   %ecx
   11f00:	52                   	push   %edx
   11f01:	50                   	push   %eax
   11f02:	68 f0 43 01 00       	push   $0x143f0
   11f07:	e8 bb 21 00 00       	call   140c7 <log_printf>
   11f0c:	83 c4 20             	add    $0x20,%esp
        goto load_failed;
   11f0f:	e9 e7 00 00 00       	jmp    11ffb <load_elf_file+0x19d>
    }
    uint32_t e_phoff = elf_hdr.e_phoff;
   11f14:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11f17:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(int i = 0; i < elf_hdr.e_phnum; i++,e_phoff += elf_hdr.e_phentsize)
   11f1a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11f21:	e9 b2 00 00 00       	jmp    11fd8 <load_elf_file+0x17a>
    {
        if(sys_lseek(file,e_phoff,0) < 0)
   11f26:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f29:	83 ec 04             	sub    $0x4,%esp
   11f2c:	6a 00                	push   $0x0
   11f2e:	50                   	push   %eax
   11f2f:	ff 75 ec             	pushl  -0x14(%ebp)
   11f32:	e8 d7 12 00 00       	call   1320e <sys_lseek>
   11f37:	83 c4 10             	add    $0x10,%esp
   11f3a:	85 c0                	test   %eax,%eax
   11f3c:	79 15                	jns    11f53 <load_elf_file+0xf5>
        {
            log_printf("load elf file failed,sys_lseek failed");
   11f3e:	83 ec 0c             	sub    $0xc,%esp
   11f41:	68 68 44 01 00       	push   $0x14468
   11f46:	e8 7c 21 00 00       	call   140c7 <log_printf>
   11f4b:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11f4e:	e9 a8 00 00 00       	jmp    11ffb <load_elf_file+0x19d>
        }
        cnt = sys_read(file,(char *)&elf_phdr,sizeof(elf_phdr));
   11f53:	83 ec 04             	sub    $0x4,%esp
   11f56:	6a 20                	push   $0x20
   11f58:	8d 45 90             	lea    -0x70(%ebp),%eax
   11f5b:	50                   	push   %eax
   11f5c:	ff 75 ec             	pushl  -0x14(%ebp)
   11f5f:	e8 61 12 00 00       	call   131c5 <sys_read>
   11f64:	83 c4 10             	add    $0x10,%esp
   11f67:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(cnt < sizeof(elf_phdr))
   11f6a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11f6d:	83 f8 1f             	cmp    $0x1f,%eax
   11f70:	77 15                	ja     11f87 <load_elf_file+0x129>
        {
            log_printf("load elf file failed,read cnt = %d",cnt);
   11f72:	83 ec 08             	sub    $0x8,%esp
   11f75:	ff 75 e8             	pushl  -0x18(%ebp)
   11f78:	68 cc 43 01 00       	push   $0x143cc
   11f7d:	e8 45 21 00 00       	call   140c7 <log_printf>
   11f82:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11f85:	eb 74                	jmp    11ffb <load_elf_file+0x19d>
        }
        if(elf_phdr.p_type != PT_LOAD || elf_phdr.p_vaddr < MEM_PAGE_SIZE)
   11f87:	8b 45 90             	mov    -0x70(%ebp),%eax
   11f8a:	83 f8 01             	cmp    $0x1,%eax
   11f8d:	75 3a                	jne    11fc9 <load_elf_file+0x16b>
   11f8f:	8b 45 98             	mov    -0x68(%ebp),%eax
   11f92:	3d ff 0f 00 00       	cmp    $0xfff,%eax
   11f97:	76 30                	jbe    11fc9 <load_elf_file+0x16b>
        {
            continue;
        }
        int err = load_phdr(file,&elf_phdr,new_page_dir);
   11f99:	83 ec 04             	sub    $0x4,%esp
   11f9c:	ff 75 10             	pushl  0x10(%ebp)
   11f9f:	8d 45 90             	lea    -0x70(%ebp),%eax
   11fa2:	50                   	push   %eax
   11fa3:	ff 75 ec             	pushl  -0x14(%ebp)
   11fa6:	e8 e8 fd ff ff       	call   11d93 <load_phdr>
   11fab:	83 c4 10             	add    $0x10,%esp
   11fae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(err < 0)
   11fb1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   11fb5:	79 13                	jns    11fca <load_elf_file+0x16c>
        {
            log_printf("load elf file failed,load_phdr failed");
   11fb7:	83 ec 0c             	sub    $0xc,%esp
   11fba:	68 90 44 01 00       	push   $0x14490
   11fbf:	e8 03 21 00 00       	call   140c7 <log_printf>
   11fc4:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11fc7:	eb 32                	jmp    11ffb <load_elf_file+0x19d>
            continue;
   11fc9:	90                   	nop
    for(int i = 0; i < elf_hdr.e_phnum; i++,e_phoff += elf_hdr.e_phentsize)
   11fca:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11fce:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
   11fd2:	0f b7 c0             	movzwl %ax,%eax
   11fd5:	01 45 f4             	add    %eax,-0xc(%ebp)
   11fd8:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
   11fdc:	0f b7 c0             	movzwl %ax,%eax
   11fdf:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11fe2:	0f 8c 3e ff ff ff    	jl     11f26 <load_elf_file+0xc8>
        }

    }
    
    sys_close(file);
   11fe8:	83 ec 0c             	sub    $0xc,%esp
   11feb:	ff 75 ec             	pushl  -0x14(%ebp)
   11fee:	e8 3f 12 00 00       	call   13232 <sys_close>
   11ff3:	83 c4 10             	add    $0x10,%esp
    return elf_hdr.e_entry;
   11ff6:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11ff9:	eb 19                	jmp    12014 <load_elf_file+0x1b6>
load_failed:
    if(file)
   11ffb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11fff:	74 0e                	je     1200f <load_elf_file+0x1b1>
    {
        sys_close(file);
   12001:	83 ec 0c             	sub    $0xc,%esp
   12004:	ff 75 ec             	pushl  -0x14(%ebp)
   12007:	e8 26 12 00 00       	call   13232 <sys_close>
   1200c:	83 c4 10             	add    $0x10,%esp
    }
    return 0;
   1200f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12014:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12017:	c9                   	leave  
   12018:	c3                   	ret    

00012019 <copy_args>:

static int copy_args (char * to, uint32_t page_dir, int argc, char **argv) {
   12019:	55                   	push   %ebp
   1201a:	89 e5                	mov    %esp,%ebp
   1201c:	83 ec 38             	sub    $0x38,%esp
    // 在stack_top中依次写入argc, argv指针，参数字符串
    task_args_t task_args;
    task_args.argc = argc;
   1201f:	8b 45 10             	mov    0x10(%ebp),%eax
   12022:	89 45 d8             	mov    %eax,-0x28(%ebp)
    task_args.argv = (char **)(to + sizeof(task_args_t));
   12025:	8b 45 08             	mov    0x8(%ebp),%eax
   12028:	83 c0 0c             	add    $0xc,%eax
   1202b:	89 45 dc             	mov    %eax,-0x24(%ebp)

    // 复制各项参数, 跳过task_args和参数表
    // 各argv参数写入的内存空间
    char * dest_arg = to + sizeof(task_args_t) + sizeof(char *) * (argc + 1);   // 留出结束符
   1202e:	8b 45 10             	mov    0x10(%ebp),%eax
   12031:	83 c0 04             	add    $0x4,%eax
   12034:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1203b:	8b 45 08             	mov    0x8(%ebp),%eax
   1203e:	01 d0                	add    %edx,%eax
   12040:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    // argv表
    char ** dest_argv_tb = (char **)memory_get_paddr(page_dir, (uint32_t)(to + sizeof(task_args_t)));
   12043:	8b 45 08             	mov    0x8(%ebp),%eax
   12046:	83 c0 0c             	add    $0xc,%eax
   12049:	83 ec 08             	sub    $0x8,%esp
   1204c:	50                   	push   %eax
   1204d:	ff 75 0c             	pushl  0xc(%ebp)
   12050:	e8 9f ee ff ff       	call   10ef4 <memory_get_paddr>
   12055:	83 c4 10             	add    $0x10,%esp
   12058:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ASSERT(dest_argv_tb != 0);

    for (int i = 0; i < argc; i++) {
   1205b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12062:	eb 60                	jmp    120c4 <copy_args+0xab>
        char * from = argv[i];
   12064:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12067:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1206e:	8b 45 14             	mov    0x14(%ebp),%eax
   12071:	01 d0                	add    %edx,%eax
   12073:	8b 00                	mov    (%eax),%eax
   12075:	89 45 e8             	mov    %eax,-0x18(%ebp)

        // 不能用kernel_strcpy，因为to和argv不在一个页表里
        int len = kernel_strlen(from) + 1;   // 包含结束符
   12078:	83 ec 0c             	sub    $0xc,%esp
   1207b:	ff 75 e8             	pushl  -0x18(%ebp)
   1207e:	e8 d8 18 00 00       	call   1395b <kernel_strlen>
   12083:	83 c4 10             	add    $0x10,%esp
   12086:	83 c0 01             	add    $0x1,%eax
   12089:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int err = memory_copy_uvm_data((uint32_t)dest_arg, page_dir, (uint32_t)from, len);
   1208c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   1208f:	8b 55 e8             	mov    -0x18(%ebp),%edx
   12092:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12095:	51                   	push   %ecx
   12096:	52                   	push   %edx
   12097:	ff 75 0c             	pushl  0xc(%ebp)
   1209a:	50                   	push   %eax
   1209b:	e8 9a ee ff ff       	call   10f3a <memory_copy_uvm_data>
   120a0:	83 c4 10             	add    $0x10,%esp
   120a3:	89 45 e0             	mov    %eax,-0x20(%ebp)
        ASSERT(err >= 0);

        // 关联ar
        dest_argv_tb[i] = dest_arg;
   120a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   120a9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   120b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   120b3:	01 c2                	add    %eax,%edx
   120b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   120b8:	89 02                	mov    %eax,(%edx)

        // 记录下位置后，复制的位置前移
        dest_arg += len;
   120ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   120bd:	01 45 f4             	add    %eax,-0xc(%ebp)
    for (int i = 0; i < argc; i++) {
   120c0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   120c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   120c7:	3b 45 10             	cmp    0x10(%ebp),%eax
   120ca:	7c 98                	jl     12064 <copy_args+0x4b>
    }

    // 可能存在无参的情况，此时不需要写入
    if (argc) {
   120cc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   120d0:	74 15                	je     120e7 <copy_args+0xce>
        dest_argv_tb[argc] = '\0';
   120d2:	8b 45 10             	mov    0x10(%ebp),%eax
   120d5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   120dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   120df:	01 d0                	add    %edx,%eax
   120e1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }

     // 写入task_args
    return memory_copy_uvm_data((uint32_t)to, page_dir, (uint32_t)&task_args, sizeof(task_args_t));
   120e7:	8d 55 d4             	lea    -0x2c(%ebp),%edx
   120ea:	8b 45 08             	mov    0x8(%ebp),%eax
   120ed:	6a 0c                	push   $0xc
   120ef:	52                   	push   %edx
   120f0:	ff 75 0c             	pushl  0xc(%ebp)
   120f3:	50                   	push   %eax
   120f4:	e8 41 ee ff ff       	call   10f3a <memory_copy_uvm_data>
   120f9:	83 c4 10             	add    $0x10,%esp
}
   120fc:	c9                   	leave  
   120fd:	c3                   	ret    

000120fe <sys_execve>:
int sys_execve(char *name,char **argv,char **env)
{
   120fe:	55                   	push   %ebp
   120ff:	89 e5                	mov    %esp,%ebp
   12101:	83 ec 28             	sub    $0x28,%esp
    task_t * task = task_current();
   12104:	e8 c5 f5 ff ff       	call   116ce <task_current>
   12109:	89 45 f4             	mov    %eax,-0xc(%ebp)

    kernel_strncpy(task->name,get_file_name(name),TASK_NAME_SIZE);
   1210c:	83 ec 0c             	sub    $0xc,%esp
   1210f:	ff 75 08             	pushl  0x8(%ebp)
   12112:	e8 9b 1c 00 00       	call   13db2 <get_file_name>
   12117:	83 c4 10             	add    $0x10,%esp
   1211a:	89 c2                	mov    %eax,%edx
   1211c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1211f:	83 c0 20             	add    $0x20,%eax
   12122:	83 ec 04             	sub    $0x4,%esp
   12125:	6a 20                	push   $0x20
   12127:	52                   	push   %edx
   12128:	50                   	push   %eax
   12129:	e8 49 17 00 00       	call   13877 <kernel_strncpy>
   1212e:	83 c4 10             	add    $0x10,%esp
    uint32_t old_page_dir = task->tss.cr3;
   12131:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12134:	8b 40 78             	mov    0x78(%eax),%eax
   12137:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t new_page_dir = memory_create_user_space();
   1213a:	e8 b3 e8 ff ff       	call   109f2 <memory_create_user_space>
   1213f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(new_page_dir == 0)
   12142:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   12146:	0f 84 5a 01 00 00    	je     122a6 <sys_execve+0x1a8>
    {
        goto execve_failed;
    }
    uint32_t entry = load_elf_file(task,name,new_page_dir);
   1214c:	83 ec 04             	sub    $0x4,%esp
   1214f:	ff 75 ec             	pushl  -0x14(%ebp)
   12152:	ff 75 08             	pushl  0x8(%ebp)
   12155:	ff 75 f4             	pushl  -0xc(%ebp)
   12158:	e8 01 fd ff ff       	call   11e5e <load_elf_file>
   1215d:	83 c4 10             	add    $0x10,%esp
   12160:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(entry == 0)
   12163:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   12167:	0f 84 3c 01 00 00    	je     122a9 <sys_execve+0x1ab>
    {
        goto execve_failed;
    }

    uint32_t stack_up = MEM_TASK_STACK_TOP - MEM_TASK_ARG_SIZE;
   1216d:	c7 45 e4 00 c0 ff df 	movl   $0xdfffc000,-0x1c(%ebp)
    int err = memory_alloc_for_page_dir(new_page_dir,MEM_TASK_STACK_TOP - MEM_TASK_STACK_SIZE,MEM_TASK_STACK_SIZE,PTE_P | PTE_W | PTE_U);
   12174:	6a 07                	push   $0x7
   12176:	68 00 40 06 00       	push   $0x64000
   1217b:	68 00 c0 f9 df       	push   $0xdff9c000
   12180:	ff 75 ec             	pushl  -0x14(%ebp)
   12183:	e8 1a ea ff ff       	call   10ba2 <memory_alloc_for_page_dir>
   12188:	83 c4 10             	add    $0x10,%esp
   1218b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(err < 0)
   1218e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   12192:	0f 88 14 01 00 00    	js     122ac <sys_execve+0x1ae>
    {
        goto execve_failed;
    }
    
    int argc = strings_count(argv);
   12198:	83 ec 0c             	sub    $0xc,%esp
   1219b:	ff 75 0c             	pushl  0xc(%ebp)
   1219e:	e8 e2 1b 00 00       	call   13d85 <strings_count>
   121a3:	83 c4 10             	add    $0x10,%esp
   121a6:	89 45 dc             	mov    %eax,-0x24(%ebp)
    err = copy_args((char *)stack_up,new_page_dir,argc,argv);
   121a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   121ac:	ff 75 0c             	pushl  0xc(%ebp)
   121af:	ff 75 dc             	pushl  -0x24(%ebp)
   121b2:	ff 75 ec             	pushl  -0x14(%ebp)
   121b5:	50                   	push   %eax
   121b6:	e8 5e fe ff ff       	call   12019 <copy_args>
   121bb:	83 c4 10             	add    $0x10,%esp
   121be:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(err < 0)
   121c1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   121c5:	0f 88 e4 00 00 00    	js     122af <sys_execve+0x1b1>
    {
        goto execve_failed;        
    }
    syscall_frame_t * frame = (syscall_frame_t *)(task_manager.global_tss.esp0 - sizeof(syscall_frame_t));
   121cb:	a1 e0 81 01 00       	mov    0x181e0,%eax
   121d0:	83 e8 58             	sub    $0x58,%eax
   121d3:	89 45 d8             	mov    %eax,-0x28(%ebp)
    frame->eip = entry;
   121d6:	8b 55 e8             	mov    -0x18(%ebp),%edx
   121d9:	8b 45 d8             	mov    -0x28(%ebp),%eax
   121dc:	89 50 34             	mov    %edx,0x34(%eax)
    frame->eax = frame->ebx = frame->ecx = frame->edx = frame->esi = frame->edi = frame->ebp = 0;
   121df:	8b 45 d8             	mov    -0x28(%ebp),%eax
   121e2:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
   121e9:	8b 45 d8             	mov    -0x28(%ebp),%eax
   121ec:	8b 50 1c             	mov    0x1c(%eax),%edx
   121ef:	8b 45 d8             	mov    -0x28(%ebp),%eax
   121f2:	89 50 14             	mov    %edx,0x14(%eax)
   121f5:	8b 45 d8             	mov    -0x28(%ebp),%eax
   121f8:	8b 50 14             	mov    0x14(%eax),%edx
   121fb:	8b 45 d8             	mov    -0x28(%ebp),%eax
   121fe:	89 50 18             	mov    %edx,0x18(%eax)
   12201:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12204:	8b 50 18             	mov    0x18(%eax),%edx
   12207:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1220a:	89 50 28             	mov    %edx,0x28(%eax)
   1220d:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12210:	8b 50 28             	mov    0x28(%eax),%edx
   12213:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12216:	89 50 2c             	mov    %edx,0x2c(%eax)
   12219:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1221c:	8b 50 2c             	mov    0x2c(%eax),%edx
   1221f:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12222:	89 50 24             	mov    %edx,0x24(%eax)
   12225:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12228:	8b 50 24             	mov    0x24(%eax),%edx
   1222b:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1222e:	89 50 30             	mov    %edx,0x30(%eax)
    frame->eflags = EFLAGS_DEFAULT | EFLAGS_IF;
   12231:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12234:	c7 00 02 02 00 00    	movl   $0x202,(%eax)
    frame->esp = stack_up - sizeof(uint32_t) * SYSCALL_PARAM_COUNT;
   1223a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1223d:	83 e8 14             	sub    $0x14,%eax
   12240:	89 c2                	mov    %eax,%edx
   12242:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12245:	89 50 50             	mov    %edx,0x50(%eax)
    frame->cs = USER_SELECTOR_CS;
   12248:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1224b:	c7 40 38 1b 00 00 00 	movl   $0x1b,0x38(%eax)
    frame->ds = USER_SELECTOR_DS;
   12252:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12255:	c7 40 10 23 00 00 00 	movl   $0x23,0x10(%eax)
    frame->es = USER_SELECTOR_DS;
   1225c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1225f:	c7 40 0c 23 00 00 00 	movl   $0x23,0xc(%eax)
    frame->fs = USER_SELECTOR_DS;
   12266:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12269:	c7 40 08 23 00 00 00 	movl   $0x23,0x8(%eax)
    frame->gs = USER_SELECTOR_DS;
   12270:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12273:	c7 40 04 23 00 00 00 	movl   $0x23,0x4(%eax)


    task->tss.cr3 = new_page_dir;
   1227a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1227d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   12280:	89 50 78             	mov    %edx,0x78(%eax)
    mmu_set_page_dir(new_page_dir);
   12283:	83 ec 0c             	sub    $0xc,%esp
   12286:	ff 75 ec             	pushl  -0x14(%ebp)
   12289:	e8 54 ee ff ff       	call   110e2 <mmu_set_page_dir>
   1228e:	83 c4 10             	add    $0x10,%esp
    memory_destroy_uvm(old_page_dir);
   12291:	83 ec 0c             	sub    $0xc,%esp
   12294:	ff 75 f0             	pushl  -0x10(%ebp)
   12297:	e8 71 eb ff ff       	call   10e0d <memory_destroy_uvm>
   1229c:	83 c4 10             	add    $0x10,%esp
    return 0;
   1229f:	b8 00 00 00 00       	mov    $0x0,%eax
   122a4:	eb 3a                	jmp    122e0 <sys_execve+0x1e2>
        goto execve_failed;
   122a6:	90                   	nop
   122a7:	eb 07                	jmp    122b0 <sys_execve+0x1b2>
        goto execve_failed;
   122a9:	90                   	nop
   122aa:	eb 04                	jmp    122b0 <sys_execve+0x1b2>
        goto execve_failed;
   122ac:	90                   	nop
   122ad:	eb 01                	jmp    122b0 <sys_execve+0x1b2>
        goto execve_failed;        
   122af:	90                   	nop
execve_failed:

    if(new_page_dir != 0)
   122b0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   122b4:	74 25                	je     122db <sys_execve+0x1dd>
    {
        task->tss.cr3 = old_page_dir;
   122b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   122b9:	8b 55 f0             	mov    -0x10(%ebp),%edx
   122bc:	89 50 78             	mov    %edx,0x78(%eax)
        mmu_set_page_dir(old_page_dir);
   122bf:	83 ec 0c             	sub    $0xc,%esp
   122c2:	ff 75 f0             	pushl  -0x10(%ebp)
   122c5:	e8 18 ee ff ff       	call   110e2 <mmu_set_page_dir>
   122ca:	83 c4 10             	add    $0x10,%esp
        memory_destroy_uvm(new_page_dir);
   122cd:	83 ec 0c             	sub    $0xc,%esp
   122d0:	ff 75 ec             	pushl  -0x14(%ebp)
   122d3:	e8 35 eb ff ff       	call   10e0d <memory_destroy_uvm>
   122d8:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   122db:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   122e0:	c9                   	leave  
   122e1:	c3                   	ret    

000122e2 <lgdt>:
{
   122e2:	55                   	push   %ebp
   122e3:	89 e5                	mov    %esp,%ebp
   122e5:	83 ec 10             	sub    $0x10,%esp
    gdt.start31_16 = start >> 16;
   122e8:	8b 45 08             	mov    0x8(%ebp),%eax
   122eb:	c1 e8 10             	shr    $0x10,%eax
   122ee:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    gdt.start15_0 = start & 0xffff;
   122f2:	8b 45 08             	mov    0x8(%ebp),%eax
   122f5:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    gdt.limit = size - 1;
   122f9:	8b 45 0c             	mov    0xc(%ebp),%eax
   122fc:	83 e8 01             	sub    $0x1,%eax
   122ff:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__("lgdt %[g]"::[g]"m"(gdt));
   12303:	0f 01 55 fa          	lgdtl  -0x6(%ebp)
}
   12307:	90                   	nop
   12308:	c9                   	leave  
   12309:	c3                   	ret    

0001230a <far_jump>:
{
   1230a:	55                   	push   %ebp
   1230b:	89 e5                	mov    %esp,%ebp
   1230d:	83 ec 10             	sub    $0x10,%esp
    uint32_t addr[] = {offset ,selector};
   12310:	8b 45 0c             	mov    0xc(%ebp),%eax
   12313:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12316:	8b 45 08             	mov    0x8(%ebp),%eax
   12319:	89 45 fc             	mov    %eax,-0x4(%ebp)
    __asm__ __volatile__("ljmpl *(%[a])"::[a]"r"(addr));
   1231c:	8d 45 f8             	lea    -0x8(%ebp),%eax
   1231f:	ff 28                	ljmp   *(%eax)
}
   12321:	90                   	nop
   12322:	c9                   	leave  
   12323:	c3                   	ret    

00012324 <show_base>:
#include "core/syscall.h"
static segment_desc_t gdt_table[GDT_TABLE_SIZE];
static mutex_t gdt_mutex;

void show_base (int index)
{
   12324:	55                   	push   %ebp
   12325:	89 e5                	mov    %esp,%ebp
   12327:	83 ec 18             	sub    $0x18,%esp
    segment_desc_t *desc = &gdt_table[index];  
   1232a:	8b 45 08             	mov    0x8(%ebp),%eax
   1232d:	c1 e0 03             	shl    $0x3,%eax
   12330:	05 80 04 02 00       	add    $0x20480,%eax
   12335:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t base = desc->base15_0 | (desc->base23_16 << 16) | (desc->base31_24 << 24);
   12338:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1233b:	0f b7 40 02          	movzwl 0x2(%eax),%eax
   1233f:	0f b7 d0             	movzwl %ax,%edx
   12342:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12345:	0f b6 40 04          	movzbl 0x4(%eax),%eax
   12349:	0f b6 c0             	movzbl %al,%eax
   1234c:	c1 e0 10             	shl    $0x10,%eax
   1234f:	09 c2                	or     %eax,%edx
   12351:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12354:	0f b6 40 07          	movzbl 0x7(%eax),%eax
   12358:	0f b6 c0             	movzbl %al,%eax
   1235b:	c1 e0 18             	shl    $0x18,%eax
   1235e:	09 d0                	or     %edx,%eax
   12360:	89 45 f0             	mov    %eax,-0x10(%ebp)
    log_printf("GDT[%d] base=%x\n", index, base);
   12363:	83 ec 04             	sub    $0x4,%esp
   12366:	ff 75 f0             	pushl  -0x10(%ebp)
   12369:	ff 75 08             	pushl  0x8(%ebp)
   1236c:	68 b6 44 01 00       	push   $0x144b6
   12371:	e8 51 1d 00 00       	call   140c7 <log_printf>
   12376:	83 c4 10             	add    $0x10,%esp
}
   12379:	90                   	nop
   1237a:	c9                   	leave  
   1237b:	c3                   	ret    

0001237c <segment_desc_set>:
void segment_desc_set(int selector, uint32_t base, uint32_t limit, uint16_t attr)
{
   1237c:	55                   	push   %ebp
   1237d:	89 e5                	mov    %esp,%ebp
   1237f:	83 ec 14             	sub    $0x14,%esp
   12382:	8b 45 14             	mov    0x14(%ebp),%eax
   12385:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    segment_desc_t *desc = gdt_table + selector / sizeof(segment_desc_t);
   12389:	8b 45 08             	mov    0x8(%ebp),%eax
   1238c:	83 e0 f8             	and    $0xfffffff8,%eax
   1238f:	05 80 04 02 00       	add    $0x20480,%eax
   12394:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(limit > 0xfffff)
   12397:	81 7d 10 ff ff 0f 00 	cmpl   $0xfffff,0x10(%ebp)
   1239e:	76 0f                	jbe    123af <segment_desc_set+0x33>
    {
        limit /= 0x1000;
   123a0:	8b 45 10             	mov    0x10(%ebp),%eax
   123a3:	c1 e8 0c             	shr    $0xc,%eax
   123a6:	89 45 10             	mov    %eax,0x10(%ebp)
        attr |= SEG_G;
   123a9:	66 81 4d ec 00 80    	orw    $0x8000,-0x14(%ebp)
    }
    desc->limit15_0 = limit & 0xffff;
   123af:	8b 45 10             	mov    0x10(%ebp),%eax
   123b2:	89 c2                	mov    %eax,%edx
   123b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123b7:	66 89 10             	mov    %dx,(%eax)
    desc->base15_0 = base & 0xffff;
   123ba:	8b 45 0c             	mov    0xc(%ebp),%eax
   123bd:	89 c2                	mov    %eax,%edx
   123bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123c2:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->base23_16 = (base >> 16) & 0xff;
   123c6:	8b 45 0c             	mov    0xc(%ebp),%eax
   123c9:	c1 e8 10             	shr    $0x10,%eax
   123cc:	89 c2                	mov    %eax,%edx
   123ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123d1:	88 50 04             	mov    %dl,0x4(%eax)
    desc->attr = attr | (((limit >> 16) & 0x0f) << 8);
   123d4:	8b 45 10             	mov    0x10(%ebp),%eax
   123d7:	c1 e8 10             	shr    $0x10,%eax
   123da:	c1 e0 08             	shl    $0x8,%eax
   123dd:	66 25 00 0f          	and    $0xf00,%ax
   123e1:	66 0b 45 ec          	or     -0x14(%ebp),%ax
   123e5:	89 c2                	mov    %eax,%edx
   123e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123ea:	66 89 50 05          	mov    %dx,0x5(%eax)
    desc->base31_24 = (base >> 24) & 0xff;
   123ee:	8b 45 0c             	mov    0xc(%ebp),%eax
   123f1:	c1 e8 18             	shr    $0x18,%eax
   123f4:	89 c2                	mov    %eax,%edx
   123f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123f9:	88 50 07             	mov    %dl,0x7(%eax)
}
   123fc:	90                   	nop
   123fd:	c9                   	leave  
   123fe:	c3                   	ret    

000123ff <gate_desc_set>:
void gate_desc_set(gate_desc_t * gate_desc, uint16_t selector, uint32_t offset, uint16_t attr)
{
   123ff:	55                   	push   %ebp
   12400:	89 e5                	mov    %esp,%ebp
   12402:	83 ec 08             	sub    $0x8,%esp
   12405:	8b 55 0c             	mov    0xc(%ebp),%edx
   12408:	8b 45 14             	mov    0x14(%ebp),%eax
   1240b:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   1240f:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    gate_desc->selector = selector;
   12413:	8b 45 08             	mov    0x8(%ebp),%eax
   12416:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   1241a:	66 89 50 02          	mov    %dx,0x2(%eax)
    gate_desc->offset15_0 = offset & 0xffff;
   1241e:	8b 45 10             	mov    0x10(%ebp),%eax
   12421:	89 c2                	mov    %eax,%edx
   12423:	8b 45 08             	mov    0x8(%ebp),%eax
   12426:	66 89 10             	mov    %dx,(%eax)
    gate_desc->offset31_16 = (offset >> 16) & 0xffff;
   12429:	8b 45 10             	mov    0x10(%ebp),%eax
   1242c:	c1 e8 10             	shr    $0x10,%eax
   1242f:	89 c2                	mov    %eax,%edx
   12431:	8b 45 08             	mov    0x8(%ebp),%eax
   12434:	66 89 50 06          	mov    %dx,0x6(%eax)
    gate_desc->attr = attr;
   12438:	8b 45 08             	mov    0x8(%ebp),%eax
   1243b:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
   1243f:	66 89 50 04          	mov    %dx,0x4(%eax)
}
   12443:	90                   	nop
   12444:	c9                   	leave  
   12445:	c3                   	ret    

00012446 <gdt_alloc_desc>:

int gdt_alloc_desc(void)
{
   12446:	55                   	push   %ebp
   12447:	89 e5                	mov    %esp,%ebp
   12449:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   1244c:	e8 cb 0a 00 00       	call   12f1c <irq_enter_protection>
   12451:	89 45 f0             	mov    %eax,-0x10(%ebp)
    //mutex_lock(&gdt_mutex);
    for (int i = 1; i < GDT_TABLE_SIZE; i++)
   12454:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   1245b:	eb 2a                	jmp    12487 <gdt_alloc_desc+0x41>
    {
        if(gdt_table[i].attr == 0)
   1245d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12460:	0f b7 04 c5 85 04 02 	movzwl 0x20485(,%eax,8),%eax
   12467:	00 
   12468:	66 85 c0             	test   %ax,%ax
   1246b:	75 16                	jne    12483 <gdt_alloc_desc+0x3d>
        {
            //mutex_unlock(&gdt_mutex);
            irq_leave_protection(state);
   1246d:	83 ec 0c             	sub    $0xc,%esp
   12470:	ff 75 f0             	pushl  -0x10(%ebp)
   12473:	e8 bc 0a 00 00       	call   12f34 <irq_leave_protection>
   12478:	83 c4 10             	add    $0x10,%esp
            return i * sizeof(segment_desc_t);
   1247b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1247e:	c1 e0 03             	shl    $0x3,%eax
   12481:	eb 20                	jmp    124a3 <gdt_alloc_desc+0x5d>
    for (int i = 1; i < GDT_TABLE_SIZE; i++)
   12483:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12487:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   1248e:	7e cd                	jle    1245d <gdt_alloc_desc+0x17>
        }
        
    }
    //mutex_unlock(&gdt_mutex);
    irq_leave_protection(state);
   12490:	83 ec 0c             	sub    $0xc,%esp
   12493:	ff 75 f0             	pushl  -0x10(%ebp)
   12496:	e8 99 0a 00 00       	call   12f34 <irq_leave_protection>
   1249b:	83 c4 10             	add    $0x10,%esp
    return -1;
   1249e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   124a3:	c9                   	leave  
   124a4:	c3                   	ret    

000124a5 <gdt_free_desc>:

void gdt_free_desc(int selector)
{
   124a5:	55                   	push   %ebp
   124a6:	89 e5                	mov    %esp,%ebp
   124a8:	83 ec 18             	sub    $0x18,%esp
    //mutex_lock(&gdt_mutex);
    irq_state_t state = irq_enter_protection();
   124ab:	e8 6c 0a 00 00       	call   12f1c <irq_enter_protection>
   124b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    gdt_table[selector / sizeof(segment_desc_t)].attr = 0;
   124b3:	8b 45 08             	mov    0x8(%ebp),%eax
   124b6:	c1 e8 03             	shr    $0x3,%eax
   124b9:	66 c7 04 c5 85 04 02 	movw   $0x0,0x20485(,%eax,8)
   124c0:	00 00 00 
    //mutex_unlock(&gdt_mutex);
    irq_leave_protection(state);
   124c3:	83 ec 0c             	sub    $0xc,%esp
   124c6:	ff 75 f4             	pushl  -0xc(%ebp)
   124c9:	e8 66 0a 00 00       	call   12f34 <irq_leave_protection>
   124ce:	83 c4 10             	add    $0x10,%esp
}
   124d1:	90                   	nop
   124d2:	c9                   	leave  
   124d3:	c3                   	ret    

000124d4 <init_gdt>:
void init_gdt(void)
{
   124d4:	55                   	push   %ebp
   124d5:	89 e5                	mov    %esp,%ebp
   124d7:	83 ec 10             	sub    $0x10,%esp
    for (int i = 0; i < GDT_TABLE_SIZE; i++)
   124da:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   124e1:	eb 19                	jmp    124fc <init_gdt+0x28>
    {
        segment_desc_set(i * sizeof(segment_desc_t), 0, 0, 0);
   124e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   124e6:	c1 e0 03             	shl    $0x3,%eax
   124e9:	6a 00                	push   $0x0
   124eb:	6a 00                	push   $0x0
   124ed:	6a 00                	push   $0x0
   124ef:	50                   	push   %eax
   124f0:	e8 87 fe ff ff       	call   1237c <segment_desc_set>
   124f5:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < GDT_TABLE_SIZE; i++)
   124f8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   124fc:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
   12503:	7e de                	jle    124e3 <init_gdt+0xf>
    }

    segment_desc_set(KERNEL_SELECTOR_CS, 0, 0xffffffff, SEG_P_PRESENT | SEG_DPL_0 | SEG_S_NORMAL | SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D);
   12505:	68 9a 40 00 00       	push   $0x409a
   1250a:	6a ff                	push   $0xffffffff
   1250c:	6a 00                	push   $0x0
   1250e:	6a 08                	push   $0x8
   12510:	e8 67 fe ff ff       	call   1237c <segment_desc_set>
   12515:	83 c4 10             	add    $0x10,%esp
    segment_desc_set(KERNEL_SELECTOR_DS, 0, 0xffffffff, SEG_P_PRESENT | SEG_DPL_0 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D);
   12518:	68 92 40 00 00       	push   $0x4092
   1251d:	6a ff                	push   $0xffffffff
   1251f:	6a 00                	push   $0x0
   12521:	6a 10                	push   $0x10
   12523:	e8 54 fe ff ff       	call   1237c <segment_desc_set>
   12528:	83 c4 10             	add    $0x10,%esp

    gate_desc_set((gate_desc_t *)(gdt_table + (SELECTOR_SYSCALL >> 3)),KERNEL_SELECTOR_CS,
   1252b:	ba da 05 01 00       	mov    $0x105da,%edx
   12530:	b8 a8 04 02 00       	mov    $0x204a8,%eax
   12535:	68 05 ec 00 00       	push   $0xec05
   1253a:	52                   	push   %edx
   1253b:	6a 08                	push   $0x8
   1253d:	50                   	push   %eax
   1253e:	e8 bc fe ff ff       	call   123ff <gate_desc_set>
   12543:	83 c4 10             	add    $0x10,%esp
    (uint32_t)exception_handler_syscall,
    GATE_P_PRESENT | GATE_DPL_3 | GATE_TYPE_SYSCALL | SYSCALL_PARAM_COUNT
    );
    lgdt((uint32_t)gdt_table, sizeof(gdt_table));
   12546:	b8 80 04 02 00       	mov    $0x20480,%eax
   1254b:	68 00 08 00 00       	push   $0x800
   12550:	50                   	push   %eax
   12551:	e8 8c fd ff ff       	call   122e2 <lgdt>
   12556:	83 c4 08             	add    $0x8,%esp
}
   12559:	90                   	nop
   1255a:	c9                   	leave  
   1255b:	c3                   	ret    

0001255c <cpu_init>:

void cpu_init(void)
{
   1255c:	55                   	push   %ebp
   1255d:	89 e5                	mov    %esp,%ebp
   1255f:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&gdt_mutex);
   12562:	83 ec 0c             	sub    $0xc,%esp
   12565:	68 80 0c 02 00       	push   $0x20c80
   1256a:	e8 cb 0d 00 00       	call   1333a <mutex_init>
   1256f:	83 c4 10             	add    $0x10,%esp
    init_gdt();
   12572:	e8 5d ff ff ff       	call   124d4 <init_gdt>
    
}
   12577:	90                   	nop
   12578:	c9                   	leave  
   12579:	c3                   	ret    

0001257a <switch_to_tss>:

void switch_to_tss (int tss_sel)
{
   1257a:	55                   	push   %ebp
   1257b:	89 e5                	mov    %esp,%ebp
    far_jump(tss_sel,0);
   1257d:	8b 45 08             	mov    0x8(%ebp),%eax
   12580:	6a 00                	push   $0x0
   12582:	50                   	push   %eax
   12583:	e8 82 fd ff ff       	call   1230a <far_jump>
   12588:	83 c4 08             	add    $0x8,%esp
   1258b:	90                   	nop
   1258c:	c9                   	leave  
   1258d:	c3                   	ret    

0001258e <inb>:
{
   1258e:	55                   	push   %ebp
   1258f:	89 e5                	mov    %esp,%ebp
   12591:	83 ec 14             	sub    $0x14,%esp
   12594:	8b 45 08             	mov    0x8(%ebp),%eax
   12597:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[p], %[v]":[v] "=a"(rv) : [p]"d"(port));
   1259b:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   1259f:	89 c2                	mov    %eax,%edx
   125a1:	ec                   	in     (%dx),%al
   125a2:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   125a5:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   125a9:	c9                   	leave  
   125aa:	c3                   	ret    

000125ab <outb>:
{
   125ab:	55                   	push   %ebp
   125ac:	89 e5                	mov    %esp,%ebp
   125ae:	83 ec 08             	sub    $0x8,%esp
   125b1:	8b 55 08             	mov    0x8(%ebp),%edx
   125b4:	8b 45 0c             	mov    0xc(%ebp),%eax
   125b7:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   125bb:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]"::[p]"d"(port),[v]"a"(data));
   125be:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   125c2:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   125c6:	ee                   	out    %al,(%dx)
}
   125c7:	90                   	nop
   125c8:	c9                   	leave  
   125c9:	c3                   	ret    

000125ca <cli>:
{
   125ca:	55                   	push   %ebp
   125cb:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile("cli");
   125cd:	fa                   	cli    
}
   125ce:	90                   	nop
   125cf:	5d                   	pop    %ebp
   125d0:	c3                   	ret    

000125d1 <sti>:
{
   125d1:	55                   	push   %ebp
   125d2:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile("sti");
   125d4:	fb                   	sti    
}
   125d5:	90                   	nop
   125d6:	5d                   	pop    %ebp
   125d7:	c3                   	ret    

000125d8 <lidt>:
{
   125d8:	55                   	push   %ebp
   125d9:	89 e5                	mov    %esp,%ebp
   125db:	83 ec 10             	sub    $0x10,%esp
    idt.start31_16 = start >> 16;
   125de:	8b 45 08             	mov    0x8(%ebp),%eax
   125e1:	c1 e8 10             	shr    $0x10,%eax
   125e4:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    idt.start15_0 = start & 0xffff;
   125e8:	8b 45 08             	mov    0x8(%ebp),%eax
   125eb:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    idt.limit = size - 1;
   125ef:	8b 45 0c             	mov    0xc(%ebp),%eax
   125f2:	83 e8 01             	sub    $0x1,%eax
   125f5:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__("lidt %[i]"::[i]"m"(idt));
   125f9:	0f 01 5d fa          	lidtl  -0x6(%ebp)
}
   125fd:	90                   	nop
   125fe:	c9                   	leave  
   125ff:	c3                   	ret    

00012600 <read_cr2>:
{
   12600:	55                   	push   %ebp
   12601:	89 e5                	mov    %esp,%ebp
   12603:	83 ec 10             	sub    $0x10,%esp
    __asm__ __volatile__("mov %%cr2, %[v]":[v]"=r"(cr2));
   12606:	0f 20 d0             	mov    %cr2,%eax
   12609:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return cr2;
   1260c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1260f:	c9                   	leave  
   12610:	c3                   	ret    

00012611 <hlt>:
{
   12611:	55                   	push   %ebp
   12612:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   12614:	f4                   	hlt    
}
   12615:	90                   	nop
   12616:	5d                   	pop    %ebp
   12617:	c3                   	ret    

00012618 <read_eflags>:

static inline uint32_t read_eflags(void)
{
   12618:	55                   	push   %ebp
   12619:	89 e5                	mov    %esp,%ebp
   1261b:	83 ec 10             	sub    $0x10,%esp
    uint32_t eflags;
    __asm__ __volatile__("pushf\n\tpop %%eax":"=a"(eflags));
   1261e:	9c                   	pushf  
   1261f:	58                   	pop    %eax
   12620:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return eflags;
   12623:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   12626:	c9                   	leave  
   12627:	c3                   	ret    

00012628 <write_eflags>:

static inline void write_eflags(uint32_t eflags)
{
   12628:	55                   	push   %ebp
   12629:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("push %%eax\n\tpopf"::"a"(eflags));
   1262b:	8b 45 08             	mov    0x8(%ebp),%eax
   1262e:	50                   	push   %eax
   1262f:	9d                   	popf   
}
   12630:	90                   	nop
   12631:	5d                   	pop    %ebp
   12632:	c3                   	ret    

00012633 <dump_core_regs>:
#include "os_cfg.h"
#include "tools/log.h"
#define IRQ_TABLE_NU 128
static gate_desc_t idt_table[IRQ_TABLE_NU];
static dump_core_regs(exception_frame_t *frame)
{
   12633:	55                   	push   %ebp
   12634:	89 e5                	mov    %esp,%ebp
   12636:	56                   	push   %esi
   12637:	53                   	push   %ebx
   12638:	83 ec 10             	sub    $0x10,%esp
    uint32_t ss,esp;
    if(frame->cs & 0x3)
   1263b:	8b 45 08             	mov    0x8(%ebp),%eax
   1263e:	8b 40 3c             	mov    0x3c(%eax),%eax
   12641:	83 e0 03             	and    $0x3,%eax
   12644:	85 c0                	test   %eax,%eax
   12646:	74 14                	je     1265c <dump_core_regs+0x29>
    {
        ss = frame->ss3;
   12648:	8b 45 08             	mov    0x8(%ebp),%eax
   1264b:	8b 40 48             	mov    0x48(%eax),%eax
   1264e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        esp = frame->esp3;
   12651:	8b 45 08             	mov    0x8(%ebp),%eax
   12654:	8b 40 44             	mov    0x44(%eax),%eax
   12657:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1265a:	eb 12                	jmp    1266e <dump_core_regs+0x3b>
    }
    else
    {
        ss = frame->ds;
   1265c:	8b 45 08             	mov    0x8(%ebp),%eax
   1265f:	8b 40 0c             	mov    0xc(%eax),%eax
   12662:	89 45 f4             	mov    %eax,-0xc(%ebp)
        esp = frame->esp;
   12665:	8b 45 08             	mov    0x8(%ebp),%eax
   12668:	8b 40 1c             	mov    0x1c(%eax),%eax
   1266b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    log_printf("IRQ: %d, error code: %d\n",frame->irq_num,frame->error_code);
   1266e:	8b 45 08             	mov    0x8(%ebp),%eax
   12671:	8b 50 34             	mov    0x34(%eax),%edx
   12674:	8b 45 08             	mov    0x8(%ebp),%eax
   12677:	8b 40 30             	mov    0x30(%eax),%eax
   1267a:	83 ec 04             	sub    $0x4,%esp
   1267d:	52                   	push   %edx
   1267e:	50                   	push   %eax
   1267f:	68 c8 44 01 00       	push   $0x144c8
   12684:	e8 3e 1a 00 00       	call   140c7 <log_printf>
   12689:	83 c4 10             	add    $0x10,%esp
    log_printf("CS: %x DS: %x ES: %x SS: %x FS: %x GS: %x\n",frame->cs,frame->ds,frame->es,ss,frame->fs,frame->gs);
   1268c:	8b 45 08             	mov    0x8(%ebp),%eax
   1268f:	8b 30                	mov    (%eax),%esi
   12691:	8b 45 08             	mov    0x8(%ebp),%eax
   12694:	8b 58 04             	mov    0x4(%eax),%ebx
   12697:	8b 45 08             	mov    0x8(%ebp),%eax
   1269a:	8b 48 08             	mov    0x8(%eax),%ecx
   1269d:	8b 45 08             	mov    0x8(%ebp),%eax
   126a0:	8b 50 0c             	mov    0xc(%eax),%edx
   126a3:	8b 45 08             	mov    0x8(%ebp),%eax
   126a6:	8b 40 3c             	mov    0x3c(%eax),%eax
   126a9:	83 ec 04             	sub    $0x4,%esp
   126ac:	56                   	push   %esi
   126ad:	53                   	push   %ebx
   126ae:	ff 75 f4             	pushl  -0xc(%ebp)
   126b1:	51                   	push   %ecx
   126b2:	52                   	push   %edx
   126b3:	50                   	push   %eax
   126b4:	68 e4 44 01 00       	push   $0x144e4
   126b9:	e8 09 1a 00 00       	call   140c7 <log_printf>
   126be:	83 c4 20             	add    $0x20,%esp
    log_printf("EAX: 0x%x EBX: 0x%x ECX: 0x%x EDX: 0x%x\n",frame->eax,frame->ebx,frame->ecx,frame->edx);
   126c1:	8b 45 08             	mov    0x8(%ebp),%eax
   126c4:	8b 58 24             	mov    0x24(%eax),%ebx
   126c7:	8b 45 08             	mov    0x8(%ebp),%eax
   126ca:	8b 48 28             	mov    0x28(%eax),%ecx
   126cd:	8b 45 08             	mov    0x8(%ebp),%eax
   126d0:	8b 50 20             	mov    0x20(%eax),%edx
   126d3:	8b 45 08             	mov    0x8(%ebp),%eax
   126d6:	8b 40 2c             	mov    0x2c(%eax),%eax
   126d9:	83 ec 0c             	sub    $0xc,%esp
   126dc:	53                   	push   %ebx
   126dd:	51                   	push   %ecx
   126de:	52                   	push   %edx
   126df:	50                   	push   %eax
   126e0:	68 10 45 01 00       	push   $0x14510
   126e5:	e8 dd 19 00 00       	call   140c7 <log_printf>
   126ea:	83 c4 20             	add    $0x20,%esp
    log_printf("EIP: 0x%x EFLAGS: 0x%x ESP: 0x%x EBP: 0x%x\n",frame->eip,frame->eflags,esp,frame->ebp);
   126ed:	8b 45 08             	mov    0x8(%ebp),%eax
   126f0:	8b 48 18             	mov    0x18(%eax),%ecx
   126f3:	8b 45 08             	mov    0x8(%ebp),%eax
   126f6:	8b 50 40             	mov    0x40(%eax),%edx
   126f9:	8b 45 08             	mov    0x8(%ebp),%eax
   126fc:	8b 40 38             	mov    0x38(%eax),%eax
   126ff:	83 ec 0c             	sub    $0xc,%esp
   12702:	51                   	push   %ecx
   12703:	ff 75 f0             	pushl  -0x10(%ebp)
   12706:	52                   	push   %edx
   12707:	50                   	push   %eax
   12708:	68 3c 45 01 00       	push   $0x1453c
   1270d:	e8 b5 19 00 00       	call   140c7 <log_printf>
   12712:	83 c4 20             	add    $0x20,%esp
    log_printf("EDI: 0x%x ESI: 0x%x EDI: 0x%x\n",frame->edi,frame->esi,frame->edi);
   12715:	8b 45 08             	mov    0x8(%ebp),%eax
   12718:	8b 48 10             	mov    0x10(%eax),%ecx
   1271b:	8b 45 08             	mov    0x8(%ebp),%eax
   1271e:	8b 50 14             	mov    0x14(%eax),%edx
   12721:	8b 45 08             	mov    0x8(%ebp),%eax
   12724:	8b 40 10             	mov    0x10(%eax),%eax
   12727:	51                   	push   %ecx
   12728:	52                   	push   %edx
   12729:	50                   	push   %eax
   1272a:	68 68 45 01 00       	push   $0x14568
   1272f:	e8 93 19 00 00       	call   140c7 <log_printf>
   12734:	83 c4 10             	add    $0x10,%esp
}
   12737:	90                   	nop
   12738:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1273b:	5b                   	pop    %ebx
   1273c:	5e                   	pop    %esi
   1273d:	5d                   	pop    %ebp
   1273e:	c3                   	ret    

0001273f <do_default_handler>:
static void do_default_handler(exception_frame_t *frame,const char *message)
{
   1273f:	55                   	push   %ebp
   12740:	89 e5                	mov    %esp,%ebp
   12742:	83 ec 08             	sub    $0x8,%esp
    log_printf("---------------------\n");
   12745:	83 ec 0c             	sub    $0xc,%esp
   12748:	68 87 45 01 00       	push   $0x14587
   1274d:	e8 75 19 00 00       	call   140c7 <log_printf>
   12752:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: %s\n",message);
   12755:	83 ec 08             	sub    $0x8,%esp
   12758:	ff 75 0c             	pushl  0xc(%ebp)
   1275b:	68 9e 45 01 00       	push   $0x1459e
   12760:	e8 62 19 00 00       	call   140c7 <log_printf>
   12765:	83 c4 10             	add    $0x10,%esp

    dump_core_regs(frame);
   12768:	83 ec 0c             	sub    $0xc,%esp
   1276b:	ff 75 08             	pushl  0x8(%ebp)
   1276e:	e8 c0 fe ff ff       	call   12633 <dump_core_regs>
   12773:	83 c4 10             	add    $0x10,%esp
    for(;;)
    {
        hlt();
   12776:	e8 96 fe ff ff       	call   12611 <hlt>
   1277b:	eb f9                	jmp    12776 <do_default_handler+0x37>

0001277d <do_handler_unknown>:
    }
}
void do_handler_unknown(exception_frame_t *frame)
{
   1277d:	55                   	push   %ebp
   1277e:	89 e5                	mov    %esp,%ebp
   12780:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"unknown exception");
   12783:	83 ec 08             	sub    $0x8,%esp
   12786:	68 b9 45 01 00       	push   $0x145b9
   1278b:	ff 75 08             	pushl  0x8(%ebp)
   1278e:	e8 ac ff ff ff       	call   1273f <do_default_handler>
   12793:	83 c4 10             	add    $0x10,%esp
}
   12796:	90                   	nop
   12797:	c9                   	leave  
   12798:	c3                   	ret    

00012799 <do_handler_divider>:
void do_handler_divider(exception_frame_t *frame)
{
   12799:	55                   	push   %ebp
   1279a:	89 e5                	mov    %esp,%ebp
   1279c:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"divider exception");
   1279f:	83 ec 08             	sub    $0x8,%esp
   127a2:	68 cb 45 01 00       	push   $0x145cb
   127a7:	ff 75 08             	pushl  0x8(%ebp)
   127aa:	e8 90 ff ff ff       	call   1273f <do_default_handler>
   127af:	83 c4 10             	add    $0x10,%esp
}
   127b2:	90                   	nop
   127b3:	c9                   	leave  
   127b4:	c3                   	ret    

000127b5 <do_handler_debug>:
void do_handler_debug(exception_frame_t *frame)
{
   127b5:	55                   	push   %ebp
   127b6:	89 e5                	mov    %esp,%ebp
   127b8:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"debug exception");
   127bb:	83 ec 08             	sub    $0x8,%esp
   127be:	68 dd 45 01 00       	push   $0x145dd
   127c3:	ff 75 08             	pushl  0x8(%ebp)
   127c6:	e8 74 ff ff ff       	call   1273f <do_default_handler>
   127cb:	83 c4 10             	add    $0x10,%esp
}
   127ce:	90                   	nop
   127cf:	c9                   	leave  
   127d0:	c3                   	ret    

000127d1 <do_handler_nmi>:
void do_handler_nmi(exception_frame_t *frame)   
{
   127d1:	55                   	push   %ebp
   127d2:	89 e5                	mov    %esp,%ebp
   127d4:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"nmi exception");
   127d7:	83 ec 08             	sub    $0x8,%esp
   127da:	68 ed 45 01 00       	push   $0x145ed
   127df:	ff 75 08             	pushl  0x8(%ebp)
   127e2:	e8 58 ff ff ff       	call   1273f <do_default_handler>
   127e7:	83 c4 10             	add    $0x10,%esp
}
   127ea:	90                   	nop
   127eb:	c9                   	leave  
   127ec:	c3                   	ret    

000127ed <do_handler_breakpoint>:
void do_handler_breakpoint(exception_frame_t *frame)
{
   127ed:	55                   	push   %ebp
   127ee:	89 e5                	mov    %esp,%ebp
   127f0:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"breakpoint exception");
   127f3:	83 ec 08             	sub    $0x8,%esp
   127f6:	68 fb 45 01 00       	push   $0x145fb
   127fb:	ff 75 08             	pushl  0x8(%ebp)
   127fe:	e8 3c ff ff ff       	call   1273f <do_default_handler>
   12803:	83 c4 10             	add    $0x10,%esp
}
   12806:	90                   	nop
   12807:	c9                   	leave  
   12808:	c3                   	ret    

00012809 <do_handler_overflow>:
void do_handler_overflow(exception_frame_t *frame)
{
   12809:	55                   	push   %ebp
   1280a:	89 e5                	mov    %esp,%ebp
   1280c:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"overflow exception");
   1280f:	83 ec 08             	sub    $0x8,%esp
   12812:	68 10 46 01 00       	push   $0x14610
   12817:	ff 75 08             	pushl  0x8(%ebp)
   1281a:	e8 20 ff ff ff       	call   1273f <do_default_handler>
   1281f:	83 c4 10             	add    $0x10,%esp
}
   12822:	90                   	nop
   12823:	c9                   	leave  
   12824:	c3                   	ret    

00012825 <do_handler_bounds>:
void do_handler_bounds(exception_frame_t *frame)
{
   12825:	55                   	push   %ebp
   12826:	89 e5                	mov    %esp,%ebp
   12828:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"bounds exception");
   1282b:	83 ec 08             	sub    $0x8,%esp
   1282e:	68 23 46 01 00       	push   $0x14623
   12833:	ff 75 08             	pushl  0x8(%ebp)
   12836:	e8 04 ff ff ff       	call   1273f <do_default_handler>
   1283b:	83 c4 10             	add    $0x10,%esp
}
   1283e:	90                   	nop
   1283f:	c9                   	leave  
   12840:	c3                   	ret    

00012841 <do_handler_invalid_op>:
void do_handler_invalid_op(exception_frame_t *frame)
{
   12841:	55                   	push   %ebp
   12842:	89 e5                	mov    %esp,%ebp
   12844:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"invalid operation exception");
   12847:	83 ec 08             	sub    $0x8,%esp
   1284a:	68 34 46 01 00       	push   $0x14634
   1284f:	ff 75 08             	pushl  0x8(%ebp)
   12852:	e8 e8 fe ff ff       	call   1273f <do_default_handler>
   12857:	83 c4 10             	add    $0x10,%esp
}
   1285a:	90                   	nop
   1285b:	c9                   	leave  
   1285c:	c3                   	ret    

0001285d <do_handler_device_not_available>:
void do_handler_device_not_available(exception_frame_t *frame)
{
   1285d:	55                   	push   %ebp
   1285e:	89 e5                	mov    %esp,%ebp
   12860:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"device not available exception");
   12863:	83 ec 08             	sub    $0x8,%esp
   12866:	68 50 46 01 00       	push   $0x14650
   1286b:	ff 75 08             	pushl  0x8(%ebp)
   1286e:	e8 cc fe ff ff       	call   1273f <do_default_handler>
   12873:	83 c4 10             	add    $0x10,%esp
}
   12876:	90                   	nop
   12877:	c9                   	leave  
   12878:	c3                   	ret    

00012879 <do_handler_double_fault>:
void do_handler_double_fault(exception_frame_t *frame)
{
   12879:	55                   	push   %ebp
   1287a:	89 e5                	mov    %esp,%ebp
   1287c:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"double fault exception");
   1287f:	83 ec 08             	sub    $0x8,%esp
   12882:	68 6f 46 01 00       	push   $0x1466f
   12887:	ff 75 08             	pushl  0x8(%ebp)
   1288a:	e8 b0 fe ff ff       	call   1273f <do_default_handler>
   1288f:	83 c4 10             	add    $0x10,%esp
}
   12892:	90                   	nop
   12893:	c9                   	leave  
   12894:	c3                   	ret    

00012895 <do_handler_invalid_tss>:
void do_handler_invalid_tss(exception_frame_t *frame)
{
   12895:	55                   	push   %ebp
   12896:	89 e5                	mov    %esp,%ebp
   12898:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"invalid tss exception");
   1289b:	83 ec 08             	sub    $0x8,%esp
   1289e:	68 86 46 01 00       	push   $0x14686
   128a3:	ff 75 08             	pushl  0x8(%ebp)
   128a6:	e8 94 fe ff ff       	call   1273f <do_default_handler>
   128ab:	83 c4 10             	add    $0x10,%esp
}
   128ae:	90                   	nop
   128af:	c9                   	leave  
   128b0:	c3                   	ret    

000128b1 <do_handler_segment_not_present>:
void do_handler_segment_not_present(exception_frame_t *frame)
{
   128b1:	55                   	push   %ebp
   128b2:	89 e5                	mov    %esp,%ebp
   128b4:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"segment not present exception");
   128b7:	83 ec 08             	sub    $0x8,%esp
   128ba:	68 9c 46 01 00       	push   $0x1469c
   128bf:	ff 75 08             	pushl  0x8(%ebp)
   128c2:	e8 78 fe ff ff       	call   1273f <do_default_handler>
   128c7:	83 c4 10             	add    $0x10,%esp
}
   128ca:	90                   	nop
   128cb:	c9                   	leave  
   128cc:	c3                   	ret    

000128cd <do_handler_stack_segment_fault>:
void do_handler_stack_segment_fault(exception_frame_t *frame)
{
   128cd:	55                   	push   %ebp
   128ce:	89 e5                	mov    %esp,%ebp
   128d0:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"stack segment fault exception");
   128d3:	83 ec 08             	sub    $0x8,%esp
   128d6:	68 ba 46 01 00       	push   $0x146ba
   128db:	ff 75 08             	pushl  0x8(%ebp)
   128de:	e8 5c fe ff ff       	call   1273f <do_default_handler>
   128e3:	83 c4 10             	add    $0x10,%esp
}
   128e6:	90                   	nop
   128e7:	c9                   	leave  
   128e8:	c3                   	ret    

000128e9 <do_handler_general_protection>:
void do_handler_general_protection(exception_frame_t *frame)
{
   128e9:	55                   	push   %ebp
   128ea:	89 e5                	mov    %esp,%ebp
   128ec:	83 ec 08             	sub    $0x8,%esp
    log_printf("--------------------------------");
   128ef:	83 ec 0c             	sub    $0xc,%esp
   128f2:	68 d8 46 01 00       	push   $0x146d8
   128f7:	e8 cb 17 00 00       	call   140c7 <log_printf>
   128fc:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happened: General Protection.");
   128ff:	83 ec 0c             	sub    $0xc,%esp
   12902:	68 fc 46 01 00       	push   $0x146fc
   12907:	e8 bb 17 00 00       	call   140c7 <log_printf>
   1290c:	83 c4 10             	add    $0x10,%esp
    if (frame->error_code & ERR_GP_EXT) {
   1290f:	8b 45 08             	mov    0x8(%ebp),%eax
   12912:	8b 40 34             	mov    0x34(%eax),%eax
   12915:	83 e0 01             	and    $0x1,%eax
   12918:	85 c0                	test   %eax,%eax
   1291a:	74 12                	je     1292e <do_handler_general_protection+0x45>
        log_printf("the exception occurred during delivery of an "
   1291c:	83 ec 0c             	sub    $0xc,%esp
   1291f:	68 28 47 01 00       	push   $0x14728
   12924:	e8 9e 17 00 00       	call   140c7 <log_printf>
   12929:	83 c4 10             	add    $0x10,%esp
   1292c:	eb 10                	jmp    1293e <do_handler_general_protection+0x55>
                "event external to the program, such as an interrupt"
                "or an earlier exception.");
    } else {
        log_printf("the exception occurred during delivery of a"
   1292e:	83 ec 0c             	sub    $0xc,%esp
   12931:	68 a4 47 01 00       	push   $0x147a4
   12936:	e8 8c 17 00 00       	call   140c7 <log_printf>
   1293b:	83 c4 10             	add    $0x10,%esp
                    "software interrupt (INT n, INT3, or INTO).");
    }
    
    if (frame->error_code & ERR_GP_IDT) {
   1293e:	8b 45 08             	mov    0x8(%ebp),%eax
   12941:	8b 40 34             	mov    0x34(%eax),%eax
   12944:	83 e0 02             	and    $0x2,%eax
   12947:	85 c0                	test   %eax,%eax
   12949:	74 12                	je     1295d <do_handler_general_protection+0x74>
        log_printf("the index portion of the error code refers "
   1294b:	83 ec 0c             	sub    $0xc,%esp
   1294e:	68 fc 47 01 00       	push   $0x147fc
   12953:	e8 6f 17 00 00       	call   140c7 <log_printf>
   12958:	83 c4 10             	add    $0x10,%esp
   1295b:	eb 10                	jmp    1296d <do_handler_general_protection+0x84>
                    "to a gate descriptor in the IDT");
    } else {
        log_printf("the index refers to a descriptor in the GDT");
   1295d:	83 ec 0c             	sub    $0xc,%esp
   12960:	68 48 48 01 00       	push   $0x14848
   12965:	e8 5d 17 00 00       	call   140c7 <log_printf>
   1296a:	83 c4 10             	add    $0x10,%esp
    }
    
    log_printf("segment index: %d", frame->error_code & 0xFFF8);
   1296d:	8b 45 08             	mov    0x8(%ebp),%eax
   12970:	8b 40 34             	mov    0x34(%eax),%eax
   12973:	25 f8 ff 00 00       	and    $0xfff8,%eax
   12978:	83 ec 08             	sub    $0x8,%esp
   1297b:	50                   	push   %eax
   1297c:	68 74 48 01 00       	push   $0x14874
   12981:	e8 41 17 00 00       	call   140c7 <log_printf>
   12986:	83 c4 10             	add    $0x10,%esp

    dump_core_regs(frame);
   12989:	83 ec 0c             	sub    $0xc,%esp
   1298c:	ff 75 08             	pushl  0x8(%ebp)
   1298f:	e8 9f fc ff ff       	call   12633 <dump_core_regs>
   12994:	83 c4 10             	add    $0x10,%esp
    while(1)
    {
        hlt();
   12997:	e8 75 fc ff ff       	call   12611 <hlt>
   1299c:	eb f9                	jmp    12997 <do_handler_general_protection+0xae>

0001299e <do_handler_page_fault>:
    }
}
void do_handler_page_fault(exception_frame_t *frame)
{
   1299e:	55                   	push   %ebp
   1299f:	89 e5                	mov    %esp,%ebp
   129a1:	83 ec 08             	sub    $0x8,%esp
    log_printf("---------------------\n");
   129a4:	83 ec 0c             	sub    $0xc,%esp
   129a7:	68 87 45 01 00       	push   $0x14587
   129ac:	e8 16 17 00 00       	call   140c7 <log_printf>
   129b1:	83 c4 10             	add    $0x10,%esp
    log_printf("page fault exception\n");
   129b4:	83 ec 0c             	sub    $0xc,%esp
   129b7:	68 86 48 01 00       	push   $0x14886
   129bc:	e8 06 17 00 00       	call   140c7 <log_printf>
   129c1:	83 c4 10             	add    $0x10,%esp
    if(frame->error_code & ERR_PAGE_P)
   129c4:	8b 45 08             	mov    0x8(%ebp),%eax
   129c7:	8b 40 34             	mov    0x34(%eax),%eax
   129ca:	83 e0 01             	and    $0x1,%eax
   129cd:	85 c0                	test   %eax,%eax
   129cf:	74 18                	je     129e9 <do_handler_page_fault+0x4b>
    {
        log_printf("page fault exception: page level protection: 0x%x\n",read_cr2());
   129d1:	e8 2a fc ff ff       	call   12600 <read_cr2>
   129d6:	83 ec 08             	sub    $0x8,%esp
   129d9:	50                   	push   %eax
   129da:	68 9c 48 01 00       	push   $0x1489c
   129df:	e8 e3 16 00 00       	call   140c7 <log_printf>
   129e4:	83 c4 10             	add    $0x10,%esp
   129e7:	eb 16                	jmp    129ff <do_handler_page_fault+0x61>
    }
    else
    {
        log_printf("page fault exception: page not present: 0x%x\n",read_cr2());
   129e9:	e8 12 fc ff ff       	call   12600 <read_cr2>
   129ee:	83 ec 08             	sub    $0x8,%esp
   129f1:	50                   	push   %eax
   129f2:	68 d0 48 01 00       	push   $0x148d0
   129f7:	e8 cb 16 00 00       	call   140c7 <log_printf>
   129fc:	83 c4 10             	add    $0x10,%esp
    }
    if(frame->error_code & ERR_PAGE_WR)
   129ff:	8b 45 08             	mov    0x8(%ebp),%eax
   12a02:	8b 40 34             	mov    0x34(%eax),%eax
   12a05:	83 e0 02             	and    $0x2,%eax
   12a08:	85 c0                	test   %eax,%eax
   12a0a:	74 18                	je     12a24 <do_handler_page_fault+0x86>
    {
        log_printf("page fault exception: write access :0x%x\n",read_cr2());
   12a0c:	e8 ef fb ff ff       	call   12600 <read_cr2>
   12a11:	83 ec 08             	sub    $0x8,%esp
   12a14:	50                   	push   %eax
   12a15:	68 00 49 01 00       	push   $0x14900
   12a1a:	e8 a8 16 00 00       	call   140c7 <log_printf>
   12a1f:	83 c4 10             	add    $0x10,%esp
   12a22:	eb 16                	jmp    12a3a <do_handler_page_fault+0x9c>
    }
    else
    {
        log_printf("page fault exception: read access :0x%x\n",read_cr2());
   12a24:	e8 d7 fb ff ff       	call   12600 <read_cr2>
   12a29:	83 ec 08             	sub    $0x8,%esp
   12a2c:	50                   	push   %eax
   12a2d:	68 2c 49 01 00       	push   $0x1492c
   12a32:	e8 90 16 00 00       	call   140c7 <log_printf>
   12a37:	83 c4 10             	add    $0x10,%esp
    }
    if(frame->error_code & ERR_PAGE_US)
   12a3a:	8b 45 08             	mov    0x8(%ebp),%eax
   12a3d:	8b 40 34             	mov    0x34(%eax),%eax
   12a40:	83 e0 04             	and    $0x4,%eax
   12a43:	85 c0                	test   %eax,%eax
   12a45:	74 18                	je     12a5f <do_handler_page_fault+0xc1>
    {
        log_printf("page fault exception: user access :0x%x\n",read_cr2());
   12a47:	e8 b4 fb ff ff       	call   12600 <read_cr2>
   12a4c:	83 ec 08             	sub    $0x8,%esp
   12a4f:	50                   	push   %eax
   12a50:	68 58 49 01 00       	push   $0x14958
   12a55:	e8 6d 16 00 00       	call   140c7 <log_printf>
   12a5a:	83 c4 10             	add    $0x10,%esp
   12a5d:	eb 16                	jmp    12a75 <do_handler_page_fault+0xd7>
    }
    else
    {
        log_printf("page fault exception: supervisor access :0x%x\n",read_cr2());
   12a5f:	e8 9c fb ff ff       	call   12600 <read_cr2>
   12a64:	83 ec 08             	sub    $0x8,%esp
   12a67:	50                   	push   %eax
   12a68:	68 84 49 01 00       	push   $0x14984
   12a6d:	e8 55 16 00 00       	call   140c7 <log_printf>
   12a72:	83 c4 10             	add    $0x10,%esp
    }
    dump_core_regs(frame);
   12a75:	83 ec 0c             	sub    $0xc,%esp
   12a78:	ff 75 08             	pushl  0x8(%ebp)
   12a7b:	e8 b3 fb ff ff       	call   12633 <dump_core_regs>
   12a80:	83 c4 10             	add    $0x10,%esp
    while(1)
    {
        hlt();
   12a83:	e8 89 fb ff ff       	call   12611 <hlt>
   12a88:	eb f9                	jmp    12a83 <do_handler_page_fault+0xe5>

00012a8a <do_handler_x87_floating_point>:
    }
}
void do_handler_x87_floating_point(exception_frame_t *frame)
{   
   12a8a:	55                   	push   %ebp
   12a8b:	89 e5                	mov    %esp,%ebp
   12a8d:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"x87 floating point exception");
   12a90:	83 ec 08             	sub    $0x8,%esp
   12a93:	68 b3 49 01 00       	push   $0x149b3
   12a98:	ff 75 08             	pushl  0x8(%ebp)
   12a9b:	e8 9f fc ff ff       	call   1273f <do_default_handler>
   12aa0:	83 c4 10             	add    $0x10,%esp
}
   12aa3:	90                   	nop
   12aa4:	c9                   	leave  
   12aa5:	c3                   	ret    

00012aa6 <do_handler_alignment_check>:
void do_handler_alignment_check(exception_frame_t *frame)
{
   12aa6:	55                   	push   %ebp
   12aa7:	89 e5                	mov    %esp,%ebp
   12aa9:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"alignment check exception");
   12aac:	83 ec 08             	sub    $0x8,%esp
   12aaf:	68 d0 49 01 00       	push   $0x149d0
   12ab4:	ff 75 08             	pushl  0x8(%ebp)
   12ab7:	e8 83 fc ff ff       	call   1273f <do_default_handler>
   12abc:	83 c4 10             	add    $0x10,%esp
}
   12abf:	90                   	nop
   12ac0:	c9                   	leave  
   12ac1:	c3                   	ret    

00012ac2 <do_handler_machine_check>:
void do_handler_machine_check(exception_frame_t *frame)
{
   12ac2:	55                   	push   %ebp
   12ac3:	89 e5                	mov    %esp,%ebp
   12ac5:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"machine check exception");
   12ac8:	83 ec 08             	sub    $0x8,%esp
   12acb:	68 ea 49 01 00       	push   $0x149ea
   12ad0:	ff 75 08             	pushl  0x8(%ebp)
   12ad3:	e8 67 fc ff ff       	call   1273f <do_default_handler>
   12ad8:	83 c4 10             	add    $0x10,%esp
}
   12adb:	90                   	nop
   12adc:	c9                   	leave  
   12add:	c3                   	ret    

00012ade <do_handler_simd_floating_point>:
void do_handler_simd_floating_point(exception_frame_t *frame)
{
   12ade:	55                   	push   %ebp
   12adf:	89 e5                	mov    %esp,%ebp
   12ae1:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"simd floating point exception");
   12ae4:	83 ec 08             	sub    $0x8,%esp
   12ae7:	68 02 4a 01 00       	push   $0x14a02
   12aec:	ff 75 08             	pushl  0x8(%ebp)
   12aef:	e8 4b fc ff ff       	call   1273f <do_default_handler>
   12af4:	83 c4 10             	add    $0x10,%esp
}
   12af7:	90                   	nop
   12af8:	c9                   	leave  
   12af9:	c3                   	ret    

00012afa <do_handler_virtualization>:
void do_handler_virtualization(exception_frame_t *frame)
{
   12afa:	55                   	push   %ebp
   12afb:	89 e5                	mov    %esp,%ebp
   12afd:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"virtualization exception");
   12b00:	83 ec 08             	sub    $0x8,%esp
   12b03:	68 20 4a 01 00       	push   $0x14a20
   12b08:	ff 75 08             	pushl  0x8(%ebp)
   12b0b:	e8 2f fc ff ff       	call   1273f <do_default_handler>
   12b10:	83 c4 10             	add    $0x10,%esp
}
   12b13:	90                   	nop
   12b14:	c9                   	leave  
   12b15:	c3                   	ret    

00012b16 <do_handler_security>:
void do_handler_security(exception_frame_t *frame)
{
   12b16:	55                   	push   %ebp
   12b17:	89 e5                	mov    %esp,%ebp
   12b19:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"security exception");
   12b1c:	83 ec 08             	sub    $0x8,%esp
   12b1f:	68 39 4a 01 00       	push   $0x14a39
   12b24:	ff 75 08             	pushl  0x8(%ebp)
   12b27:	e8 13 fc ff ff       	call   1273f <do_default_handler>
   12b2c:	83 c4 10             	add    $0x10,%esp
}
   12b2f:	90                   	nop
   12b30:	c9                   	leave  
   12b31:	c3                   	ret    

00012b32 <init_pic>:

static void init_pic(void)
{
   12b32:	55                   	push   %ebp
   12b33:	89 e5                	mov    %esp,%ebp
    outb(PIC0_ICW1,PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
   12b35:	6a 11                	push   $0x11
   12b37:	6a 20                	push   $0x20
   12b39:	e8 6d fa ff ff       	call   125ab <outb>
   12b3e:	83 c4 08             	add    $0x8,%esp
    outb(PIC0_ICW2,IRQ_PIC_START);
   12b41:	6a 20                	push   $0x20
   12b43:	6a 21                	push   $0x21
   12b45:	e8 61 fa ff ff       	call   125ab <outb>
   12b4a:	83 c4 08             	add    $0x8,%esp
    outb(PIC0_ICW3,1 << IRQ2_NMI);
   12b4d:	6a 04                	push   $0x4
   12b4f:	6a 21                	push   $0x21
   12b51:	e8 55 fa ff ff       	call   125ab <outb>
   12b56:	83 c4 08             	add    $0x8,%esp
    outb(PIC0_ICW4,PIC_ICW4_8086);
   12b59:	6a 01                	push   $0x1
   12b5b:	6a 21                	push   $0x21
   12b5d:	e8 49 fa ff ff       	call   125ab <outb>
   12b62:	83 c4 08             	add    $0x8,%esp


    outb(PIC1_ICW1,PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
   12b65:	6a 11                	push   $0x11
   12b67:	68 a0 00 00 00       	push   $0xa0
   12b6c:	e8 3a fa ff ff       	call   125ab <outb>
   12b71:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_ICW2,IRQ_PIC_START + 8);
   12b74:	6a 28                	push   $0x28
   12b76:	68 a1 00 00 00       	push   $0xa1
   12b7b:	e8 2b fa ff ff       	call   125ab <outb>
   12b80:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_ICW3,2);
   12b83:	6a 02                	push   $0x2
   12b85:	68 a1 00 00 00       	push   $0xa1
   12b8a:	e8 1c fa ff ff       	call   125ab <outb>
   12b8f:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_ICW4,PIC_ICW4_8086);
   12b92:	6a 01                	push   $0x1
   12b94:	68 a1 00 00 00       	push   $0xa1
   12b99:	e8 0d fa ff ff       	call   125ab <outb>
   12b9e:	83 c4 08             	add    $0x8,%esp

    outb(PIC0_IMR,0xff & ~ (1 << 2));
   12ba1:	68 fb 00 00 00       	push   $0xfb
   12ba6:	6a 21                	push   $0x21
   12ba8:	e8 fe f9 ff ff       	call   125ab <outb>
   12bad:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_IMR,0xff);
   12bb0:	68 ff 00 00 00       	push   $0xff
   12bb5:	68 a1 00 00 00       	push   $0xa1
   12bba:	e8 ec f9 ff ff       	call   125ab <outb>
   12bbf:	83 c4 08             	add    $0x8,%esp
}
   12bc2:	90                   	nop
   12bc3:	c9                   	leave  
   12bc4:	c3                   	ret    

00012bc5 <irq_init>:

void irq_init(void)
{
   12bc5:	55                   	push   %ebp
   12bc6:	89 e5                	mov    %esp,%ebp
   12bc8:	83 ec 18             	sub    $0x18,%esp
    for(int i = 0; i < IRQ_TABLE_NU; i++)
   12bcb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12bd2:	eb 25                	jmp    12bf9 <irq_init+0x34>
    {
        gate_desc_set(idt_table + i, KERNEL_SELECTOR_CS, (uint32_t)exception_handler_unknown, 
   12bd4:	ba 84 00 01 00       	mov    $0x10084,%edx
   12bd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12bdc:	c1 e0 03             	shl    $0x3,%eax
   12bdf:	05 a0 0c 02 00       	add    $0x20ca0,%eax
   12be4:	68 00 8e 00 00       	push   $0x8e00
   12be9:	52                   	push   %edx
   12bea:	6a 08                	push   $0x8
   12bec:	50                   	push   %eax
   12bed:	e8 0d f8 ff ff       	call   123ff <gate_desc_set>
   12bf2:	83 c4 10             	add    $0x10,%esp
    for(int i = 0; i < IRQ_TABLE_NU; i++)
   12bf5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12bf9:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   12bfd:	7e d5                	jle    12bd4 <irq_init+0xf>
        GATE_P_PRESENT | GATE_DPL_0 | GATE_TYPE_INT);
    }
    //irq_install(IRQ0_DE,do_handler_divider); 用这个的话能进入do_handler_divider 但是跳不到.S的地方出栈
    irq_install(IRQ0_DE,exception_handler_divider);
   12bff:	83 ec 08             	sub    $0x8,%esp
   12c02:	68 af 00 01 00       	push   $0x100af
   12c07:	6a 00                	push   $0x0
   12c09:	e8 77 01 00 00       	call   12d85 <irq_install>
   12c0e:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ1_DB,exception_handler_debug);
   12c11:	83 ec 08             	sub    $0x8,%esp
   12c14:	68 da 00 01 00       	push   $0x100da
   12c19:	6a 01                	push   $0x1
   12c1b:	e8 65 01 00 00       	call   12d85 <irq_install>
   12c20:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ2_NMI,exception_handler_nmi);
   12c23:	83 ec 08             	sub    $0x8,%esp
   12c26:	68 05 01 01 00       	push   $0x10105
   12c2b:	6a 02                	push   $0x2
   12c2d:	e8 53 01 00 00       	call   12d85 <irq_install>
   12c32:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ3_BP,exception_handler_breakpoint);
   12c35:	83 ec 08             	sub    $0x8,%esp
   12c38:	68 30 01 01 00       	push   $0x10130
   12c3d:	6a 03                	push   $0x3
   12c3f:	e8 41 01 00 00       	call   12d85 <irq_install>
   12c44:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ4_OF,exception_handler_overflow);
   12c47:	83 ec 08             	sub    $0x8,%esp
   12c4a:	68 5b 01 01 00       	push   $0x1015b
   12c4f:	6a 04                	push   $0x4
   12c51:	e8 2f 01 00 00       	call   12d85 <irq_install>
   12c56:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ5_BR,exception_handler_bounds);
   12c59:	83 ec 08             	sub    $0x8,%esp
   12c5c:	68 86 01 01 00       	push   $0x10186
   12c61:	6a 05                	push   $0x5
   12c63:	e8 1d 01 00 00       	call   12d85 <irq_install>
   12c68:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ6_UD,exception_handler_invalid_op);
   12c6b:	83 ec 08             	sub    $0x8,%esp
   12c6e:	68 b1 01 01 00       	push   $0x101b1
   12c73:	6a 06                	push   $0x6
   12c75:	e8 0b 01 00 00       	call   12d85 <irq_install>
   12c7a:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ7_NM,exception_handler_device_not_available);
   12c7d:	83 ec 08             	sub    $0x8,%esp
   12c80:	68 dc 01 01 00       	push   $0x101dc
   12c85:	6a 07                	push   $0x7
   12c87:	e8 f9 00 00 00       	call   12d85 <irq_install>
   12c8c:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ8_DF,exception_handler_double_fault);
   12c8f:	83 ec 08             	sub    $0x8,%esp
   12c92:	68 07 02 01 00       	push   $0x10207
   12c97:	6a 08                	push   $0x8
   12c99:	e8 e7 00 00 00       	call   12d85 <irq_install>
   12c9e:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ10_TS,exception_handler_invalid_tss);
   12ca1:	83 ec 08             	sub    $0x8,%esp
   12ca4:	68 30 02 01 00       	push   $0x10230
   12ca9:	6a 0a                	push   $0xa
   12cab:	e8 d5 00 00 00       	call   12d85 <irq_install>
   12cb0:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ11_NP,exception_handler_segment_not_present);
   12cb3:	83 ec 08             	sub    $0x8,%esp
   12cb6:	68 59 02 01 00       	push   $0x10259
   12cbb:	6a 0b                	push   $0xb
   12cbd:	e8 c3 00 00 00       	call   12d85 <irq_install>
   12cc2:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ12_SS,exception_handler_stack_segment_fault);
   12cc5:	83 ec 08             	sub    $0x8,%esp
   12cc8:	68 82 02 01 00       	push   $0x10282
   12ccd:	6a 0c                	push   $0xc
   12ccf:	e8 b1 00 00 00       	call   12d85 <irq_install>
   12cd4:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ13_GP,exception_handler_general_protection);
   12cd7:	83 ec 08             	sub    $0x8,%esp
   12cda:	68 ab 02 01 00       	push   $0x102ab
   12cdf:	6a 0d                	push   $0xd
   12ce1:	e8 9f 00 00 00       	call   12d85 <irq_install>
   12ce6:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ14_PF,exception_handler_page_fault);
   12ce9:	83 ec 08             	sub    $0x8,%esp
   12cec:	68 5b 00 01 00       	push   $0x1005b
   12cf1:	6a 0e                	push   $0xe
   12cf3:	e8 8d 00 00 00       	call   12d85 <irq_install>
   12cf8:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ16_MF,exception_handler_x87_floating_point);
   12cfb:	83 ec 08             	sub    $0x8,%esp
   12cfe:	68 d4 02 01 00       	push   $0x102d4
   12d03:	6a 10                	push   $0x10
   12d05:	e8 7b 00 00 00       	call   12d85 <irq_install>
   12d0a:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ17_AC,exception_handler_alignment_check);
   12d0d:	83 ec 08             	sub    $0x8,%esp
   12d10:	68 ff 02 01 00       	push   $0x102ff
   12d15:	6a 11                	push   $0x11
   12d17:	e8 69 00 00 00       	call   12d85 <irq_install>
   12d1c:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ18_MC,exception_handler_machine_check);
   12d1f:	83 ec 08             	sub    $0x8,%esp
   12d22:	68 28 03 01 00       	push   $0x10328
   12d27:	6a 12                	push   $0x12
   12d29:	e8 57 00 00 00       	call   12d85 <irq_install>
   12d2e:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ19_XM,exception_handler_simd_floating_point);
   12d31:	83 ec 08             	sub    $0x8,%esp
   12d34:	68 53 03 01 00       	push   $0x10353
   12d39:	6a 13                	push   $0x13
   12d3b:	e8 45 00 00 00       	call   12d85 <irq_install>
   12d40:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ20_VE,exception_handler_virtualization);
   12d43:	83 ec 08             	sub    $0x8,%esp
   12d46:	68 7e 03 01 00       	push   $0x1037e
   12d4b:	6a 14                	push   $0x14
   12d4d:	e8 33 00 00 00       	call   12d85 <irq_install>
   12d52:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ21_CP,exception_handler_security);
   12d55:	83 ec 08             	sub    $0x8,%esp
   12d58:	68 a9 03 01 00       	push   $0x103a9
   12d5d:	6a 15                	push   $0x15
   12d5f:	e8 21 00 00 00       	call   12d85 <irq_install>
   12d64:	83 c4 10             	add    $0x10,%esp

    lidt((uint32_t)idt_table, sizeof(idt_table));
   12d67:	b8 a0 0c 02 00       	mov    $0x20ca0,%eax
   12d6c:	83 ec 08             	sub    $0x8,%esp
   12d6f:	68 00 04 00 00       	push   $0x400
   12d74:	50                   	push   %eax
   12d75:	e8 5e f8 ff ff       	call   125d8 <lidt>
   12d7a:	83 c4 10             	add    $0x10,%esp

    init_pic();
   12d7d:	e8 b0 fd ff ff       	call   12b32 <init_pic>
}
   12d82:	90                   	nop
   12d83:	c9                   	leave  
   12d84:	c3                   	ret    

00012d85 <irq_install>:

int irq_install(int irq_num,irq_handler_t handler)
{
   12d85:	55                   	push   %ebp
   12d86:	89 e5                	mov    %esp,%ebp
   12d88:	83 ec 08             	sub    $0x8,%esp
    if(irq_num < 0 || irq_num >= IRQ_TABLE_NU)
   12d8b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   12d8f:	78 06                	js     12d97 <irq_install+0x12>
   12d91:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   12d95:	7e 07                	jle    12d9e <irq_install+0x19>
    {
        return -1;
   12d97:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   12d9c:	eb 25                	jmp    12dc3 <irq_install+0x3e>
    }
    gate_desc_set(idt_table + irq_num, KERNEL_SELECTOR_CS, (uint32_t)handler, 
   12d9e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12da1:	8b 55 08             	mov    0x8(%ebp),%edx
   12da4:	c1 e2 03             	shl    $0x3,%edx
   12da7:	81 c2 a0 0c 02 00    	add    $0x20ca0,%edx
   12dad:	68 00 8e 00 00       	push   $0x8e00
   12db2:	50                   	push   %eax
   12db3:	6a 08                	push   $0x8
   12db5:	52                   	push   %edx
   12db6:	e8 44 f6 ff ff       	call   123ff <gate_desc_set>
   12dbb:	83 c4 10             	add    $0x10,%esp
    GATE_P_PRESENT | GATE_DPL_0 | GATE_TYPE_INT);
    return 0;
   12dbe:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12dc3:	c9                   	leave  
   12dc4:	c3                   	ret    

00012dc5 <irq_enable>:

void irq_enable(int irq_num)
{
   12dc5:	55                   	push   %ebp
   12dc6:	89 e5                	mov    %esp,%ebp
   12dc8:	53                   	push   %ebx
   12dc9:	83 ec 10             	sub    $0x10,%esp
    if(irq_num < IRQ_PIC_START)
   12dcc:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   12dd0:	7e 78                	jle    12e4a <irq_enable+0x85>
    {
        return;
    }
    irq_num -= IRQ_PIC_START;
   12dd2:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if(irq_num < 8)
   12dd6:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   12dda:	7f 32                	jg     12e0e <irq_enable+0x49>
    {
        uint8_t mask = inb(PIC0_IMR) & ~(1 << irq_num);
   12ddc:	6a 21                	push   $0x21
   12dde:	e8 ab f7 ff ff       	call   1258e <inb>
   12de3:	83 c4 04             	add    $0x4,%esp
   12de6:	89 c2                	mov    %eax,%edx
   12de8:	8b 45 08             	mov    0x8(%ebp),%eax
   12deb:	bb 01 00 00 00       	mov    $0x1,%ebx
   12df0:	89 c1                	mov    %eax,%ecx
   12df2:	d3 e3                	shl    %cl,%ebx
   12df4:	89 d8                	mov    %ebx,%eax
   12df6:	f7 d0                	not    %eax
   12df8:	21 d0                	and    %edx,%eax
   12dfa:	88 45 fa             	mov    %al,-0x6(%ebp)
        outb(PIC0_IMR,mask);
   12dfd:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   12e01:	50                   	push   %eax
   12e02:	6a 21                	push   $0x21
   12e04:	e8 a2 f7 ff ff       	call   125ab <outb>
   12e09:	83 c4 08             	add    $0x8,%esp
   12e0c:	eb 3d                	jmp    12e4b <irq_enable+0x86>
    }
    else
    {
        irq_num -= 8;
   12e0e:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
        uint8_t mask = inb(PIC1_IMR) & ~(1 << (irq_num));
   12e12:	68 a1 00 00 00       	push   $0xa1
   12e17:	e8 72 f7 ff ff       	call   1258e <inb>
   12e1c:	83 c4 04             	add    $0x4,%esp
   12e1f:	89 c2                	mov    %eax,%edx
   12e21:	8b 45 08             	mov    0x8(%ebp),%eax
   12e24:	bb 01 00 00 00       	mov    $0x1,%ebx
   12e29:	89 c1                	mov    %eax,%ecx
   12e2b:	d3 e3                	shl    %cl,%ebx
   12e2d:	89 d8                	mov    %ebx,%eax
   12e2f:	f7 d0                	not    %eax
   12e31:	21 d0                	and    %edx,%eax
   12e33:	88 45 fb             	mov    %al,-0x5(%ebp)
        outb(PIC1_IMR,mask);
   12e36:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   12e3a:	50                   	push   %eax
   12e3b:	68 a1 00 00 00       	push   $0xa1
   12e40:	e8 66 f7 ff ff       	call   125ab <outb>
   12e45:	83 c4 08             	add    $0x8,%esp
   12e48:	eb 01                	jmp    12e4b <irq_enable+0x86>
        return;
   12e4a:	90                   	nop
    }
}
   12e4b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12e4e:	c9                   	leave  
   12e4f:	c3                   	ret    

00012e50 <irq_disable>:

void irq_disable(int irq_num)
{
   12e50:	55                   	push   %ebp
   12e51:	89 e5                	mov    %esp,%ebp
   12e53:	53                   	push   %ebx
   12e54:	83 ec 10             	sub    $0x10,%esp
    if(irq_num < IRQ_PIC_START)
   12e57:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   12e5b:	7e 78                	jle    12ed5 <irq_disable+0x85>
    {
        return;
    }
    irq_num -= IRQ_PIC_START;
   12e5d:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if(irq_num < 8)
   12e61:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   12e65:	7f 32                	jg     12e99 <irq_disable+0x49>
    {
        uint8_t mask = inb(PIC0_IMR) | ~(1 << irq_num);
   12e67:	6a 21                	push   $0x21
   12e69:	e8 20 f7 ff ff       	call   1258e <inb>
   12e6e:	83 c4 04             	add    $0x4,%esp
   12e71:	89 c3                	mov    %eax,%ebx
   12e73:	8b 45 08             	mov    0x8(%ebp),%eax
   12e76:	ba 01 00 00 00       	mov    $0x1,%edx
   12e7b:	89 c1                	mov    %eax,%ecx
   12e7d:	d3 e2                	shl    %cl,%edx
   12e7f:	89 d0                	mov    %edx,%eax
   12e81:	f7 d0                	not    %eax
   12e83:	09 d8                	or     %ebx,%eax
   12e85:	88 45 fa             	mov    %al,-0x6(%ebp)
        outb(PIC0_IMR,mask);
   12e88:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   12e8c:	50                   	push   %eax
   12e8d:	6a 21                	push   $0x21
   12e8f:	e8 17 f7 ff ff       	call   125ab <outb>
   12e94:	83 c4 08             	add    $0x8,%esp
   12e97:	eb 3d                	jmp    12ed6 <irq_disable+0x86>
    }
    else
    {
        irq_num -= 8;
   12e99:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
        uint8_t mask = inb(PIC1_IMR) | ~(1 << (irq_num));
   12e9d:	68 a1 00 00 00       	push   $0xa1
   12ea2:	e8 e7 f6 ff ff       	call   1258e <inb>
   12ea7:	83 c4 04             	add    $0x4,%esp
   12eaa:	89 c3                	mov    %eax,%ebx
   12eac:	8b 45 08             	mov    0x8(%ebp),%eax
   12eaf:	ba 01 00 00 00       	mov    $0x1,%edx
   12eb4:	89 c1                	mov    %eax,%ecx
   12eb6:	d3 e2                	shl    %cl,%edx
   12eb8:	89 d0                	mov    %edx,%eax
   12eba:	f7 d0                	not    %eax
   12ebc:	09 d8                	or     %ebx,%eax
   12ebe:	88 45 fb             	mov    %al,-0x5(%ebp)
        outb(PIC1_IMR,mask);
   12ec1:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   12ec5:	50                   	push   %eax
   12ec6:	68 a1 00 00 00       	push   $0xa1
   12ecb:	e8 db f6 ff ff       	call   125ab <outb>
   12ed0:	83 c4 08             	add    $0x8,%esp
   12ed3:	eb 01                	jmp    12ed6 <irq_disable+0x86>
        return;
   12ed5:	90                   	nop
    }
}
   12ed6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12ed9:	c9                   	leave  
   12eda:	c3                   	ret    

00012edb <irq_disable_global>:
void irq_disable_global(void)
{
   12edb:	55                   	push   %ebp
   12edc:	89 e5                	mov    %esp,%ebp
    cli();
   12ede:	e8 e7 f6 ff ff       	call   125ca <cli>
}
   12ee3:	90                   	nop
   12ee4:	5d                   	pop    %ebp
   12ee5:	c3                   	ret    

00012ee6 <irq_enable_global>:

void irq_enable_global(void)
{
   12ee6:	55                   	push   %ebp
   12ee7:	89 e5                	mov    %esp,%ebp
    sti();
   12ee9:	e8 e3 f6 ff ff       	call   125d1 <sti>
}
   12eee:	90                   	nop
   12eef:	5d                   	pop    %ebp
   12ef0:	c3                   	ret    

00012ef1 <pic_send_eoi>:
void pic_send_eoi(int irq_num)
{
   12ef1:	55                   	push   %ebp
   12ef2:	89 e5                	mov    %esp,%ebp
    irq_num -= IRQ_PIC_START;
   12ef4:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if(irq_num >= 8)
   12ef8:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   12efc:	7e 0f                	jle    12f0d <pic_send_eoi+0x1c>
    {
        outb(PIC1_OCW2,PIC_OCW2_EOI);
   12efe:	6a 20                	push   $0x20
   12f00:	68 a0 00 00 00       	push   $0xa0
   12f05:	e8 a1 f6 ff ff       	call   125ab <outb>
   12f0a:	83 c4 08             	add    $0x8,%esp
    }
    outb(PIC0_OCW2,PIC_OCW2_EOI);
   12f0d:	6a 20                	push   $0x20
   12f0f:	6a 20                	push   $0x20
   12f11:	e8 95 f6 ff ff       	call   125ab <outb>
   12f16:	83 c4 08             	add    $0x8,%esp
}
   12f19:	90                   	nop
   12f1a:	c9                   	leave  
   12f1b:	c3                   	ret    

00012f1c <irq_enter_protection>:

irq_state_t irq_enter_protection(void)
{
   12f1c:	55                   	push   %ebp
   12f1d:	89 e5                	mov    %esp,%ebp
   12f1f:	83 ec 10             	sub    $0x10,%esp
    irq_state_t state = read_eflags();
   12f22:	e8 f1 f6 ff ff       	call   12618 <read_eflags>
   12f27:	89 45 fc             	mov    %eax,-0x4(%ebp)
    irq_disable_global();
   12f2a:	e8 ac ff ff ff       	call   12edb <irq_disable_global>
    return state;
   12f2f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   12f32:	c9                   	leave  
   12f33:	c3                   	ret    

00012f34 <irq_leave_protection>:

void irq_leave_protection(irq_state_t state)
{
   12f34:	55                   	push   %ebp
   12f35:	89 e5                	mov    %esp,%ebp
    
    write_eflags(state);
   12f37:	ff 75 08             	pushl  0x8(%ebp)
   12f3a:	e8 e9 f6 ff ff       	call   12628 <write_eflags>
   12f3f:	83 c4 04             	add    $0x4,%esp
}
   12f42:	90                   	nop
   12f43:	c9                   	leave  
   12f44:	c3                   	ret    

00012f45 <outb>:
{
   12f45:	55                   	push   %ebp
   12f46:	89 e5                	mov    %esp,%ebp
   12f48:	83 ec 08             	sub    $0x8,%esp
   12f4b:	8b 55 08             	mov    0x8(%ebp),%edx
   12f4e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12f51:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   12f55:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]"::[p]"d"(port),[v]"a"(data));
   12f58:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   12f5c:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   12f60:	ee                   	out    %al,(%dx)
}
   12f61:	90                   	nop
   12f62:	c9                   	leave  
   12f63:	c3                   	ret    

00012f64 <do_handler_time>:
#include "cpu/irq.h"
#include "os_cfg.h"
#include "comm/cpu_instr.h"
static uint32_t sys_tick;
void do_handler_time(exception_frame_t *frame)
{
   12f64:	55                   	push   %ebp
   12f65:	89 e5                	mov    %esp,%ebp
   12f67:	83 ec 08             	sub    $0x8,%esp
    sys_tick++;
   12f6a:	a1 a0 10 02 00       	mov    0x210a0,%eax
   12f6f:	83 c0 01             	add    $0x1,%eax
   12f72:	a3 a0 10 02 00       	mov    %eax,0x210a0
    pic_send_eoi(IRQ0_TIMER);
   12f77:	83 ec 0c             	sub    $0xc,%esp
   12f7a:	6a 20                	push   $0x20
   12f7c:	e8 70 ff ff ff       	call   12ef1 <pic_send_eoi>
   12f81:	83 c4 10             	add    $0x10,%esp
    task_time_tick();
   12f84:	e8 78 e8 ff ff       	call   11801 <task_time_tick>

    
}
   12f89:	90                   	nop
   12f8a:	c9                   	leave  
   12f8b:	c3                   	ret    

00012f8c <init_pit>:
static void init_pit(void)
{
   12f8c:	55                   	push   %ebp
   12f8d:	89 e5                	mov    %esp,%ebp
   12f8f:	83 ec 18             	sub    $0x18,%esp
    uint32_t reload_count = (PIT_OSC_FREQ * OS_TICK_MS )/ 1000.0;
   12f92:	c7 45 f4 37 5d 00 00 	movl   $0x5d37,-0xc(%ebp)
    outb(PIT_COMMAND_MODE_PORT,PIT_CHANNEL | PIT_LOAD_LOHI | PIT_MODE3);
   12f99:	6a 36                	push   $0x36
   12f9b:	6a 43                	push   $0x43
   12f9d:	e8 a3 ff ff ff       	call   12f45 <outb>
   12fa2:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT,reload_count & 0xff);
   12fa5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12fa8:	0f b6 c0             	movzbl %al,%eax
   12fab:	50                   	push   %eax
   12fac:	6a 40                	push   $0x40
   12fae:	e8 92 ff ff ff       	call   12f45 <outb>
   12fb3:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT,(reload_count >> 8) & 0xff);
   12fb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12fb9:	c1 e8 08             	shr    $0x8,%eax
   12fbc:	0f b6 c0             	movzbl %al,%eax
   12fbf:	50                   	push   %eax
   12fc0:	6a 40                	push   $0x40
   12fc2:	e8 7e ff ff ff       	call   12f45 <outb>
   12fc7:	83 c4 08             	add    $0x8,%esp
    irq_install(IRQ0_TIMER,exception_handler_time);
   12fca:	83 ec 08             	sub    $0x8,%esp
   12fcd:	68 2b 00 01 00       	push   $0x1002b
   12fd2:	6a 20                	push   $0x20
   12fd4:	e8 ac fd ff ff       	call   12d85 <irq_install>
   12fd9:	83 c4 10             	add    $0x10,%esp

    irq_enable(IRQ0_TIMER);
   12fdc:	83 ec 0c             	sub    $0xc,%esp
   12fdf:	6a 20                	push   $0x20
   12fe1:	e8 df fd ff ff       	call   12dc5 <irq_enable>
   12fe6:	83 c4 10             	add    $0x10,%esp
}
   12fe9:	90                   	nop
   12fea:	c9                   	leave  
   12feb:	c3                   	ret    

00012fec <time_init>:
void time_init(void)
{
   12fec:	55                   	push   %ebp
   12fed:	89 e5                	mov    %esp,%ebp
   12fef:	83 ec 08             	sub    $0x8,%esp
    sys_tick = 0;
   12ff2:	c7 05 a0 10 02 00 00 	movl   $0x0,0x210a0
   12ff9:	00 00 00 
    init_pit();
   12ffc:	e8 8b ff ff ff       	call   12f8c <init_pit>
}
   13001:	90                   	nop
   13002:	c9                   	leave  
   13003:	c3                   	ret    

00013004 <inb>:
{
   13004:	55                   	push   %ebp
   13005:	89 e5                	mov    %esp,%ebp
   13007:	83 ec 14             	sub    $0x14,%esp
   1300a:	8b 45 08             	mov    0x8(%ebp),%eax
   1300d:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[p], %[v]":[v] "=a"(rv) : [p]"d"(port));
   13011:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   13015:	89 c2                	mov    %eax,%edx
   13017:	ec                   	in     (%dx),%al
   13018:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   1301b:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   1301f:	c9                   	leave  
   13020:	c3                   	ret    

00013021 <inw>:
{
   13021:	55                   	push   %ebp
   13022:	89 e5                	mov    %esp,%ebp
   13024:	83 ec 14             	sub    $0x14,%esp
   13027:	8b 45 08             	mov    0x8(%ebp),%eax
   1302a:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("in %[p], %[v]":[v] "=a"(rv) : [p]"d"(port));
   1302e:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   13032:	89 c2                	mov    %eax,%edx
   13034:	66 ed                	in     (%dx),%ax
   13036:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    return rv;
   1303a:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
   1303e:	c9                   	leave  
   1303f:	c3                   	ret    

00013040 <outb>:
{
   13040:	55                   	push   %ebp
   13041:	89 e5                	mov    %esp,%ebp
   13043:	83 ec 08             	sub    $0x8,%esp
   13046:	8b 55 08             	mov    0x8(%ebp),%edx
   13049:	8b 45 0c             	mov    0xc(%ebp),%eax
   1304c:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   13050:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]"::[p]"d"(port),[v]"a"(data));
   13053:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   13057:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   1305b:	ee                   	out    %al,(%dx)
}
   1305c:	90                   	nop
   1305d:	c9                   	leave  
   1305e:	c3                   	ret    

0001305f <read_disk>:
#include "comm/cpu_instr.h"
static uint8_t TEMP_ADDR[100 * 1024];
static uint8_t * temp_pos;
#define TEMP_FILE_ID 100
static void read_disk(uint32_t sector, uint32_t sector_count,uint8_t *buf)
{
   1305f:	55                   	push   %ebp
   13060:	89 e5                	mov    %esp,%ebp
   13062:	53                   	push   %ebx
   13063:	83 ec 10             	sub    $0x10,%esp
    outb(0x1f6, 0xe0);
   13066:	68 e0 00 00 00       	push   $0xe0
   1306b:	68 f6 01 00 00       	push   $0x1f6
   13070:	e8 cb ff ff ff       	call   13040 <outb>
   13075:	83 c4 08             	add    $0x8,%esp
    outb(0x1f2, (uint8_t)(sector_count >> 8));
   13078:	8b 45 0c             	mov    0xc(%ebp),%eax
   1307b:	c1 e8 08             	shr    $0x8,%eax
   1307e:	0f b6 c0             	movzbl %al,%eax
   13081:	50                   	push   %eax
   13082:	68 f2 01 00 00       	push   $0x1f2
   13087:	e8 b4 ff ff ff       	call   13040 <outb>
   1308c:	83 c4 08             	add    $0x8,%esp
    outb(0x1f3, (uint8_t)(sector >> 24));
   1308f:	8b 45 08             	mov    0x8(%ebp),%eax
   13092:	c1 e8 18             	shr    $0x18,%eax
   13095:	0f b6 c0             	movzbl %al,%eax
   13098:	50                   	push   %eax
   13099:	68 f3 01 00 00       	push   $0x1f3
   1309e:	e8 9d ff ff ff       	call   13040 <outb>
   130a3:	83 c4 08             	add    $0x8,%esp
    outb(0x1f4, 0);
   130a6:	6a 00                	push   $0x0
   130a8:	68 f4 01 00 00       	push   $0x1f4
   130ad:	e8 8e ff ff ff       	call   13040 <outb>
   130b2:	83 c4 08             	add    $0x8,%esp
    outb(0x1f5, 0);
   130b5:	6a 00                	push   $0x0
   130b7:	68 f5 01 00 00       	push   $0x1f5
   130bc:	e8 7f ff ff ff       	call   13040 <outb>
   130c1:	83 c4 08             	add    $0x8,%esp
    
    outb(0x1f2, (uint8_t)(sector_count));
   130c4:	8b 45 0c             	mov    0xc(%ebp),%eax
   130c7:	0f b6 c0             	movzbl %al,%eax
   130ca:	50                   	push   %eax
   130cb:	68 f2 01 00 00       	push   $0x1f2
   130d0:	e8 6b ff ff ff       	call   13040 <outb>
   130d5:	83 c4 08             	add    $0x8,%esp
    outb(0x1f3, (uint8_t)(sector));
   130d8:	8b 45 08             	mov    0x8(%ebp),%eax
   130db:	0f b6 c0             	movzbl %al,%eax
   130de:	50                   	push   %eax
   130df:	68 f3 01 00 00       	push   $0x1f3
   130e4:	e8 57 ff ff ff       	call   13040 <outb>
   130e9:	83 c4 08             	add    $0x8,%esp
    outb(0x1f4, (uint8_t)(sector >> 8));
   130ec:	8b 45 08             	mov    0x8(%ebp),%eax
   130ef:	c1 e8 08             	shr    $0x8,%eax
   130f2:	0f b6 c0             	movzbl %al,%eax
   130f5:	50                   	push   %eax
   130f6:	68 f4 01 00 00       	push   $0x1f4
   130fb:	e8 40 ff ff ff       	call   13040 <outb>
   13100:	83 c4 08             	add    $0x8,%esp
    outb(0x1f5, (uint8_t)(sector >> 16));
   13103:	8b 45 08             	mov    0x8(%ebp),%eax
   13106:	c1 e8 10             	shr    $0x10,%eax
   13109:	0f b6 c0             	movzbl %al,%eax
   1310c:	50                   	push   %eax
   1310d:	68 f5 01 00 00       	push   $0x1f5
   13112:	e8 29 ff ff ff       	call   13040 <outb>
   13117:	83 c4 08             	add    $0x8,%esp
   
   outb(0x1f7, 0x24);
   1311a:	6a 24                	push   $0x24
   1311c:	68 f7 01 00 00       	push   $0x1f7
   13121:	e8 1a ff ff ff       	call   13040 <outb>
   13126:	83 c4 08             	add    $0x8,%esp

   uint16_t * data_buf = (uint16_t *)buf;
   13129:	8b 45 10             	mov    0x10(%ebp),%eax
   1312c:	89 45 f8             	mov    %eax,-0x8(%ebp)
   while(sector_count--)
   1312f:	eb 48                	jmp    13179 <read_disk+0x11a>
   {
        while((inb(0x1f7) & 0x08) != 0x08);
   13131:	90                   	nop
   13132:	68 f7 01 00 00       	push   $0x1f7
   13137:	e8 c8 fe ff ff       	call   13004 <inb>
   1313c:	83 c4 04             	add    $0x4,%esp
   1313f:	0f b6 c0             	movzbl %al,%eax
   13142:	83 e0 08             	and    $0x8,%eax
   13145:	83 f8 08             	cmp    $0x8,%eax
   13148:	75 e8                	jne    13132 <read_disk+0xd3>
        for(int i = 0; i < SECTOR_SIZE / 2; i++)
   1314a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   13151:	eb 1d                	jmp    13170 <read_disk+0x111>
        {
            *data_buf++ = inw(0x1f0);
   13153:	8b 5d f8             	mov    -0x8(%ebp),%ebx
   13156:	8d 43 02             	lea    0x2(%ebx),%eax
   13159:	89 45 f8             	mov    %eax,-0x8(%ebp)
   1315c:	68 f0 01 00 00       	push   $0x1f0
   13161:	e8 bb fe ff ff       	call   13021 <inw>
   13166:	83 c4 04             	add    $0x4,%esp
   13169:	66 89 03             	mov    %ax,(%ebx)
        for(int i = 0; i < SECTOR_SIZE / 2; i++)
   1316c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   13170:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   13177:	7e da                	jle    13153 <read_disk+0xf4>
   while(sector_count--)
   13179:	8b 45 0c             	mov    0xc(%ebp),%eax
   1317c:	8d 50 ff             	lea    -0x1(%eax),%edx
   1317f:	89 55 0c             	mov    %edx,0xc(%ebp)
   13182:	85 c0                	test   %eax,%eax
   13184:	75 ab                	jne    13131 <read_disk+0xd2>
        }
   }
}
   13186:	90                   	nop
   13187:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1318a:	c9                   	leave  
   1318b:	c3                   	ret    

0001318c <sys_open>:
int sys_open(const char *name, int flags, ...)
{
   1318c:	55                   	push   %ebp
   1318d:	89 e5                	mov    %esp,%ebp
    if(name[0] == '/')
   1318f:	8b 45 08             	mov    0x8(%ebp),%eax
   13192:	0f b6 00             	movzbl (%eax),%eax
   13195:	3c 2f                	cmp    $0x2f,%al
   13197:	75 25                	jne    131be <sys_open+0x32>
    {
        read_disk(5000,80,(uint8_t *)TEMP_ADDR);
   13199:	68 c0 10 02 00       	push   $0x210c0
   1319e:	6a 50                	push   $0x50
   131a0:	68 88 13 00 00       	push   $0x1388
   131a5:	e8 b5 fe ff ff       	call   1305f <read_disk>
   131aa:	83 c4 0c             	add    $0xc,%esp
        temp_pos = TEMP_ADDR;
   131ad:	c7 05 c0 a0 03 00 c0 	movl   $0x210c0,0x3a0c0
   131b4:	10 02 00 
        return TEMP_FILE_ID;
   131b7:	b8 64 00 00 00       	mov    $0x64,%eax
   131bc:	eb 05                	jmp    131c3 <sys_open+0x37>
    }
    return -1;
   131be:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   131c3:	c9                   	leave  
   131c4:	c3                   	ret    

000131c5 <sys_read>:
int sys_read(int file, char *ptr, int len)
{
   131c5:	55                   	push   %ebp
   131c6:	89 e5                	mov    %esp,%ebp
   131c8:	83 ec 08             	sub    $0x8,%esp
    if(file == TEMP_FILE_ID)
   131cb:	83 7d 08 64          	cmpl   $0x64,0x8(%ebp)
   131cf:	75 2c                	jne    131fd <sys_read+0x38>
    {
        kernel_memcpy(ptr,temp_pos,len);
   131d1:	a1 c0 a0 03 00       	mov    0x3a0c0,%eax
   131d6:	83 ec 04             	sub    $0x4,%esp
   131d9:	ff 75 10             	pushl  0x10(%ebp)
   131dc:	50                   	push   %eax
   131dd:	ff 75 0c             	pushl  0xc(%ebp)
   131e0:	e8 b1 07 00 00       	call   13996 <kernel_memcpy>
   131e5:	83 c4 10             	add    $0x10,%esp
        temp_pos += len;
   131e8:	8b 15 c0 a0 03 00    	mov    0x3a0c0,%edx
   131ee:	8b 45 10             	mov    0x10(%ebp),%eax
   131f1:	01 d0                	add    %edx,%eax
   131f3:	a3 c0 a0 03 00       	mov    %eax,0x3a0c0
        return len;
   131f8:	8b 45 10             	mov    0x10(%ebp),%eax
   131fb:	eb 05                	jmp    13202 <sys_read+0x3d>
    }
    return -1;
   131fd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   13202:	c9                   	leave  
   13203:	c3                   	ret    

00013204 <sys_write>:
int sys_write(int file, char *ptr, int len)
{
   13204:	55                   	push   %ebp
   13205:	89 e5                	mov    %esp,%ebp
    return -1;
   13207:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   1320c:	5d                   	pop    %ebp
   1320d:	c3                   	ret    

0001320e <sys_lseek>:
int sys_lseek(int file, int offset, int dir)
{
   1320e:	55                   	push   %ebp
   1320f:	89 e5                	mov    %esp,%ebp
    if(file == TEMP_FILE_ID)
   13211:	83 7d 08 64          	cmpl   $0x64,0x8(%ebp)
   13215:	75 14                	jne    1322b <sys_lseek+0x1d>
    {
        temp_pos = (uint8_t *)(TEMP_ADDR + offset);
   13217:	8b 45 0c             	mov    0xc(%ebp),%eax
   1321a:	05 c0 10 02 00       	add    $0x210c0,%eax
   1321f:	a3 c0 a0 03 00       	mov    %eax,0x3a0c0
        return 0;
   13224:	b8 00 00 00 00       	mov    $0x0,%eax
   13229:	eb 05                	jmp    13230 <sys_lseek+0x22>
    }
    return -1;
   1322b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   13230:	5d                   	pop    %ebp
   13231:	c3                   	ret    

00013232 <sys_close>:
int sys_close(int file)
{
   13232:	55                   	push   %ebp
   13233:	89 e5                	mov    %esp,%ebp
    return 0; 
   13235:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1323a:	5d                   	pop    %ebp
   1323b:	c3                   	ret    

0001323c <kernel_init>:
#include "ipc/mutex.h"
#include "core/memory.h"
#include "dev/time.h"
#include "core/task.h"
void kernel_init(boot_info_t * boot_info)
{
   1323c:	55                   	push   %ebp
   1323d:	89 e5                	mov    %esp,%ebp
   1323f:	83 ec 08             	sub    $0x8,%esp
    //ASSERT(boot_info->ram_region_count != 2);
    cpu_init();
   13242:	e8 15 f3 ff ff       	call   1255c <cpu_init>
    log_init(); 
   13247:	e8 de 0d 00 00       	call   1402a <log_init>
    memory_init(boot_info);
   1324c:	83 ec 0c             	sub    $0xc,%esp
   1324f:	ff 75 08             	pushl  0x8(%ebp)
   13252:	e8 20 d8 ff ff       	call   10a77 <memory_init>
   13257:	83 c4 10             	add    $0x10,%esp
    
    irq_init();
   1325a:	e8 66 f9 ff ff       	call   12bc5 <irq_init>
    time_init();
   1325f:	e8 88 fd ff ff       	call   12fec <time_init>

    task_manager_init();
   13264:	e8 83 e2 ff ff       	call   114ec <task_manager_init>
}
   13269:	90                   	nop
   1326a:	c9                   	leave  
   1326b:	c3                   	ret    

0001326c <move_to_first_task>:
//         mutex_unlock(&mutex);
//     }
// }

void move_to_first_task(void)
{
   1326c:	55                   	push   %ebp
   1326d:	89 e5                	mov    %esp,%ebp
   1326f:	56                   	push   %esi
   13270:	53                   	push   %ebx
   13271:	83 ec 10             	sub    $0x10,%esp
    // void first_task_entry(void);
    // first_task_entry();
    task_t *curr = task_current();
   13274:	e8 55 e4 ff ff       	call   116ce <task_current>
   13279:	89 45 f4             	mov    %eax,-0xc(%ebp)
    tss_t *tss = &curr->tss;
   1327c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1327f:	83 c0 5c             	add    $0x5c,%eax
   13282:	89 45 f0             	mov    %eax,-0x10(%ebp)
    curr->task_type = TASK_KERNEL;
   13285:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13288:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    tss->cs = USER_SELECTOR_CS;
   1328f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13292:	c7 40 4c 1b 00 00 00 	movl   $0x1b,0x4c(%eax)
    tss->ss = USER_SELECTOR_DS;
   13299:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1329c:	c7 40 50 23 00 00 00 	movl   $0x23,0x50(%eax)
    tss->ds = USER_SELECTOR_DS;
   132a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   132a6:	c7 40 54 23 00 00 00 	movl   $0x23,0x54(%eax)
    tss->es = USER_SELECTOR_DS;
   132ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
   132b0:	c7 40 48 23 00 00 00 	movl   $0x23,0x48(%eax)
    tss->fs = USER_SELECTOR_DS;
   132b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   132ba:	c7 40 58 23 00 00 00 	movl   $0x23,0x58(%eax)
    tss->gs = USER_SELECTOR_DS;
   132c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   132c4:	c7 40 5c 23 00 00 00 	movl   $0x23,0x5c(%eax)
        "push %[ss]\n\t"			// SS
        "push %[esp]\n\t"			// ESP
        "push %[eflags]\n\t"           // EFLAGS
        "push %[cs]\n\t"			// CS
        "push %[eip]\n\t"		    // ip
        "iret\n\t"::[ss]"r"(USER_SELECTOR_DS),  [esp]"r"(tss->esp), [eflags]"r"(tss->eflags),
   132cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   132ce:	8b 40 38             	mov    0x38(%eax),%eax
   132d1:	8b 55 f0             	mov    -0x10(%ebp),%edx
   132d4:	8b 52 24             	mov    0x24(%edx),%edx
        [cs]"r"(USER_SELECTOR_CS), [eip]"r"(tss->eip));
   132d7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   132da:	8b 49 20             	mov    0x20(%ecx),%ecx
    __asm__ __volatile__(
   132dd:	bb 23 00 00 00       	mov    $0x23,%ebx
   132e2:	be 1b 00 00 00       	mov    $0x1b,%esi
   132e7:	53                   	push   %ebx
   132e8:	50                   	push   %eax
   132e9:	52                   	push   %edx
   132ea:	56                   	push   %esi
   132eb:	51                   	push   %ecx
   132ec:	cf                   	iret   
}
   132ed:	90                   	nop
   132ee:	83 c4 10             	add    $0x10,%esp
   132f1:	5b                   	pop    %ebx
   132f2:	5e                   	pop    %esi
   132f3:	5d                   	pop    %ebp
   132f4:	c3                   	ret    

000132f5 <init_main>:
void init_main(void)
{
   132f5:	55                   	push   %ebp
   132f6:	89 e5                	mov    %esp,%ebp
   132f8:	83 ec 08             	sub    $0x8,%esp
    irq_enable_global();
   132fb:	e8 e6 fb ff ff       	call   12ee6 <irq_enable_global>
    sem_init(&sem,0);
   13300:	83 ec 08             	sub    $0x8,%esp
   13303:	6a 00                	push   $0x0
   13305:	68 c4 a0 03 00       	push   $0x3a0c4
   1330a:	e8 ac 01 00 00       	call   134bb <sem_init>
   1330f:	83 c4 10             	add    $0x10,%esp
    log_printf("init main\n");
   13312:	83 ec 0c             	sub    $0xc,%esp
   13315:	68 4c 4a 01 00       	push   $0x14a4c
   1331a:	e8 a8 0d 00 00       	call   140c7 <log_printf>
   1331f:	83 c4 10             	add    $0x10,%esp
    //user_task_init(&init_task,"init_task",(uint32_t)init_task_entry,(uint32_t)&init_task_stack[1024]);
    // task_init(&test_task,"test_task",(uint32_t)test_task_entry,(uint32_t)&test_task_stack[1024]);
    task_first_init();
   13322:	e8 75 e2 ff ff       	call   1159c <task_first_init>
    move_to_first_task();
   13327:	e8 40 ff ff ff       	call   1326c <move_to_first_task>
    //     mutex_lock(&mutex);
    //     log_printf("init main count = %d\n", count++);
    //     sys_sleep(3000);
    //     mutex_unlock(&mutex);
    // }
}
   1332c:	90                   	nop
   1332d:	c9                   	leave  
   1332e:	c3                   	ret    

0001332f <list_count>:
{
   1332f:	55                   	push   %ebp
   13330:	89 e5                	mov    %esp,%ebp
    return list->count;
   13332:	8b 45 08             	mov    0x8(%ebp),%eax
   13335:	8b 40 08             	mov    0x8(%eax),%eax
}
   13338:	5d                   	pop    %ebp
   13339:	c3                   	ret    

0001333a <mutex_init>:
 */
#include "ipc/mutex.h"
#include "cpu/irq.h"

void mutex_init(mutex_t *mutex)
{
   1333a:	55                   	push   %ebp
   1333b:	89 e5                	mov    %esp,%ebp
   1333d:	83 ec 08             	sub    $0x8,%esp
    mutex->owner = (task_t *)0;
   13340:	8b 45 08             	mov    0x8(%ebp),%eax
   13343:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    mutex->locked_count = 0;
   1334a:	8b 45 08             	mov    0x8(%ebp),%eax
   1334d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    list_init(&mutex->wait_list);
   13354:	8b 45 08             	mov    0x8(%ebp),%eax
   13357:	83 ec 0c             	sub    $0xc,%esp
   1335a:	50                   	push   %eax
   1335b:	e8 ab 0a 00 00       	call   13e0b <list_init>
   13360:	83 c4 10             	add    $0x10,%esp
}
   13363:	90                   	nop
   13364:	c9                   	leave  
   13365:	c3                   	ret    

00013366 <mutex_lock>:

void mutex_lock(mutex_t *mutex)
{
   13366:	55                   	push   %ebp
   13367:	89 e5                	mov    %esp,%ebp
   13369:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   1336c:	e8 ab fb ff ff       	call   12f1c <irq_enter_protection>
   13371:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t *curr = task_current();
   13374:	e8 55 e3 ff ff       	call   116ce <task_current>
   13379:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(mutex->locked_count == 0)
   1337c:	8b 45 08             	mov    0x8(%ebp),%eax
   1337f:	8b 40 10             	mov    0x10(%eax),%eax
   13382:	85 c0                	test   %eax,%eax
   13384:	75 1a                	jne    133a0 <mutex_lock+0x3a>
    {
        mutex->locked_count++;
   13386:	8b 45 08             	mov    0x8(%ebp),%eax
   13389:	8b 40 10             	mov    0x10(%eax),%eax
   1338c:	8d 50 01             	lea    0x1(%eax),%edx
   1338f:	8b 45 08             	mov    0x8(%ebp),%eax
   13392:	89 50 10             	mov    %edx,0x10(%eax)
        mutex->owner = curr;
   13395:	8b 45 08             	mov    0x8(%ebp),%eax
   13398:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1339b:	89 50 0c             	mov    %edx,0xc(%eax)
   1339e:	eb 45                	jmp    133e5 <mutex_lock+0x7f>
    }else if(mutex->owner == curr)
   133a0:	8b 45 08             	mov    0x8(%ebp),%eax
   133a3:	8b 40 0c             	mov    0xc(%eax),%eax
   133a6:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   133a9:	75 11                	jne    133bc <mutex_lock+0x56>
    {
        mutex->locked_count++;
   133ab:	8b 45 08             	mov    0x8(%ebp),%eax
   133ae:	8b 40 10             	mov    0x10(%eax),%eax
   133b1:	8d 50 01             	lea    0x1(%eax),%edx
   133b4:	8b 45 08             	mov    0x8(%ebp),%eax
   133b7:	89 50 10             	mov    %edx,0x10(%eax)
   133ba:	eb 29                	jmp    133e5 <mutex_lock+0x7f>
    }else
    {
        task_set_block(curr);
   133bc:	83 ec 0c             	sub    $0xc,%esp
   133bf:	ff 75 f0             	pushl  -0x10(%ebp)
   133c2:	e8 dc e2 ff ff       	call   116a3 <task_set_block>
   133c7:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&mutex->wait_list,&curr->wait_node);
   133ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
   133cd:	8d 50 50             	lea    0x50(%eax),%edx
   133d0:	8b 45 08             	mov    0x8(%ebp),%eax
   133d3:	83 ec 08             	sub    $0x8,%esp
   133d6:	52                   	push   %edx
   133d7:	50                   	push   %eax
   133d8:	e8 b2 0a 00 00       	call   13e8f <list_insert_last>
   133dd:	83 c4 10             	add    $0x10,%esp
        schedule_switch();
   133e0:	e8 a4 e3 ff ff       	call   11789 <schedule_switch>
    }
    irq_leave_protection(state);
   133e5:	83 ec 0c             	sub    $0xc,%esp
   133e8:	ff 75 f4             	pushl  -0xc(%ebp)
   133eb:	e8 44 fb ff ff       	call   12f34 <irq_leave_protection>
   133f0:	83 c4 10             	add    $0x10,%esp
}
   133f3:	90                   	nop
   133f4:	c9                   	leave  
   133f5:	c3                   	ret    

000133f6 <mutex_unlock>:

void mutex_unlock(mutex_t *mutex)
{
   133f6:	55                   	push   %ebp
   133f7:	89 e5                	mov    %esp,%ebp
   133f9:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   133fc:	e8 1b fb ff ff       	call   12f1c <irq_enter_protection>
   13401:	89 45 f4             	mov    %eax,-0xc(%ebp)

    task_t * curr = task_current();
   13404:	e8 c5 e2 ff ff       	call   116ce <task_current>
   13409:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(mutex->owner == curr)
   1340c:	8b 45 08             	mov    0x8(%ebp),%eax
   1340f:	8b 40 0c             	mov    0xc(%eax),%eax
   13412:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   13415:	0f 85 84 00 00 00    	jne    1349f <mutex_unlock+0xa9>
    {
        if(--mutex->locked_count == 0)
   1341b:	8b 45 08             	mov    0x8(%ebp),%eax
   1341e:	8b 40 10             	mov    0x10(%eax),%eax
   13421:	8d 50 ff             	lea    -0x1(%eax),%edx
   13424:	8b 45 08             	mov    0x8(%ebp),%eax
   13427:	89 50 10             	mov    %edx,0x10(%eax)
   1342a:	8b 45 08             	mov    0x8(%ebp),%eax
   1342d:	8b 40 10             	mov    0x10(%eax),%eax
   13430:	85 c0                	test   %eax,%eax
   13432:	75 6b                	jne    1349f <mutex_unlock+0xa9>
        {
            mutex->owner = (task_t *)0;
   13434:	8b 45 08             	mov    0x8(%ebp),%eax
   13437:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
            if(list_count(&mutex->wait_list))
   1343e:	8b 45 08             	mov    0x8(%ebp),%eax
   13441:	83 ec 0c             	sub    $0xc,%esp
   13444:	50                   	push   %eax
   13445:	e8 e5 fe ff ff       	call   1332f <list_count>
   1344a:	83 c4 10             	add    $0x10,%esp
   1344d:	85 c0                	test   %eax,%eax
   1344f:	74 4e                	je     1349f <mutex_unlock+0xa9>
            {
                list_node_t * node = list_remove_first(&mutex->wait_list);
   13451:	8b 45 08             	mov    0x8(%ebp),%eax
   13454:	83 ec 0c             	sub    $0xc,%esp
   13457:	50                   	push   %eax
   13458:	e8 96 0a 00 00       	call   13ef3 <list_remove_first>
   1345d:	83 c4 10             	add    $0x10,%esp
   13460:	89 45 ec             	mov    %eax,-0x14(%ebp)
                task_t * task = list_node_parent(node,task_t,wait_node);
   13463:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   13467:	74 08                	je     13471 <mutex_unlock+0x7b>
   13469:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1346c:	83 e8 50             	sub    $0x50,%eax
   1346f:	eb 05                	jmp    13476 <mutex_unlock+0x80>
   13471:	b8 00 00 00 00       	mov    $0x0,%eax
   13476:	89 45 e8             	mov    %eax,-0x18(%ebp)
                task_set_ready(task);
   13479:	83 ec 0c             	sub    $0xc,%esp
   1347c:	ff 75 e8             	pushl  -0x18(%ebp)
   1347f:	e8 ea e1 ff ff       	call   1166e <task_set_ready>
   13484:	83 c4 10             	add    $0x10,%esp
                mutex->locked_count = 1;
   13487:	8b 45 08             	mov    0x8(%ebp),%eax
   1348a:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
                mutex->owner = task;
   13491:	8b 45 08             	mov    0x8(%ebp),%eax
   13494:	8b 55 e8             	mov    -0x18(%ebp),%edx
   13497:	89 50 0c             	mov    %edx,0xc(%eax)
                schedule_switch();
   1349a:	e8 ea e2 ff ff       	call   11789 <schedule_switch>
            }
        }
    }
    irq_leave_protection(state);
   1349f:	83 ec 0c             	sub    $0xc,%esp
   134a2:	ff 75 f4             	pushl  -0xc(%ebp)
   134a5:	e8 8a fa ff ff       	call   12f34 <irq_leave_protection>
   134aa:	83 c4 10             	add    $0x10,%esp
}
   134ad:	90                   	nop
   134ae:	c9                   	leave  
   134af:	c3                   	ret    

000134b0 <list_count>:
{
   134b0:	55                   	push   %ebp
   134b1:	89 e5                	mov    %esp,%ebp
    return list->count;
   134b3:	8b 45 08             	mov    0x8(%ebp),%eax
   134b6:	8b 40 08             	mov    0x8(%eax),%eax
}
   134b9:	5d                   	pop    %ebp
   134ba:	c3                   	ret    

000134bb <sem_init>:
#include "ipc/sem.h"
#include "core/task.h"
#include "cpu/irq.h"
void sem_init(sem_t *sem,int count)
{
   134bb:	55                   	push   %ebp
   134bc:	89 e5                	mov    %esp,%ebp
   134be:	83 ec 08             	sub    $0x8,%esp
    sem->count = count;
   134c1:	8b 45 08             	mov    0x8(%ebp),%eax
   134c4:	8b 55 0c             	mov    0xc(%ebp),%edx
   134c7:	89 10                	mov    %edx,(%eax)
    list_init(&sem->wait_list);
   134c9:	8b 45 08             	mov    0x8(%ebp),%eax
   134cc:	83 c0 04             	add    $0x4,%eax
   134cf:	83 ec 0c             	sub    $0xc,%esp
   134d2:	50                   	push   %eax
   134d3:	e8 33 09 00 00       	call   13e0b <list_init>
   134d8:	83 c4 10             	add    $0x10,%esp
}
   134db:	90                   	nop
   134dc:	c9                   	leave  
   134dd:	c3                   	ret    

000134de <sem_wait>:

void sem_wait(sem_t *sem)
{
   134de:	55                   	push   %ebp
   134df:	89 e5                	mov    %esp,%ebp
   134e1:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   134e4:	e8 33 fa ff ff       	call   12f1c <irq_enter_protection>
   134e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(sem->count > 0)
   134ec:	8b 45 08             	mov    0x8(%ebp),%eax
   134ef:	8b 00                	mov    (%eax),%eax
   134f1:	85 c0                	test   %eax,%eax
   134f3:	7e 0f                	jle    13504 <sem_wait+0x26>
    {
        sem->count--;
   134f5:	8b 45 08             	mov    0x8(%ebp),%eax
   134f8:	8b 00                	mov    (%eax),%eax
   134fa:	8d 50 ff             	lea    -0x1(%eax),%edx
   134fd:	8b 45 08             	mov    0x8(%ebp),%eax
   13500:	89 10                	mov    %edx,(%eax)
   13502:	eb 34                	jmp    13538 <sem_wait+0x5a>
    }
    else
    {
        task_t *curr = task_current();
   13504:	e8 c5 e1 ff ff       	call   116ce <task_current>
   13509:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_set_block(curr);
   1350c:	83 ec 0c             	sub    $0xc,%esp
   1350f:	ff 75 f0             	pushl  -0x10(%ebp)
   13512:	e8 8c e1 ff ff       	call   116a3 <task_set_block>
   13517:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&sem->wait_list,&curr->wait_node);
   1351a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1351d:	8d 50 50             	lea    0x50(%eax),%edx
   13520:	8b 45 08             	mov    0x8(%ebp),%eax
   13523:	83 c0 04             	add    $0x4,%eax
   13526:	83 ec 08             	sub    $0x8,%esp
   13529:	52                   	push   %edx
   1352a:	50                   	push   %eax
   1352b:	e8 5f 09 00 00       	call   13e8f <list_insert_last>
   13530:	83 c4 10             	add    $0x10,%esp
        schedule_switch();
   13533:	e8 51 e2 ff ff       	call   11789 <schedule_switch>
    }
    irq_leave_protection(state);
   13538:	83 ec 0c             	sub    $0xc,%esp
   1353b:	ff 75 f4             	pushl  -0xc(%ebp)
   1353e:	e8 f1 f9 ff ff       	call   12f34 <irq_leave_protection>
   13543:	83 c4 10             	add    $0x10,%esp
}
   13546:	90                   	nop
   13547:	c9                   	leave  
   13548:	c3                   	ret    

00013549 <sem_notify>:


void sem_notify(sem_t *sem)
{
   13549:	55                   	push   %ebp
   1354a:	89 e5                	mov    %esp,%ebp
   1354c:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   1354f:	e8 c8 f9 ff ff       	call   12f1c <irq_enter_protection>
   13554:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(list_count(&sem->wait_list) > 0)
   13557:	8b 45 08             	mov    0x8(%ebp),%eax
   1355a:	83 c0 04             	add    $0x4,%eax
   1355d:	83 ec 0c             	sub    $0xc,%esp
   13560:	50                   	push   %eax
   13561:	e8 4a ff ff ff       	call   134b0 <list_count>
   13566:	83 c4 10             	add    $0x10,%esp
   13569:	85 c0                	test   %eax,%eax
   1356b:	7e 40                	jle    135ad <sem_notify+0x64>
    {
        list_node_t * node = list_remove_first(&sem->wait_list);
   1356d:	8b 45 08             	mov    0x8(%ebp),%eax
   13570:	83 c0 04             	add    $0x4,%eax
   13573:	83 ec 0c             	sub    $0xc,%esp
   13576:	50                   	push   %eax
   13577:	e8 77 09 00 00       	call   13ef3 <list_remove_first>
   1357c:	83 c4 10             	add    $0x10,%esp
   1357f:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_t *task = list_node_parent(node,task_t,wait_node);
   13582:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   13586:	74 08                	je     13590 <sem_notify+0x47>
   13588:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1358b:	83 e8 50             	sub    $0x50,%eax
   1358e:	eb 05                	jmp    13595 <sem_notify+0x4c>
   13590:	b8 00 00 00 00       	mov    $0x0,%eax
   13595:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_set_ready(task);
   13598:	83 ec 0c             	sub    $0xc,%esp
   1359b:	ff 75 ec             	pushl  -0x14(%ebp)
   1359e:	e8 cb e0 ff ff       	call   1166e <task_set_ready>
   135a3:	83 c4 10             	add    $0x10,%esp
        schedule_switch();
   135a6:	e8 de e1 ff ff       	call   11789 <schedule_switch>
   135ab:	eb 0d                	jmp    135ba <sem_notify+0x71>
    }
    else
    {
        sem->count++;
   135ad:	8b 45 08             	mov    0x8(%ebp),%eax
   135b0:	8b 00                	mov    (%eax),%eax
   135b2:	8d 50 01             	lea    0x1(%eax),%edx
   135b5:	8b 45 08             	mov    0x8(%ebp),%eax
   135b8:	89 10                	mov    %edx,(%eax)
    }
    irq_leave_protection(state);
   135ba:	83 ec 0c             	sub    $0xc,%esp
   135bd:	ff 75 f4             	pushl  -0xc(%ebp)
   135c0:	e8 6f f9 ff ff       	call   12f34 <irq_leave_protection>
   135c5:	83 c4 10             	add    $0x10,%esp
}
   135c8:	90                   	nop
   135c9:	c9                   	leave  
   135ca:	c3                   	ret    

000135cb <sem_count>:
int sem_count(sem_t *sem)
{
   135cb:	55                   	push   %ebp
   135cc:	89 e5                	mov    %esp,%ebp
   135ce:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   135d1:	e8 46 f9 ff ff       	call   12f1c <irq_enter_protection>
   135d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int count = sem->count;
   135d9:	8b 45 08             	mov    0x8(%ebp),%eax
   135dc:	8b 00                	mov    (%eax),%eax
   135de:	89 45 f0             	mov    %eax,-0x10(%ebp)
    irq_leave_protection(state);
   135e1:	83 ec 0c             	sub    $0xc,%esp
   135e4:	ff 75 f4             	pushl  -0xc(%ebp)
   135e7:	e8 48 f9 ff ff       	call   12f34 <irq_leave_protection>
   135ec:	83 c4 10             	add    $0x10,%esp
    return count;
   135ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   135f2:	c9                   	leave  
   135f3:	c3                   	ret    

000135f4 <bitmap_byte_count>:
#include "tools/bitmap.h"
#include "tools/klib.h"

int bitmap_byte_count(int bit_count)
{
   135f4:	55                   	push   %ebp
   135f5:	89 e5                	mov    %esp,%ebp
    return (bit_count + 7) / 8;
   135f7:	8b 45 08             	mov    0x8(%ebp),%eax
   135fa:	83 c0 07             	add    $0x7,%eax
   135fd:	8d 50 07             	lea    0x7(%eax),%edx
   13600:	85 c0                	test   %eax,%eax
   13602:	0f 48 c2             	cmovs  %edx,%eax
   13605:	c1 f8 03             	sar    $0x3,%eax
}
   13608:	5d                   	pop    %ebp
   13609:	c3                   	ret    

0001360a <bitmap_init>:
void bitmap_init(bitmap_t *bitmap, uint8_t *bits, int count ,int init_bit)
{
   1360a:	55                   	push   %ebp
   1360b:	89 e5                	mov    %esp,%ebp
   1360d:	83 ec 18             	sub    $0x18,%esp
    bitmap->bit_count = count;
   13610:	8b 45 08             	mov    0x8(%ebp),%eax
   13613:	8b 55 10             	mov    0x10(%ebp),%edx
   13616:	89 10                	mov    %edx,(%eax)
    bitmap->bits = bits;
   13618:	8b 45 08             	mov    0x8(%ebp),%eax
   1361b:	8b 55 0c             	mov    0xc(%ebp),%edx
   1361e:	89 50 04             	mov    %edx,0x4(%eax)
    int bytes = bitmap_byte_count(count);
   13621:	ff 75 10             	pushl  0x10(%ebp)
   13624:	e8 cb ff ff ff       	call   135f4 <bitmap_byte_count>
   13629:	83 c4 04             	add    $0x4,%esp
   1362c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kernel_memset(bits, init_bit ? 0xff : 0x00, bytes);
   1362f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   13633:	74 07                	je     1363c <bitmap_init+0x32>
   13635:	b8 ff 00 00 00       	mov    $0xff,%eax
   1363a:	eb 05                	jmp    13641 <bitmap_init+0x37>
   1363c:	b8 00 00 00 00       	mov    $0x0,%eax
   13641:	83 ec 04             	sub    $0x4,%esp
   13644:	ff 75 f4             	pushl  -0xc(%ebp)
   13647:	50                   	push   %eax
   13648:	ff 75 0c             	pushl  0xc(%ebp)
   1364b:	e8 95 03 00 00       	call   139e5 <kernel_memset>
   13650:	83 c4 10             	add    $0x10,%esp
}
   13653:	90                   	nop
   13654:	c9                   	leave  
   13655:	c3                   	ret    

00013656 <bitmap_get_bit>:

int bitmap_get_bit(bitmap_t *bitmap, int index)
{
   13656:	55                   	push   %ebp
   13657:	89 e5                	mov    %esp,%ebp
   13659:	53                   	push   %ebx
    return bitmap->bits[index / 8] & (1 << (index % 8));
   1365a:	8b 45 08             	mov    0x8(%ebp),%eax
   1365d:	8b 50 04             	mov    0x4(%eax),%edx
   13660:	8b 45 0c             	mov    0xc(%ebp),%eax
   13663:	8d 48 07             	lea    0x7(%eax),%ecx
   13666:	85 c0                	test   %eax,%eax
   13668:	0f 48 c1             	cmovs  %ecx,%eax
   1366b:	c1 f8 03             	sar    $0x3,%eax
   1366e:	01 d0                	add    %edx,%eax
   13670:	0f b6 00             	movzbl (%eax),%eax
   13673:	0f b6 d8             	movzbl %al,%ebx
   13676:	8b 45 0c             	mov    0xc(%ebp),%eax
   13679:	99                   	cltd   
   1367a:	c1 ea 1d             	shr    $0x1d,%edx
   1367d:	01 d0                	add    %edx,%eax
   1367f:	83 e0 07             	and    $0x7,%eax
   13682:	29 d0                	sub    %edx,%eax
   13684:	ba 01 00 00 00       	mov    $0x1,%edx
   13689:	89 c1                	mov    %eax,%ecx
   1368b:	d3 e2                	shl    %cl,%edx
   1368d:	89 d0                	mov    %edx,%eax
   1368f:	21 d8                	and    %ebx,%eax
}
   13691:	5b                   	pop    %ebx
   13692:	5d                   	pop    %ebp
   13693:	c3                   	ret    

00013694 <bitmap_set_bit>:
void bitmap_set_bit(bitmap_t *bitmap, int index, int count,int bit)
{
   13694:	55                   	push   %ebp
   13695:	89 e5                	mov    %esp,%ebp
   13697:	56                   	push   %esi
   13698:	53                   	push   %ebx
   13699:	83 ec 10             	sub    $0x10,%esp
    for(int i = 0; (i < count) && (index < bitmap->bit_count); i++)
   1369c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   136a3:	e9 a2 00 00 00       	jmp    1374a <bitmap_set_bit+0xb6>
    {
        if(bit)
   136a8:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   136ac:	74 4a                	je     136f8 <bitmap_set_bit+0x64>
        {
            bitmap->bits[index / 8] |= (1 << (index % 8));
   136ae:	8b 45 08             	mov    0x8(%ebp),%eax
   136b1:	8b 50 04             	mov    0x4(%eax),%edx
   136b4:	8b 45 0c             	mov    0xc(%ebp),%eax
   136b7:	8d 48 07             	lea    0x7(%eax),%ecx
   136ba:	85 c0                	test   %eax,%eax
   136bc:	0f 48 c1             	cmovs  %ecx,%eax
   136bf:	c1 f8 03             	sar    $0x3,%eax
   136c2:	89 c3                	mov    %eax,%ebx
   136c4:	89 d8                	mov    %ebx,%eax
   136c6:	01 d0                	add    %edx,%eax
   136c8:	0f b6 00             	movzbl (%eax),%eax
   136cb:	89 c6                	mov    %eax,%esi
   136cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   136d0:	99                   	cltd   
   136d1:	c1 ea 1d             	shr    $0x1d,%edx
   136d4:	01 d0                	add    %edx,%eax
   136d6:	83 e0 07             	and    $0x7,%eax
   136d9:	29 d0                	sub    %edx,%eax
   136db:	ba 01 00 00 00       	mov    $0x1,%edx
   136e0:	89 c1                	mov    %eax,%ecx
   136e2:	d3 e2                	shl    %cl,%edx
   136e4:	89 d0                	mov    %edx,%eax
   136e6:	89 f2                	mov    %esi,%edx
   136e8:	09 c2                	or     %eax,%edx
   136ea:	8b 45 08             	mov    0x8(%ebp),%eax
   136ed:	8b 40 04             	mov    0x4(%eax),%eax
   136f0:	89 d9                	mov    %ebx,%ecx
   136f2:	01 c8                	add    %ecx,%eax
   136f4:	88 10                	mov    %dl,(%eax)
   136f6:	eb 4a                	jmp    13742 <bitmap_set_bit+0xae>
        }
        else
        {
            bitmap->bits[index / 8] &= ~(1 << (index % 8));
   136f8:	8b 45 08             	mov    0x8(%ebp),%eax
   136fb:	8b 50 04             	mov    0x4(%eax),%edx
   136fe:	8b 45 0c             	mov    0xc(%ebp),%eax
   13701:	8d 48 07             	lea    0x7(%eax),%ecx
   13704:	85 c0                	test   %eax,%eax
   13706:	0f 48 c1             	cmovs  %ecx,%eax
   13709:	c1 f8 03             	sar    $0x3,%eax
   1370c:	89 c3                	mov    %eax,%ebx
   1370e:	89 d8                	mov    %ebx,%eax
   13710:	01 d0                	add    %edx,%eax
   13712:	0f b6 00             	movzbl (%eax),%eax
   13715:	89 c6                	mov    %eax,%esi
   13717:	8b 45 0c             	mov    0xc(%ebp),%eax
   1371a:	99                   	cltd   
   1371b:	c1 ea 1d             	shr    $0x1d,%edx
   1371e:	01 d0                	add    %edx,%eax
   13720:	83 e0 07             	and    $0x7,%eax
   13723:	29 d0                	sub    %edx,%eax
   13725:	ba 01 00 00 00       	mov    $0x1,%edx
   1372a:	89 c1                	mov    %eax,%ecx
   1372c:	d3 e2                	shl    %cl,%edx
   1372e:	89 d0                	mov    %edx,%eax
   13730:	f7 d0                	not    %eax
   13732:	89 f2                	mov    %esi,%edx
   13734:	21 c2                	and    %eax,%edx
   13736:	8b 45 08             	mov    0x8(%ebp),%eax
   13739:	8b 40 04             	mov    0x4(%eax),%eax
   1373c:	89 d9                	mov    %ebx,%ecx
   1373e:	01 c8                	add    %ecx,%eax
   13740:	88 10                	mov    %dl,(%eax)
        }
        index++;
   13742:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
    for(int i = 0; (i < count) && (index < bitmap->bit_count); i++)
   13746:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1374a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1374d:	3b 45 10             	cmp    0x10(%ebp),%eax
   13750:	7d 0e                	jge    13760 <bitmap_set_bit+0xcc>
   13752:	8b 45 08             	mov    0x8(%ebp),%eax
   13755:	8b 00                	mov    (%eax),%eax
   13757:	39 45 0c             	cmp    %eax,0xc(%ebp)
   1375a:	0f 8c 48 ff ff ff    	jl     136a8 <bitmap_set_bit+0x14>
    }
}
   13760:	90                   	nop
   13761:	83 c4 10             	add    $0x10,%esp
   13764:	5b                   	pop    %ebx
   13765:	5e                   	pop    %esi
   13766:	5d                   	pop    %ebp
   13767:	c3                   	ret    

00013768 <bitmap_is_set>:
int bitmap_is_set(bitmap_t *bitmap, int index)
{
   13768:	55                   	push   %ebp
   13769:	89 e5                	mov    %esp,%ebp
    return bitmap_get_bit(bitmap, index) ? 1 : 0;
   1376b:	ff 75 0c             	pushl  0xc(%ebp)
   1376e:	ff 75 08             	pushl  0x8(%ebp)
   13771:	e8 e0 fe ff ff       	call   13656 <bitmap_get_bit>
   13776:	83 c4 08             	add    $0x8,%esp
   13779:	85 c0                	test   %eax,%eax
   1377b:	0f 95 c0             	setne  %al
   1377e:	0f b6 c0             	movzbl %al,%eax
}
   13781:	c9                   	leave  
   13782:	c3                   	ret    

00013783 <bitmap_alloc_nbits>:
int bitmap_alloc_nbits(bitmap_t *bitmap, int bit, int count)
{
   13783:	55                   	push   %ebp
   13784:	89 e5                	mov    %esp,%ebp
   13786:	83 ec 10             	sub    $0x10,%esp
    int index = 0;
   13789:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    int ok_index = -1;
   13790:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
    while(index < bitmap->bit_count)
   13797:	e9 8c 00 00 00       	jmp    13828 <bitmap_alloc_nbits+0xa5>
    {
        if(bitmap_get_bit(bitmap, index) != bit)
   1379c:	ff 75 fc             	pushl  -0x4(%ebp)
   1379f:	ff 75 08             	pushl  0x8(%ebp)
   137a2:	e8 af fe ff ff       	call   13656 <bitmap_get_bit>
   137a7:	83 c4 08             	add    $0x8,%esp
   137aa:	39 45 0c             	cmp    %eax,0xc(%ebp)
   137ad:	74 06                	je     137b5 <bitmap_alloc_nbits+0x32>
        {
            index++;
   137af:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
            continue;
   137b3:	eb 73                	jmp    13828 <bitmap_alloc_nbits+0xa5>
        }
        ok_index = index;
   137b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   137b8:	89 45 f8             	mov    %eax,-0x8(%ebp)
        int i = 0;
   137bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        for(i = 0; (i < count) && (index  < bitmap->bit_count); i++)
   137c2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   137c9:	eb 27                	jmp    137f2 <bitmap_alloc_nbits+0x6f>
        {
            if(bitmap_get_bit(bitmap, index++) != bit)
   137cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   137ce:	8d 50 01             	lea    0x1(%eax),%edx
   137d1:	89 55 fc             	mov    %edx,-0x4(%ebp)
   137d4:	50                   	push   %eax
   137d5:	ff 75 08             	pushl  0x8(%ebp)
   137d8:	e8 79 fe ff ff       	call   13656 <bitmap_get_bit>
   137dd:	83 c4 08             	add    $0x8,%esp
   137e0:	39 45 0c             	cmp    %eax,0xc(%ebp)
   137e3:	74 09                	je     137ee <bitmap_alloc_nbits+0x6b>
            {
                ok_index = -1;
   137e5:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
                break;
   137ec:	eb 16                	jmp    13804 <bitmap_alloc_nbits+0x81>
        for(i = 0; (i < count) && (index  < bitmap->bit_count); i++)
   137ee:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   137f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   137f5:	3b 45 10             	cmp    0x10(%ebp),%eax
   137f8:	7d 0a                	jge    13804 <bitmap_alloc_nbits+0x81>
   137fa:	8b 45 08             	mov    0x8(%ebp),%eax
   137fd:	8b 00                	mov    (%eax),%eax
   137ff:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   13802:	7c c7                	jl     137cb <bitmap_alloc_nbits+0x48>
            }
        }
        if(i >= count)
   13804:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13807:	3b 45 10             	cmp    0x10(%ebp),%eax
   1380a:	7c 1c                	jl     13828 <bitmap_alloc_nbits+0xa5>
        {
            bitmap_set_bit(bitmap, ok_index, count, ~bit);
   1380c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1380f:	f7 d0                	not    %eax
   13811:	50                   	push   %eax
   13812:	ff 75 10             	pushl  0x10(%ebp)
   13815:	ff 75 f8             	pushl  -0x8(%ebp)
   13818:	ff 75 08             	pushl  0x8(%ebp)
   1381b:	e8 74 fe ff ff       	call   13694 <bitmap_set_bit>
   13820:	83 c4 10             	add    $0x10,%esp
            return ok_index;
   13823:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13826:	eb 13                	jmp    1383b <bitmap_alloc_nbits+0xb8>
    while(index < bitmap->bit_count)
   13828:	8b 45 08             	mov    0x8(%ebp),%eax
   1382b:	8b 00                	mov    (%eax),%eax
   1382d:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   13830:	0f 8c 66 ff ff ff    	jl     1379c <bitmap_alloc_nbits+0x19>
        }
    }        
    return -1;
   13836:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1383b:	c9                   	leave  
   1383c:	c3                   	ret    

0001383d <hlt>:
{
   1383d:	55                   	push   %ebp
   1383e:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   13840:	f4                   	hlt    
}
   13841:	90                   	nop
   13842:	5d                   	pop    %ebp
   13843:	c3                   	ret    

00013844 <kernel_strcpy>:
#include "tools/klib.h"
#include "comm/types.h"
#include "comm/cpu_instr.h"
void kernel_strcpy (char *dest, const char *src)
{
   13844:	55                   	push   %ebp
   13845:	89 e5                	mov    %esp,%ebp
    if(!dest || !src)
   13847:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1384b:	74 27                	je     13874 <kernel_strcpy+0x30>
   1384d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   13851:	74 21                	je     13874 <kernel_strcpy+0x30>
    {
        return;
    }
    while((*dest++ = *src++) != '\0');
   13853:	90                   	nop
   13854:	8b 55 0c             	mov    0xc(%ebp),%edx
   13857:	8d 42 01             	lea    0x1(%edx),%eax
   1385a:	89 45 0c             	mov    %eax,0xc(%ebp)
   1385d:	8b 45 08             	mov    0x8(%ebp),%eax
   13860:	8d 48 01             	lea    0x1(%eax),%ecx
   13863:	89 4d 08             	mov    %ecx,0x8(%ebp)
   13866:	0f b6 12             	movzbl (%edx),%edx
   13869:	88 10                	mov    %dl,(%eax)
   1386b:	0f b6 00             	movzbl (%eax),%eax
   1386e:	84 c0                	test   %al,%al
   13870:	75 e2                	jne    13854 <kernel_strcpy+0x10>
   13872:	eb 01                	jmp    13875 <kernel_strcpy+0x31>
        return;
   13874:	90                   	nop
    //*dest = '\0';
}
   13875:	5d                   	pop    %ebp
   13876:	c3                   	ret    

00013877 <kernel_strncpy>:

void kernel_strncpy (char *dest, const char *src, int size)
{
   13877:	55                   	push   %ebp
   13878:	89 e5                	mov    %esp,%ebp
   1387a:	83 ec 10             	sub    $0x10,%esp
    if(!dest || !src)
   1387d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13881:	74 5b                	je     138de <kernel_strncpy+0x67>
   13883:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   13887:	74 55                	je     138de <kernel_strncpy+0x67>
    {
        return;
    }
    char *d = dest;
   13889:	8b 45 08             	mov    0x8(%ebp),%eax
   1388c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    const char *s = src;
   1388f:	8b 45 0c             	mov    0xc(%ebp),%eax
   13892:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(size-- > 0 && (*s))
   13895:	eb 17                	jmp    138ae <kernel_strncpy+0x37>
    {
        *d++ = *s++;
   13897:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1389a:	8d 42 01             	lea    0x1(%edx),%eax
   1389d:	89 45 f8             	mov    %eax,-0x8(%ebp)
   138a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   138a3:	8d 48 01             	lea    0x1(%eax),%ecx
   138a6:	89 4d fc             	mov    %ecx,-0x4(%ebp)
   138a9:	0f b6 12             	movzbl (%edx),%edx
   138ac:	88 10                	mov    %dl,(%eax)
    while(size-- > 0 && (*s))
   138ae:	8b 45 10             	mov    0x10(%ebp),%eax
   138b1:	8d 50 ff             	lea    -0x1(%eax),%edx
   138b4:	89 55 10             	mov    %edx,0x10(%ebp)
   138b7:	85 c0                	test   %eax,%eax
   138b9:	7e 0a                	jle    138c5 <kernel_strncpy+0x4e>
   138bb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   138be:	0f b6 00             	movzbl (%eax),%eax
   138c1:	84 c0                	test   %al,%al
   138c3:	75 d2                	jne    13897 <kernel_strncpy+0x20>
    }
    if(size == 0)
   138c5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   138c9:	75 0b                	jne    138d6 <kernel_strncpy+0x5f>
    {
        *(d - 1) = '\0';
   138cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   138ce:	83 e8 01             	sub    $0x1,%eax
   138d1:	c6 00 00             	movb   $0x0,(%eax)
   138d4:	eb 09                	jmp    138df <kernel_strncpy+0x68>
    }
    else
    {
        *d = '\0';
   138d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   138d9:	c6 00 00             	movb   $0x0,(%eax)
   138dc:	eb 01                	jmp    138df <kernel_strncpy+0x68>
        return;
   138de:	90                   	nop
    }
}
   138df:	c9                   	leave  
   138e0:	c3                   	ret    

000138e1 <kernel_strncmp>:

int kernel_strncmp (const char *str1, const char *str2, int size)
{
   138e1:	55                   	push   %ebp
   138e2:	89 e5                	mov    %esp,%ebp
    if(!str1 || !str2)
   138e4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   138e8:	74 06                	je     138f0 <kernel_strncmp+0xf>
   138ea:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   138ee:	75 0f                	jne    138ff <kernel_strncmp+0x1e>
    {
        return 0;
   138f0:	b8 00 00 00 00       	mov    $0x0,%eax
   138f5:	eb 62                	jmp    13959 <kernel_strncmp+0x78>
    }
    while(*str1 && *str2 && (*str1 == *str2) && size)
    {
        str1++;
   138f7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        str2++;
   138fb:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
    while(*str1 && *str2 && (*str1 == *str2) && size)
   138ff:	8b 45 08             	mov    0x8(%ebp),%eax
   13902:	0f b6 00             	movzbl (%eax),%eax
   13905:	84 c0                	test   %al,%al
   13907:	74 20                	je     13929 <kernel_strncmp+0x48>
   13909:	8b 45 0c             	mov    0xc(%ebp),%eax
   1390c:	0f b6 00             	movzbl (%eax),%eax
   1390f:	84 c0                	test   %al,%al
   13911:	74 16                	je     13929 <kernel_strncmp+0x48>
   13913:	8b 45 08             	mov    0x8(%ebp),%eax
   13916:	0f b6 10             	movzbl (%eax),%edx
   13919:	8b 45 0c             	mov    0xc(%ebp),%eax
   1391c:	0f b6 00             	movzbl (%eax),%eax
   1391f:	38 c2                	cmp    %al,%dl
   13921:	75 06                	jne    13929 <kernel_strncmp+0x48>
   13923:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   13927:	75 ce                	jne    138f7 <kernel_strncmp+0x16>
    }
    return !((*str1 == '\0') || (*str2 == '\0') || (*str1 == *str2));
   13929:	8b 45 08             	mov    0x8(%ebp),%eax
   1392c:	0f b6 00             	movzbl (%eax),%eax
   1392f:	84 c0                	test   %al,%al
   13931:	74 21                	je     13954 <kernel_strncmp+0x73>
   13933:	8b 45 0c             	mov    0xc(%ebp),%eax
   13936:	0f b6 00             	movzbl (%eax),%eax
   13939:	84 c0                	test   %al,%al
   1393b:	74 17                	je     13954 <kernel_strncmp+0x73>
   1393d:	8b 45 08             	mov    0x8(%ebp),%eax
   13940:	0f b6 10             	movzbl (%eax),%edx
   13943:	8b 45 0c             	mov    0xc(%ebp),%eax
   13946:	0f b6 00             	movzbl (%eax),%eax
   13949:	38 c2                	cmp    %al,%dl
   1394b:	74 07                	je     13954 <kernel_strncmp+0x73>
   1394d:	b8 01 00 00 00       	mov    $0x1,%eax
   13952:	eb 05                	jmp    13959 <kernel_strncmp+0x78>
   13954:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13959:	5d                   	pop    %ebp
   1395a:	c3                   	ret    

0001395b <kernel_strlen>:

int kernel_strlen (const char *str)
{
   1395b:	55                   	push   %ebp
   1395c:	89 e5                	mov    %esp,%ebp
   1395e:	83 ec 10             	sub    $0x10,%esp
    if(!str)
   13961:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13965:	75 07                	jne    1396e <kernel_strlen+0x13>
    {
        return 0;
   13967:	b8 00 00 00 00       	mov    $0x0,%eax
   1396c:	eb 26                	jmp    13994 <kernel_strlen+0x39>
    }
    const char *s = str;
   1396e:	8b 45 08             	mov    0x8(%ebp),%eax
   13971:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int len = 0;
   13974:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    while(*s++)
   1397b:	eb 04                	jmp    13981 <kernel_strlen+0x26>
    {
        len++;
   1397d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while(*s++)
   13981:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13984:	8d 50 01             	lea    0x1(%eax),%edx
   13987:	89 55 fc             	mov    %edx,-0x4(%ebp)
   1398a:	0f b6 00             	movzbl (%eax),%eax
   1398d:	84 c0                	test   %al,%al
   1398f:	75 ec                	jne    1397d <kernel_strlen+0x22>
    }
    return len;
   13991:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
   13994:	c9                   	leave  
   13995:	c3                   	ret    

00013996 <kernel_memcpy>:


void kernel_memcpy (void *dest, void *src, int size)
{
   13996:	55                   	push   %ebp
   13997:	89 e5                	mov    %esp,%ebp
   13999:	83 ec 10             	sub    $0x10,%esp
    if(!dest || !src || size <= 0)
   1399c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   139a0:	74 40                	je     139e2 <kernel_memcpy+0x4c>
   139a2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   139a6:	74 3a                	je     139e2 <kernel_memcpy+0x4c>
   139a8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   139ac:	7e 34                	jle    139e2 <kernel_memcpy+0x4c>
    {
        return;
    }
    uint8_t *d = (uint8_t *)dest;
   139ae:	8b 45 08             	mov    0x8(%ebp),%eax
   139b1:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t *s = (uint8_t *)src;
   139b4:	8b 45 0c             	mov    0xc(%ebp),%eax
   139b7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(size--)
   139ba:	eb 17                	jmp    139d3 <kernel_memcpy+0x3d>
    {
        *d++ = *s++;
   139bc:	8b 55 f8             	mov    -0x8(%ebp),%edx
   139bf:	8d 42 01             	lea    0x1(%edx),%eax
   139c2:	89 45 f8             	mov    %eax,-0x8(%ebp)
   139c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   139c8:	8d 48 01             	lea    0x1(%eax),%ecx
   139cb:	89 4d fc             	mov    %ecx,-0x4(%ebp)
   139ce:	0f b6 12             	movzbl (%edx),%edx
   139d1:	88 10                	mov    %dl,(%eax)
    while(size--)
   139d3:	8b 45 10             	mov    0x10(%ebp),%eax
   139d6:	8d 50 ff             	lea    -0x1(%eax),%edx
   139d9:	89 55 10             	mov    %edx,0x10(%ebp)
   139dc:	85 c0                	test   %eax,%eax
   139de:	75 dc                	jne    139bc <kernel_memcpy+0x26>
   139e0:	eb 01                	jmp    139e3 <kernel_memcpy+0x4d>
        return;
   139e2:	90                   	nop
    }
}
   139e3:	c9                   	leave  
   139e4:	c3                   	ret    

000139e5 <kernel_memset>:

void kernel_memset (void *dest, int c, int size)
{
   139e5:	55                   	push   %ebp
   139e6:	89 e5                	mov    %esp,%ebp
   139e8:	83 ec 10             	sub    $0x10,%esp
    if(!dest || size <= 0)
   139eb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   139ef:	74 2b                	je     13a1c <kernel_memset+0x37>
   139f1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   139f5:	7e 25                	jle    13a1c <kernel_memset+0x37>
    {
        return;
    }
    uint8_t *d = (uint8_t *)dest;
   139f7:	8b 45 08             	mov    0x8(%ebp),%eax
   139fa:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(size--)
   139fd:	eb 0e                	jmp    13a0d <kernel_memset+0x28>
    {
        *d++ = (uint8_t)c;
   139ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13a02:	8d 50 01             	lea    0x1(%eax),%edx
   13a05:	89 55 fc             	mov    %edx,-0x4(%ebp)
   13a08:	8b 55 0c             	mov    0xc(%ebp),%edx
   13a0b:	88 10                	mov    %dl,(%eax)
    while(size--)
   13a0d:	8b 45 10             	mov    0x10(%ebp),%eax
   13a10:	8d 50 ff             	lea    -0x1(%eax),%edx
   13a13:	89 55 10             	mov    %edx,0x10(%ebp)
   13a16:	85 c0                	test   %eax,%eax
   13a18:	75 e5                	jne    139ff <kernel_memset+0x1a>
   13a1a:	eb 01                	jmp    13a1d <kernel_memset+0x38>
        return;
   13a1c:	90                   	nop
    }
}
   13a1d:	c9                   	leave  
   13a1e:	c3                   	ret    

00013a1f <kernel_memcmp>:

int kernel_memcmp (void *d1, void *d2, int size)
{
   13a1f:	55                   	push   %ebp
   13a20:	89 e5                	mov    %esp,%ebp
   13a22:	83 ec 10             	sub    $0x10,%esp
    if(!d1 || !d2 || !size)
   13a25:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13a29:	74 0c                	je     13a37 <kernel_memcmp+0x18>
   13a2b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   13a2f:	74 06                	je     13a37 <kernel_memcmp+0x18>
   13a31:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   13a35:	75 07                	jne    13a3e <kernel_memcmp+0x1f>
    {
        return 1;
   13a37:	b8 01 00 00 00       	mov    $0x1,%eax
   13a3c:	eb 43                	jmp    13a81 <kernel_memcmp+0x62>
    }
    uint8_t *p_d1 = (uint8_t *)d1;
   13a3e:	8b 45 08             	mov    0x8(%ebp),%eax
   13a41:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t *p_d2 = (uint8_t *)d2;
   13a44:	8b 45 0c             	mov    0xc(%ebp),%eax
   13a47:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(size--)
   13a4a:	eb 23                	jmp    13a6f <kernel_memcmp+0x50>
    {
        if(*p_d1++ != *p_d2++)
   13a4c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13a4f:	8d 50 01             	lea    0x1(%eax),%edx
   13a52:	89 55 fc             	mov    %edx,-0x4(%ebp)
   13a55:	0f b6 08             	movzbl (%eax),%ecx
   13a58:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13a5b:	8d 50 01             	lea    0x1(%eax),%edx
   13a5e:	89 55 f8             	mov    %edx,-0x8(%ebp)
   13a61:	0f b6 00             	movzbl (%eax),%eax
   13a64:	38 c1                	cmp    %al,%cl
   13a66:	74 07                	je     13a6f <kernel_memcmp+0x50>
        {
            return 1;
   13a68:	b8 01 00 00 00       	mov    $0x1,%eax
   13a6d:	eb 12                	jmp    13a81 <kernel_memcmp+0x62>
    while(size--)
   13a6f:	8b 45 10             	mov    0x10(%ebp),%eax
   13a72:	8d 50 ff             	lea    -0x1(%eax),%edx
   13a75:	89 55 10             	mov    %edx,0x10(%ebp)
   13a78:	85 c0                	test   %eax,%eax
   13a7a:	75 d0                	jne    13a4c <kernel_memcmp+0x2d>
        }
    }
    return 0;
   13a7c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13a81:	c9                   	leave  
   13a82:	c3                   	ret    

00013a83 <kernel_itoa>:

void kernel_itoa (char *buf, int num, int base)
{
   13a83:	55                   	push   %ebp
   13a84:	89 e5                	mov    %esp,%ebp
   13a86:	53                   	push   %ebx
   13a87:	83 ec 20             	sub    $0x20,%esp
    int is_neg = 0;
   13a8a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    static const char * num2ch = "0123456789abcdef";
    char *p = buf;
   13a91:	8b 45 08             	mov    0x8(%ebp),%eax
   13a94:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(base != 2 && base != 8 && base != 10 && base != 16)
   13a97:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
   13a9b:	74 1d                	je     13aba <kernel_itoa+0x37>
   13a9d:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
   13aa1:	74 17                	je     13aba <kernel_itoa+0x37>
   13aa3:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   13aa7:	74 11                	je     13aba <kernel_itoa+0x37>
   13aa9:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
   13aad:	74 0b                	je     13aba <kernel_itoa+0x37>
    {
        *p = '\0';
   13aaf:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13ab2:	c6 00 00             	movb   $0x0,(%eax)
        return;
   13ab5:	e9 f7 00 00 00       	jmp    13bb1 <kernel_itoa+0x12e>
    }
    
    // 对于十六进制，强制按无符号数处理
    if(base == 16)
   13aba:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
   13abe:	75 4a                	jne    13b0a <kernel_itoa+0x87>
    {
        uint32_t unum = (uint32_t)num;  // 强制转换为无符号数
   13ac0:	8b 45 0c             	mov    0xc(%ebp),%eax
   13ac3:	89 45 f4             	mov    %eax,-0xc(%ebp)
        do{
            char ch = num2ch[unum % base];
   13ac6:	8b 0d 40 50 01 00    	mov    0x15040,%ecx
   13acc:	8b 5d 10             	mov    0x10(%ebp),%ebx
   13acf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13ad2:	ba 00 00 00 00       	mov    $0x0,%edx
   13ad7:	f7 f3                	div    %ebx
   13ad9:	89 d0                	mov    %edx,%eax
   13adb:	01 c8                	add    %ecx,%eax
   13add:	0f b6 00             	movzbl (%eax),%eax
   13ae0:	88 45 ea             	mov    %al,-0x16(%ebp)
            *p++ = ch;
   13ae3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13ae6:	8d 50 01             	lea    0x1(%eax),%edx
   13ae9:	89 55 f8             	mov    %edx,-0x8(%ebp)
   13aec:	0f b6 55 ea          	movzbl -0x16(%ebp),%edx
   13af0:	88 10                	mov    %dl,(%eax)
            unum /= base;
   13af2:	8b 5d 10             	mov    0x10(%ebp),%ebx
   13af5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13af8:	ba 00 00 00 00       	mov    $0x0,%edx
   13afd:	f7 f3                	div    %ebx
   13aff:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }while (unum);
   13b02:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13b06:	75 be                	jne    13ac6 <kernel_itoa+0x43>
   13b08:	eb 66                	jmp    13b70 <kernel_itoa+0xed>
    }
    else
    {
        // 其他进制的原有逻辑
        is_neg = num < 0 ? 1 : 0;
   13b0a:	8b 45 0c             	mov    0xc(%ebp),%eax
   13b0d:	c1 e8 1f             	shr    $0x1f,%eax
   13b10:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(num < 0 && base == 10)
   13b13:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   13b17:	79 09                	jns    13b22 <kernel_itoa+0x9f>
   13b19:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   13b1d:	75 03                	jne    13b22 <kernel_itoa+0x9f>
        {
            num = -num;
   13b1f:	f7 5d 0c             	negl   0xc(%ebp)
        }
        do{
            char ch = num2ch[num % base];
   13b22:	8b 0d 40 50 01 00    	mov    0x15040,%ecx
   13b28:	8b 45 0c             	mov    0xc(%ebp),%eax
   13b2b:	99                   	cltd   
   13b2c:	f7 7d 10             	idivl  0x10(%ebp)
   13b2f:	89 d0                	mov    %edx,%eax
   13b31:	01 c8                	add    %ecx,%eax
   13b33:	0f b6 00             	movzbl (%eax),%eax
   13b36:	88 45 eb             	mov    %al,-0x15(%ebp)
            *p++ = ch;
   13b39:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13b3c:	8d 50 01             	lea    0x1(%eax),%edx
   13b3f:	89 55 f8             	mov    %edx,-0x8(%ebp)
   13b42:	0f b6 55 eb          	movzbl -0x15(%ebp),%edx
   13b46:	88 10                	mov    %dl,(%eax)
            num /= base;
   13b48:	8b 45 0c             	mov    0xc(%ebp),%eax
   13b4b:	99                   	cltd   
   13b4c:	f7 7d 10             	idivl  0x10(%ebp)
   13b4f:	89 45 0c             	mov    %eax,0xc(%ebp)
        }while (num);
   13b52:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   13b56:	75 ca                	jne    13b22 <kernel_itoa+0x9f>
        if(base == 10 && is_neg)
   13b58:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   13b5c:	75 12                	jne    13b70 <kernel_itoa+0xed>
   13b5e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   13b62:	74 0c                	je     13b70 <kernel_itoa+0xed>
        {
            *p++ = '-';
   13b64:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13b67:	8d 50 01             	lea    0x1(%eax),%edx
   13b6a:	89 55 f8             	mov    %edx,-0x8(%ebp)
   13b6d:	c6 00 2d             	movb   $0x2d,(%eax)
        }
    }
    
    *p-- = '\0';
   13b70:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13b73:	8d 50 ff             	lea    -0x1(%eax),%edx
   13b76:	89 55 f8             	mov    %edx,-0x8(%ebp)
   13b79:	c6 00 00             	movb   $0x0,(%eax)

    char *start = buf;
   13b7c:	8b 45 08             	mov    0x8(%ebp),%eax
   13b7f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(start < p)
   13b82:	eb 25                	jmp    13ba9 <kernel_itoa+0x126>
    {
        char tmp = *start;
   13b84:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13b87:	0f b6 00             	movzbl (%eax),%eax
   13b8a:	88 45 e9             	mov    %al,-0x17(%ebp)
        *start = *p;
   13b8d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13b90:	0f b6 10             	movzbl (%eax),%edx
   13b93:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13b96:	88 10                	mov    %dl,(%eax)
        *p = tmp;
   13b98:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13b9b:	0f b6 55 e9          	movzbl -0x17(%ebp),%edx
   13b9f:	88 10                	mov    %dl,(%eax)
        p--;
   13ba1:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
        start++;
   13ba5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    while(start < p)
   13ba9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13bac:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   13baf:	72 d3                	jb     13b84 <kernel_itoa+0x101>
    }
}
   13bb1:	83 c4 20             	add    $0x20,%esp
   13bb4:	5b                   	pop    %ebx
   13bb5:	5d                   	pop    %ebp
   13bb6:	c3                   	ret    

00013bb7 <kernel_sprintf>:
void kernel_sprintf (char *buf, const char *fmt, ...)
{
   13bb7:	55                   	push   %ebp
   13bb8:	89 e5                	mov    %esp,%ebp
   13bba:	83 ec 18             	sub    $0x18,%esp
    va_list args;
    va_start(args, fmt);
   13bbd:	8d 45 10             	lea    0x10(%ebp),%eax
   13bc0:	89 45 f4             	mov    %eax,-0xc(%ebp)

    kernel_vsprintf(buf, fmt, args);
   13bc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13bc6:	83 ec 04             	sub    $0x4,%esp
   13bc9:	50                   	push   %eax
   13bca:	ff 75 0c             	pushl  0xc(%ebp)
   13bcd:	ff 75 08             	pushl  0x8(%ebp)
   13bd0:	e8 06 00 00 00       	call   13bdb <kernel_vsprintf>
   13bd5:	83 c4 10             	add    $0x10,%esp
    va_end(args);
}
   13bd8:	90                   	nop
   13bd9:	c9                   	leave  
   13bda:	c3                   	ret    

00013bdb <kernel_vsprintf>:
void kernel_vsprintf (char *buf, const char *fmt, va_list args)
{
   13bdb:	55                   	push   %ebp
   13bdc:	89 e5                	mov    %esp,%ebp
   13bde:	83 ec 20             	sub    $0x20,%esp
    enum{
        NORMAL,READ_FMT
    }state = NORMAL;
   13be1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    char * curr = buf;
   13be8:	8b 45 08             	mov    0x8(%ebp),%eax
   13beb:	89 45 f8             	mov    %eax,-0x8(%ebp)
    char ch;
    while((ch = *fmt++))
   13bee:	e9 17 01 00 00       	jmp    13d0a <kernel_vsprintf+0x12f>
    {
        switch(state)
   13bf3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13bf6:	85 c0                	test   %eax,%eax
   13bf8:	74 0a                	je     13c04 <kernel_vsprintf+0x29>
   13bfa:	83 f8 01             	cmp    $0x1,%eax
   13bfd:	74 2b                	je     13c2a <kernel_vsprintf+0x4f>
   13bff:	e9 06 01 00 00       	jmp    13d0a <kernel_vsprintf+0x12f>
        {
        case NORMAL:
            if(ch == '%')
   13c04:	80 7d ef 25          	cmpb   $0x25,-0x11(%ebp)
   13c08:	75 0c                	jne    13c16 <kernel_vsprintf+0x3b>
            {
                state = READ_FMT;
   13c0a:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
   13c11:	e9 f4 00 00 00       	jmp    13d0a <kernel_vsprintf+0x12f>
            }
            else
            {
                *curr++ = ch;
   13c16:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13c19:	8d 50 01             	lea    0x1(%eax),%edx
   13c1c:	89 55 f8             	mov    %edx,-0x8(%ebp)
   13c1f:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
   13c23:	88 10                	mov    %dl,(%eax)
            }
            break;
   13c25:	e9 e0 00 00 00       	jmp    13d0a <kernel_vsprintf+0x12f>
        case READ_FMT:
            if(ch == 'd')
   13c2a:	80 7d ef 64          	cmpb   $0x64,-0x11(%ebp)
   13c2e:	75 31                	jne    13c61 <kernel_vsprintf+0x86>
            {
                int num = va_arg(args,int);
   13c30:	8b 45 10             	mov    0x10(%ebp),%eax
   13c33:	8d 50 04             	lea    0x4(%eax),%edx
   13c36:	89 55 10             	mov    %edx,0x10(%ebp)
   13c39:	8b 00                	mov    (%eax),%eax
   13c3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                kernel_itoa(curr,num,10);
   13c3e:	6a 0a                	push   $0xa
   13c40:	ff 75 e4             	pushl  -0x1c(%ebp)
   13c43:	ff 75 f8             	pushl  -0x8(%ebp)
   13c46:	e8 38 fe ff ff       	call   13a83 <kernel_itoa>
   13c4b:	83 c4 0c             	add    $0xc,%esp
                curr += kernel_strlen(curr);
   13c4e:	ff 75 f8             	pushl  -0x8(%ebp)
   13c51:	e8 05 fd ff ff       	call   1395b <kernel_strlen>
   13c56:	83 c4 04             	add    $0x4,%esp
   13c59:	01 45 f8             	add    %eax,-0x8(%ebp)
   13c5c:	e9 a1 00 00 00       	jmp    13d02 <kernel_vsprintf+0x127>
            }
            else if(ch == 'x')
   13c61:	80 7d ef 78          	cmpb   $0x78,-0x11(%ebp)
   13c65:	75 2e                	jne    13c95 <kernel_vsprintf+0xba>
            {
                int num = va_arg(args,int);
   13c67:	8b 45 10             	mov    0x10(%ebp),%eax
   13c6a:	8d 50 04             	lea    0x4(%eax),%edx
   13c6d:	89 55 10             	mov    %edx,0x10(%ebp)
   13c70:	8b 00                	mov    (%eax),%eax
   13c72:	89 45 e8             	mov    %eax,-0x18(%ebp)
                kernel_itoa(curr,num,16);
   13c75:	6a 10                	push   $0x10
   13c77:	ff 75 e8             	pushl  -0x18(%ebp)
   13c7a:	ff 75 f8             	pushl  -0x8(%ebp)
   13c7d:	e8 01 fe ff ff       	call   13a83 <kernel_itoa>
   13c82:	83 c4 0c             	add    $0xc,%esp
                curr += kernel_strlen(curr);
   13c85:	ff 75 f8             	pushl  -0x8(%ebp)
   13c88:	e8 ce fc ff ff       	call   1395b <kernel_strlen>
   13c8d:	83 c4 04             	add    $0x4,%esp
   13c90:	01 45 f8             	add    %eax,-0x8(%ebp)
   13c93:	eb 6d                	jmp    13d02 <kernel_vsprintf+0x127>
            }
            else if(ch == 'c')
   13c95:	80 7d ef 63          	cmpb   $0x63,-0x11(%ebp)
   13c99:	75 1f                	jne    13cba <kernel_vsprintf+0xdf>
            {
                char ch = va_arg(args,int);
   13c9b:	8b 45 10             	mov    0x10(%ebp),%eax
   13c9e:	8d 50 04             	lea    0x4(%eax),%edx
   13ca1:	89 55 10             	mov    %edx,0x10(%ebp)
   13ca4:	8b 00                	mov    (%eax),%eax
   13ca6:	88 45 ee             	mov    %al,-0x12(%ebp)
                *curr++ = ch;
   13ca9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13cac:	8d 50 01             	lea    0x1(%eax),%edx
   13caf:	89 55 f8             	mov    %edx,-0x8(%ebp)
   13cb2:	0f b6 55 ee          	movzbl -0x12(%ebp),%edx
   13cb6:	88 10                	mov    %dl,(%eax)
   13cb8:	eb 48                	jmp    13d02 <kernel_vsprintf+0x127>
            }
            else if(ch == 's')
   13cba:	80 7d ef 73          	cmpb   $0x73,-0x11(%ebp)
   13cbe:	75 42                	jne    13d02 <kernel_vsprintf+0x127>
            {
                const char *str = va_arg(args,char *);
   13cc0:	8b 45 10             	mov    0x10(%ebp),%eax
   13cc3:	8d 50 04             	lea    0x4(%eax),%edx
   13cc6:	89 55 10             	mov    %edx,0x10(%ebp)
   13cc9:	8b 00                	mov    (%eax),%eax
   13ccb:	89 45 f4             	mov    %eax,-0xc(%ebp)
                int len = kernel_strlen(str);
   13cce:	ff 75 f4             	pushl  -0xc(%ebp)
   13cd1:	e8 85 fc ff ff       	call   1395b <kernel_strlen>
   13cd6:	83 c4 04             	add    $0x4,%esp
   13cd9:	89 45 f0             	mov    %eax,-0x10(%ebp)
                while(len--)
   13cdc:	eb 17                	jmp    13cf5 <kernel_vsprintf+0x11a>
                {
                    *curr++ = *str++;
   13cde:	8b 55 f4             	mov    -0xc(%ebp),%edx
   13ce1:	8d 42 01             	lea    0x1(%edx),%eax
   13ce4:	89 45 f4             	mov    %eax,-0xc(%ebp)
   13ce7:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13cea:	8d 48 01             	lea    0x1(%eax),%ecx
   13ced:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   13cf0:	0f b6 12             	movzbl (%edx),%edx
   13cf3:	88 10                	mov    %dl,(%eax)
                while(len--)
   13cf5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13cf8:	8d 50 ff             	lea    -0x1(%eax),%edx
   13cfb:	89 55 f0             	mov    %edx,-0x10(%ebp)
   13cfe:	85 c0                	test   %eax,%eax
   13d00:	75 dc                	jne    13cde <kernel_vsprintf+0x103>
                }
            }
            state = NORMAL;
   13d02:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
            break;
   13d09:	90                   	nop
    while((ch = *fmt++))
   13d0a:	8b 45 0c             	mov    0xc(%ebp),%eax
   13d0d:	8d 50 01             	lea    0x1(%eax),%edx
   13d10:	89 55 0c             	mov    %edx,0xc(%ebp)
   13d13:	0f b6 00             	movzbl (%eax),%eax
   13d16:	88 45 ef             	mov    %al,-0x11(%ebp)
   13d19:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
   13d1d:	0f 85 d0 fe ff ff    	jne    13bf3 <kernel_vsprintf+0x18>
        }
    }
    *curr = '\0';
   13d23:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13d26:	c6 00 00             	movb   $0x0,(%eax)
}
   13d29:	90                   	nop
   13d2a:	c9                   	leave  
   13d2b:	c3                   	ret    

00013d2c <panic>:
void panic(const char *file,int line,const char *func,const char *cond)
{
   13d2c:	55                   	push   %ebp
   13d2d:	89 e5                	mov    %esp,%ebp
   13d2f:	83 ec 08             	sub    $0x8,%esp
    log_printf("assert failed: %s\n",cond);
   13d32:	83 ec 08             	sub    $0x8,%esp
   13d35:	ff 75 14             	pushl  0x14(%ebp)
   13d38:	68 57 4a 01 00       	push   $0x14a57
   13d3d:	e8 85 03 00 00       	call   140c7 <log_printf>
   13d42:	83 c4 10             	add    $0x10,%esp
    log_printf("file: %s\n",file);
   13d45:	83 ec 08             	sub    $0x8,%esp
   13d48:	ff 75 08             	pushl  0x8(%ebp)
   13d4b:	68 6a 4a 01 00       	push   $0x14a6a
   13d50:	e8 72 03 00 00       	call   140c7 <log_printf>
   13d55:	83 c4 10             	add    $0x10,%esp
    log_printf("line: %d\n",line);
   13d58:	83 ec 08             	sub    $0x8,%esp
   13d5b:	ff 75 0c             	pushl  0xc(%ebp)
   13d5e:	68 74 4a 01 00       	push   $0x14a74
   13d63:	e8 5f 03 00 00       	call   140c7 <log_printf>
   13d68:	83 c4 10             	add    $0x10,%esp
    log_printf("function: %s\n",func);
   13d6b:	83 ec 08             	sub    $0x8,%esp
   13d6e:	ff 75 10             	pushl  0x10(%ebp)
   13d71:	68 7e 4a 01 00       	push   $0x14a7e
   13d76:	e8 4c 03 00 00       	call   140c7 <log_printf>
   13d7b:	83 c4 10             	add    $0x10,%esp
    for(;;){
        hlt();
   13d7e:	e8 ba fa ff ff       	call   1383d <hlt>
   13d83:	eb f9                	jmp    13d7e <panic+0x52>

00013d85 <strings_count>:
    }
}

int strings_count(const char **start)
{
   13d85:	55                   	push   %ebp
   13d86:	89 e5                	mov    %esp,%ebp
   13d88:	83 ec 10             	sub    $0x10,%esp
    int count = 0;
   13d8b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    if(start)
   13d92:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13d96:	74 15                	je     13dad <strings_count+0x28>
    {
        while(*start++)
   13d98:	eb 04                	jmp    13d9e <strings_count+0x19>
        {
            count++;
   13d9a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        while(*start++)
   13d9e:	8b 45 08             	mov    0x8(%ebp),%eax
   13da1:	8d 50 04             	lea    0x4(%eax),%edx
   13da4:	89 55 08             	mov    %edx,0x8(%ebp)
   13da7:	8b 00                	mov    (%eax),%eax
   13da9:	85 c0                	test   %eax,%eax
   13dab:	75 ed                	jne    13d9a <strings_count+0x15>
        }
    }
    return count;
   13dad:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   13db0:	c9                   	leave  
   13db1:	c3                   	ret    

00013db2 <get_file_name>:

char * get_file_name(const char *name)
{
   13db2:	55                   	push   %ebp
   13db3:	89 e5                	mov    %esp,%ebp
   13db5:	83 ec 10             	sub    $0x10,%esp
    char * s = name;
   13db8:	8b 45 08             	mov    0x8(%ebp),%eax
   13dbb:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(*s != '\0')
   13dbe:	eb 04                	jmp    13dc4 <get_file_name+0x12>
    {
        s++;
   13dc0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    while(*s != '\0')
   13dc4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13dc7:	0f b6 00             	movzbl (%eax),%eax
   13dca:	84 c0                	test   %al,%al
   13dcc:	75 f2                	jne    13dc0 <get_file_name+0xe>
    }
    while(*s != '/' && *s != '\\' && (s >= name))
   13dce:	eb 04                	jmp    13dd4 <get_file_name+0x22>
    {
        s--;
   13dd0:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    while(*s != '/' && *s != '\\' && (s >= name))
   13dd4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13dd7:	0f b6 00             	movzbl (%eax),%eax
   13dda:	3c 2f                	cmp    $0x2f,%al
   13ddc:	74 12                	je     13df0 <get_file_name+0x3e>
   13dde:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13de1:	0f b6 00             	movzbl (%eax),%eax
   13de4:	3c 5c                	cmp    $0x5c,%al
   13de6:	74 08                	je     13df0 <get_file_name+0x3e>
   13de8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13deb:	3b 45 08             	cmp    0x8(%ebp),%eax
   13dee:	73 e0                	jae    13dd0 <get_file_name+0x1e>
    }
    return s + 1;
   13df0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13df3:	83 c0 01             	add    $0x1,%eax
   13df6:	c9                   	leave  
   13df7:	c3                   	ret    

00013df8 <list_is_empty>:
{
   13df8:	55                   	push   %ebp
   13df9:	89 e5                	mov    %esp,%ebp
    return list->count == 0;
   13dfb:	8b 45 08             	mov    0x8(%ebp),%eax
   13dfe:	8b 40 08             	mov    0x8(%eax),%eax
   13e01:	85 c0                	test   %eax,%eax
   13e03:	0f 94 c0             	sete   %al
   13e06:	0f b6 c0             	movzbl %al,%eax
}
   13e09:	5d                   	pop    %ebp
   13e0a:	c3                   	ret    

00013e0b <list_init>:
#include "tools/list.h"

void list_init(list_t *list)
{
   13e0b:	55                   	push   %ebp
   13e0c:	89 e5                	mov    %esp,%ebp
    list->first = list->last = (list_node_t *)0;
   13e0e:	8b 45 08             	mov    0x8(%ebp),%eax
   13e11:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   13e18:	8b 45 08             	mov    0x8(%ebp),%eax
   13e1b:	8b 50 04             	mov    0x4(%eax),%edx
   13e1e:	8b 45 08             	mov    0x8(%ebp),%eax
   13e21:	89 10                	mov    %edx,(%eax)
    list->count = 0;
   13e23:	8b 45 08             	mov    0x8(%ebp),%eax
   13e26:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
   13e2d:	90                   	nop
   13e2e:	5d                   	pop    %ebp
   13e2f:	c3                   	ret    

00013e30 <list_insert_first>:

void list_insert_first(list_t * list,list_node_t * node)
{
   13e30:	55                   	push   %ebp
   13e31:	89 e5                	mov    %esp,%ebp
    node->next = list->first;
   13e33:	8b 45 08             	mov    0x8(%ebp),%eax
   13e36:	8b 10                	mov    (%eax),%edx
   13e38:	8b 45 0c             	mov    0xc(%ebp),%eax
   13e3b:	89 50 04             	mov    %edx,0x4(%eax)
    node->pre = (list_node_t *)0;
   13e3e:	8b 45 0c             	mov    0xc(%ebp),%eax
   13e41:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(list_is_empty(list))
   13e47:	ff 75 08             	pushl  0x8(%ebp)
   13e4a:	e8 a9 ff ff ff       	call   13df8 <list_is_empty>
   13e4f:	83 c4 04             	add    $0x4,%esp
   13e52:	85 c0                	test   %eax,%eax
   13e54:	74 15                	je     13e6b <list_insert_first+0x3b>
    {
        list->last = list->first = node;
   13e56:	8b 45 08             	mov    0x8(%ebp),%eax
   13e59:	8b 55 0c             	mov    0xc(%ebp),%edx
   13e5c:	89 10                	mov    %edx,(%eax)
   13e5e:	8b 45 08             	mov    0x8(%ebp),%eax
   13e61:	8b 10                	mov    (%eax),%edx
   13e63:	8b 45 08             	mov    0x8(%ebp),%eax
   13e66:	89 50 04             	mov    %edx,0x4(%eax)
   13e69:	eb 12                	jmp    13e7d <list_insert_first+0x4d>
    }
    else
    {
        list->first->pre = node;
   13e6b:	8b 45 08             	mov    0x8(%ebp),%eax
   13e6e:	8b 00                	mov    (%eax),%eax
   13e70:	8b 55 0c             	mov    0xc(%ebp),%edx
   13e73:	89 10                	mov    %edx,(%eax)
        list->first = node;
   13e75:	8b 45 08             	mov    0x8(%ebp),%eax
   13e78:	8b 55 0c             	mov    0xc(%ebp),%edx
   13e7b:	89 10                	mov    %edx,(%eax)
    }
    list->count++;
   13e7d:	8b 45 08             	mov    0x8(%ebp),%eax
   13e80:	8b 40 08             	mov    0x8(%eax),%eax
   13e83:	8d 50 01             	lea    0x1(%eax),%edx
   13e86:	8b 45 08             	mov    0x8(%ebp),%eax
   13e89:	89 50 08             	mov    %edx,0x8(%eax)
}
   13e8c:	90                   	nop
   13e8d:	c9                   	leave  
   13e8e:	c3                   	ret    

00013e8f <list_insert_last>:

void list_insert_last(list_t * list,list_node_t * node)
{
   13e8f:	55                   	push   %ebp
   13e90:	89 e5                	mov    %esp,%ebp
    node->pre = list->last;
   13e92:	8b 45 08             	mov    0x8(%ebp),%eax
   13e95:	8b 50 04             	mov    0x4(%eax),%edx
   13e98:	8b 45 0c             	mov    0xc(%ebp),%eax
   13e9b:	89 10                	mov    %edx,(%eax)
    node->next = (list_node_t *)0;
   13e9d:	8b 45 0c             	mov    0xc(%ebp),%eax
   13ea0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if(list_is_empty(list))
   13ea7:	ff 75 08             	pushl  0x8(%ebp)
   13eaa:	e8 49 ff ff ff       	call   13df8 <list_is_empty>
   13eaf:	83 c4 04             	add    $0x4,%esp
   13eb2:	85 c0                	test   %eax,%eax
   13eb4:	74 16                	je     13ecc <list_insert_last+0x3d>
    {
        list->first = list->last = node;
   13eb6:	8b 45 08             	mov    0x8(%ebp),%eax
   13eb9:	8b 55 0c             	mov    0xc(%ebp),%edx
   13ebc:	89 50 04             	mov    %edx,0x4(%eax)
   13ebf:	8b 45 08             	mov    0x8(%ebp),%eax
   13ec2:	8b 50 04             	mov    0x4(%eax),%edx
   13ec5:	8b 45 08             	mov    0x8(%ebp),%eax
   13ec8:	89 10                	mov    %edx,(%eax)
   13eca:	eb 15                	jmp    13ee1 <list_insert_last+0x52>
    }
    else
    {
        list->last->next = node;
   13ecc:	8b 45 08             	mov    0x8(%ebp),%eax
   13ecf:	8b 40 04             	mov    0x4(%eax),%eax
   13ed2:	8b 55 0c             	mov    0xc(%ebp),%edx
   13ed5:	89 50 04             	mov    %edx,0x4(%eax)
        list->last = node;
   13ed8:	8b 45 08             	mov    0x8(%ebp),%eax
   13edb:	8b 55 0c             	mov    0xc(%ebp),%edx
   13ede:	89 50 04             	mov    %edx,0x4(%eax)
    }
    list->count++;
   13ee1:	8b 45 08             	mov    0x8(%ebp),%eax
   13ee4:	8b 40 08             	mov    0x8(%eax),%eax
   13ee7:	8d 50 01             	lea    0x1(%eax),%edx
   13eea:	8b 45 08             	mov    0x8(%ebp),%eax
   13eed:	89 50 08             	mov    %edx,0x8(%eax)
}
   13ef0:	90                   	nop
   13ef1:	c9                   	leave  
   13ef2:	c3                   	ret    

00013ef3 <list_remove_first>:

list_node_t* list_remove_first(list_t * list)
{
   13ef3:	55                   	push   %ebp
   13ef4:	89 e5                	mov    %esp,%ebp
   13ef6:	83 ec 10             	sub    $0x10,%esp
    if(list_is_empty(list))
   13ef9:	ff 75 08             	pushl  0x8(%ebp)
   13efc:	e8 f7 fe ff ff       	call   13df8 <list_is_empty>
   13f01:	83 c4 04             	add    $0x4,%esp
   13f04:	85 c0                	test   %eax,%eax
   13f06:	74 07                	je     13f0f <list_remove_first+0x1c>
    {
        return (list_node_t *)0;
   13f08:	b8 00 00 00 00       	mov    $0x0,%eax
   13f0d:	eb 59                	jmp    13f68 <list_remove_first+0x75>
    }
    list_node_t * node = list->first;
   13f0f:	8b 45 08             	mov    0x8(%ebp),%eax
   13f12:	8b 00                	mov    (%eax),%eax
   13f14:	89 45 fc             	mov    %eax,-0x4(%ebp)
    list->first = node->next;
   13f17:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13f1a:	8b 50 04             	mov    0x4(%eax),%edx
   13f1d:	8b 45 08             	mov    0x8(%ebp),%eax
   13f20:	89 10                	mov    %edx,(%eax)
    if(list->first == (list_node_t *)0)
   13f22:	8b 45 08             	mov    0x8(%ebp),%eax
   13f25:	8b 00                	mov    (%eax),%eax
   13f27:	85 c0                	test   %eax,%eax
   13f29:	75 0c                	jne    13f37 <list_remove_first+0x44>
    {
        list->last = (list_node_t *)0;
   13f2b:	8b 45 08             	mov    0x8(%ebp),%eax
   13f2e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   13f35:	eb 0b                	jmp    13f42 <list_remove_first+0x4f>
    }
    else
    {
        list->first->pre = (list_node_t *)0;
   13f37:	8b 45 08             	mov    0x8(%ebp),%eax
   13f3a:	8b 00                	mov    (%eax),%eax
   13f3c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    node->next = node->pre = (list_node_t *)0;
   13f42:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13f45:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   13f4b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13f4e:	8b 10                	mov    (%eax),%edx
   13f50:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13f53:	89 50 04             	mov    %edx,0x4(%eax)
    list->count--;
   13f56:	8b 45 08             	mov    0x8(%ebp),%eax
   13f59:	8b 40 08             	mov    0x8(%eax),%eax
   13f5c:	8d 50 ff             	lea    -0x1(%eax),%edx
   13f5f:	8b 45 08             	mov    0x8(%ebp),%eax
   13f62:	89 50 08             	mov    %edx,0x8(%eax)
    return node;
   13f65:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   13f68:	c9                   	leave  
   13f69:	c3                   	ret    

00013f6a <list_remove>:

list_node_t* list_remove(list_t * list,list_node_t * node)
{
   13f6a:	55                   	push   %ebp
   13f6b:	89 e5                	mov    %esp,%ebp
    if(node == list->first)
   13f6d:	8b 45 08             	mov    0x8(%ebp),%eax
   13f70:	8b 00                	mov    (%eax),%eax
   13f72:	39 45 0c             	cmp    %eax,0xc(%ebp)
   13f75:	75 0b                	jne    13f82 <list_remove+0x18>
    {
        list->first = node->next;
   13f77:	8b 45 0c             	mov    0xc(%ebp),%eax
   13f7a:	8b 50 04             	mov    0x4(%eax),%edx
   13f7d:	8b 45 08             	mov    0x8(%ebp),%eax
   13f80:	89 10                	mov    %edx,(%eax)
    }
    if(node == list->last)
   13f82:	8b 45 08             	mov    0x8(%ebp),%eax
   13f85:	8b 40 04             	mov    0x4(%eax),%eax
   13f88:	39 45 0c             	cmp    %eax,0xc(%ebp)
   13f8b:	75 0b                	jne    13f98 <list_remove+0x2e>
    {
        list->last = node->pre;
   13f8d:	8b 45 0c             	mov    0xc(%ebp),%eax
   13f90:	8b 10                	mov    (%eax),%edx
   13f92:	8b 45 08             	mov    0x8(%ebp),%eax
   13f95:	89 50 04             	mov    %edx,0x4(%eax)
    }
    if(node->pre)
   13f98:	8b 45 0c             	mov    0xc(%ebp),%eax
   13f9b:	8b 00                	mov    (%eax),%eax
   13f9d:	85 c0                	test   %eax,%eax
   13f9f:	74 0e                	je     13faf <list_remove+0x45>
    {
        node->pre->next = node->next;
   13fa1:	8b 45 0c             	mov    0xc(%ebp),%eax
   13fa4:	8b 00                	mov    (%eax),%eax
   13fa6:	8b 55 0c             	mov    0xc(%ebp),%edx
   13fa9:	8b 52 04             	mov    0x4(%edx),%edx
   13fac:	89 50 04             	mov    %edx,0x4(%eax)
    }
    if(node->next) 
   13faf:	8b 45 0c             	mov    0xc(%ebp),%eax
   13fb2:	8b 40 04             	mov    0x4(%eax),%eax
   13fb5:	85 c0                	test   %eax,%eax
   13fb7:	74 0d                	je     13fc6 <list_remove+0x5c>
    {
        node->next->pre = node->pre;
   13fb9:	8b 45 0c             	mov    0xc(%ebp),%eax
   13fbc:	8b 40 04             	mov    0x4(%eax),%eax
   13fbf:	8b 55 0c             	mov    0xc(%ebp),%edx
   13fc2:	8b 12                	mov    (%edx),%edx
   13fc4:	89 10                	mov    %edx,(%eax)
    }
    node->next = node->pre = (list_node_t *)0;
   13fc6:	8b 45 0c             	mov    0xc(%ebp),%eax
   13fc9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   13fcf:	8b 45 0c             	mov    0xc(%ebp),%eax
   13fd2:	8b 10                	mov    (%eax),%edx
   13fd4:	8b 45 0c             	mov    0xc(%ebp),%eax
   13fd7:	89 50 04             	mov    %edx,0x4(%eax)
    list->count--;
   13fda:	8b 45 08             	mov    0x8(%ebp),%eax
   13fdd:	8b 40 08             	mov    0x8(%eax),%eax
   13fe0:	8d 50 ff             	lea    -0x1(%eax),%edx
   13fe3:	8b 45 08             	mov    0x8(%ebp),%eax
   13fe6:	89 50 08             	mov    %edx,0x8(%eax)
    return node;
   13fe9:	8b 45 0c             	mov    0xc(%ebp),%eax
}
   13fec:	5d                   	pop    %ebp
   13fed:	c3                   	ret    

00013fee <inb>:
{
   13fee:	55                   	push   %ebp
   13fef:	89 e5                	mov    %esp,%ebp
   13ff1:	83 ec 14             	sub    $0x14,%esp
   13ff4:	8b 45 08             	mov    0x8(%ebp),%eax
   13ff7:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[p], %[v]":[v] "=a"(rv) : [p]"d"(port));
   13ffb:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   13fff:	89 c2                	mov    %eax,%edx
   14001:	ec                   	in     (%dx),%al
   14002:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   14005:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   14009:	c9                   	leave  
   1400a:	c3                   	ret    

0001400b <outb>:
{
   1400b:	55                   	push   %ebp
   1400c:	89 e5                	mov    %esp,%ebp
   1400e:	83 ec 08             	sub    $0x8,%esp
   14011:	8b 55 08             	mov    0x8(%ebp),%edx
   14014:	8b 45 0c             	mov    0xc(%ebp),%eax
   14017:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   1401b:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]"::[p]"d"(port),[v]"a"(data));
   1401e:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   14022:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   14026:	ee                   	out    %al,(%dx)
}
   14027:	90                   	nop
   14028:	c9                   	leave  
   14029:	c3                   	ret    

0001402a <log_init>:
#include "cpu/irq.h"    
#include "ipc/mutex.h"
#define COM_PORT 0x3f8
static mutex_t log_mutex;
void log_init (void)
{
   1402a:	55                   	push   %ebp
   1402b:	89 e5                	mov    %esp,%ebp
   1402d:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&log_mutex);
   14030:	83 ec 0c             	sub    $0xc,%esp
   14033:	68 e8 a0 03 00       	push   $0x3a0e8
   14038:	e8 fd f2 ff ff       	call   1333a <mutex_init>
   1403d:	83 c4 10             	add    $0x10,%esp
    outb(COM_PORT + 1, 0x00);
   14040:	83 ec 08             	sub    $0x8,%esp
   14043:	6a 00                	push   $0x0
   14045:	68 f9 03 00 00       	push   $0x3f9
   1404a:	e8 bc ff ff ff       	call   1400b <outb>
   1404f:	83 c4 10             	add    $0x10,%esp
    outb(COM_PORT + 3, 0x80);
   14052:	83 ec 08             	sub    $0x8,%esp
   14055:	68 80 00 00 00       	push   $0x80
   1405a:	68 fb 03 00 00       	push   $0x3fb
   1405f:	e8 a7 ff ff ff       	call   1400b <outb>
   14064:	83 c4 10             	add    $0x10,%esp
    outb(COM_PORT + 0, 0x03);
   14067:	83 ec 08             	sub    $0x8,%esp
   1406a:	6a 03                	push   $0x3
   1406c:	68 f8 03 00 00       	push   $0x3f8
   14071:	e8 95 ff ff ff       	call   1400b <outb>
   14076:	83 c4 10             	add    $0x10,%esp
    outb(COM_PORT + 1, 0x00);
   14079:	83 ec 08             	sub    $0x8,%esp
   1407c:	6a 00                	push   $0x0
   1407e:	68 f9 03 00 00       	push   $0x3f9
   14083:	e8 83 ff ff ff       	call   1400b <outb>
   14088:	83 c4 10             	add    $0x10,%esp
    outb(COM_PORT + 3, 0x03);
   1408b:	83 ec 08             	sub    $0x8,%esp
   1408e:	6a 03                	push   $0x3
   14090:	68 fb 03 00 00       	push   $0x3fb
   14095:	e8 71 ff ff ff       	call   1400b <outb>
   1409a:	83 c4 10             	add    $0x10,%esp
    outb(COM_PORT + 2, 0xC7);
   1409d:	83 ec 08             	sub    $0x8,%esp
   140a0:	68 c7 00 00 00       	push   $0xc7
   140a5:	68 fa 03 00 00       	push   $0x3fa
   140aa:	e8 5c ff ff ff       	call   1400b <outb>
   140af:	83 c4 10             	add    $0x10,%esp
    outb(COM_PORT + 4, 0x0F);
   140b2:	83 ec 08             	sub    $0x8,%esp
   140b5:	6a 0f                	push   $0xf
   140b7:	68 fc 03 00 00       	push   $0x3fc
   140bc:	e8 4a ff ff ff       	call   1400b <outb>
   140c1:	83 c4 10             	add    $0x10,%esp
}
   140c4:	90                   	nop
   140c5:	c9                   	leave  
   140c6:	c3                   	ret    

000140c7 <log_printf>:


void log_printf (const char *fmt, ...)
{
   140c7:	55                   	push   %ebp
   140c8:	89 e5                	mov    %esp,%ebp
   140ca:	81 ec 18 01 00 00    	sub    $0x118,%esp
    char buf[256];
    kernel_memset(buf, 0, sizeof(buf));
   140d0:	83 ec 04             	sub    $0x4,%esp
   140d3:	68 00 01 00 00       	push   $0x100
   140d8:	6a 00                	push   $0x0
   140da:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
   140e0:	50                   	push   %eax
   140e1:	e8 ff f8 ff ff       	call   139e5 <kernel_memset>
   140e6:	83 c4 10             	add    $0x10,%esp

    va_list args;
    va_start(args, fmt);
   140e9:	8d 45 0c             	lea    0xc(%ebp),%eax
   140ec:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)

    kernel_vsprintf(buf, fmt, args);
   140f2:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
   140f8:	83 ec 04             	sub    $0x4,%esp
   140fb:	50                   	push   %eax
   140fc:	ff 75 08             	pushl  0x8(%ebp)
   140ff:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
   14105:	50                   	push   %eax
   14106:	e8 d0 fa ff ff       	call   13bdb <kernel_vsprintf>
   1410b:	83 c4 10             	add    $0x10,%esp
    va_end(args);

    //mutex_lock(&log_mutex);
    irq_state_t state = irq_enter_protection();
   1410e:	e8 09 ee ff ff       	call   12f1c <irq_enter_protection>
   14113:	89 45 f0             	mov    %eax,-0x10(%ebp)
    const char *p = buf;
   14116:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
   1411c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while (*p != '\0')
   1411f:	eb 39                	jmp    1415a <log_printf+0x93>
    {
        while ((inb(COM_PORT + 5) & (1 << 6)) == 0);
   14121:	90                   	nop
   14122:	83 ec 0c             	sub    $0xc,%esp
   14125:	68 fd 03 00 00       	push   $0x3fd
   1412a:	e8 bf fe ff ff       	call   13fee <inb>
   1412f:	83 c4 10             	add    $0x10,%esp
   14132:	0f b6 c0             	movzbl %al,%eax
   14135:	83 e0 40             	and    $0x40,%eax
   14138:	85 c0                	test   %eax,%eax
   1413a:	74 e6                	je     14122 <log_printf+0x5b>
        outb(COM_PORT, *p);
   1413c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1413f:	0f b6 00             	movzbl (%eax),%eax
   14142:	0f b6 c0             	movzbl %al,%eax
   14145:	83 ec 08             	sub    $0x8,%esp
   14148:	50                   	push   %eax
   14149:	68 f8 03 00 00       	push   $0x3f8
   1414e:	e8 b8 fe ff ff       	call   1400b <outb>
   14153:	83 c4 10             	add    $0x10,%esp
        p++;
   14156:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    while (*p != '\0')
   1415a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1415d:	0f b6 00             	movzbl (%eax),%eax
   14160:	84 c0                	test   %al,%al
   14162:	75 bd                	jne    14121 <log_printf+0x5a>
    } 

    outb(COM_PORT, '\r');
   14164:	83 ec 08             	sub    $0x8,%esp
   14167:	6a 0d                	push   $0xd
   14169:	68 f8 03 00 00       	push   $0x3f8
   1416e:	e8 98 fe ff ff       	call   1400b <outb>
   14173:	83 c4 10             	add    $0x10,%esp
    //outb(COM_PORT, '\n');
    irq_leave_protection(state);
   14176:	83 ec 0c             	sub    $0xc,%esp
   14179:	ff 75 f0             	pushl  -0x10(%ebp)
   1417c:	e8 b3 ed ff ff       	call   12f34 <irq_leave_protection>
   14181:	83 c4 10             	add    $0x10,%esp
    //mutex_unlock(&log_mutex);
}
   14184:	90                   	nop
   14185:	c9                   	leave  
   14186:	c3                   	ret    

Disassembly of section .first_task:

80000000 <first_task_entry>:
    .text
	.global first_task_entry
	.extern first_task_main
first_task_entry:
	mov %ss, %ax
80000000:	66 8c d0             	mov    %ss,%ax
	mov %ax, %ds
80000003:	8e d8                	mov    %eax,%ds
	mov %ax, %es
80000005:	8e c0                	mov    %eax,%es
	mov %ax, %fs
80000007:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
80000009:	8e e8                	mov    %eax,%gs
	
8000000b:	e9 ec 00 00 00       	jmp    800000fc <first_task_main>

80000010 <sys_call>:
}syscall_args_t;



static inline int sys_call(syscall_args_t *args)
{
80000010:	55                   	push   %ebp
80000011:	89 e5                	mov    %esp,%ebp
80000013:	57                   	push   %edi
80000014:	56                   	push   %esi
80000015:	53                   	push   %ebx
80000016:	83 ec 10             	sub    $0x10,%esp
    int ret;
    uint32_t addr[] = {0,SELECTOR_SYSCALL | 0};
80000019:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
80000020:	c7 45 ec 28 00 00 00 	movl   $0x28,-0x14(%ebp)
            "push %[arg1]\n\t"
            "push %[arg0]\n\t"
            "push %[id]\n\t"
            "lcalll *(%[a])"
            :"=a"(ret)
            :[arg3]"r"(args->arg3), [arg2]"r"(args->arg2), [arg1]"r"(args->arg1),
80000027:	8b 45 08             	mov    0x8(%ebp),%eax
8000002a:	8b 40 10             	mov    0x10(%eax),%eax
8000002d:	8b 55 08             	mov    0x8(%ebp),%edx
80000030:	8b 52 0c             	mov    0xc(%edx),%edx
80000033:	8b 4d 08             	mov    0x8(%ebp),%ecx
80000036:	8b 49 08             	mov    0x8(%ecx),%ecx
            [arg0]"r"(args->arg0), [id]"r"(args->id),
80000039:	8b 5d 08             	mov    0x8(%ebp),%ebx
8000003c:	8b 5b 04             	mov    0x4(%ebx),%ebx
8000003f:	8b 75 08             	mov    0x8(%ebp),%esi
80000042:	8b 36                	mov    (%esi),%esi
    __asm__ __volatile__(
80000044:	8d 7d e8             	lea    -0x18(%ebp),%edi
80000047:	50                   	push   %eax
80000048:	52                   	push   %edx
80000049:	51                   	push   %ecx
8000004a:	53                   	push   %ebx
8000004b:	56                   	push   %esi
8000004c:	ff 1f                	lcall  *(%edi)
8000004e:	89 45 f0             	mov    %eax,-0x10(%ebp)
            [a]"r"(addr));
    return ret;
80000051:	8b 45 f0             	mov    -0x10(%ebp),%eax

}
80000054:	83 c4 10             	add    $0x10,%esp
80000057:	5b                   	pop    %ebx
80000058:	5e                   	pop    %esi
80000059:	5f                   	pop    %edi
8000005a:	5d                   	pop    %ebp
8000005b:	c3                   	ret    

8000005c <msleep>:
static inline void msleep(int ms)
{
8000005c:	55                   	push   %ebp
8000005d:	89 e5                	mov    %esp,%ebp
8000005f:	83 ec 20             	sub    $0x20,%esp
    if(ms <= 0)
80000062:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
80000066:	7e 1b                	jle    80000083 <msleep+0x27>
    {
        return;
    }
    syscall_args_t args;
    args.id = SYS_sleep;
80000068:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    args.arg0 = ms;
8000006f:	8b 45 08             	mov    0x8(%ebp),%eax
80000072:	89 45 f0             	mov    %eax,-0x10(%ebp)
    sys_call(&args);
80000075:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000078:	50                   	push   %eax
80000079:	e8 92 ff ff ff       	call   80000010 <sys_call>
8000007e:	83 c4 04             	add    $0x4,%esp
80000081:	eb 01                	jmp    80000084 <msleep+0x28>
        return;
80000083:	90                   	nop
}
80000084:	c9                   	leave  
80000085:	c3                   	ret    

80000086 <getpid>:
static inline int getpid()
{
80000086:	55                   	push   %ebp
80000087:	89 e5                	mov    %esp,%ebp
80000089:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_getpid;
8000008c:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
    return sys_call(&args);
80000093:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000096:	50                   	push   %eax
80000097:	e8 74 ff ff ff       	call   80000010 <sys_call>
8000009c:	83 c4 04             	add    $0x4,%esp
}
8000009f:	c9                   	leave  
800000a0:	c3                   	ret    

800000a1 <print_msg>:
static inline void print_msg(const char *msg,int arg)
{
800000a1:	55                   	push   %ebp
800000a2:	89 e5                	mov    %esp,%ebp
800000a4:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_print_msg;
800000a7:	c7 45 ec 64 00 00 00 	movl   $0x64,-0x14(%ebp)
    args.arg0 = (int)msg;
800000ae:	8b 45 08             	mov    0x8(%ebp),%eax
800000b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = arg;
800000b4:	8b 45 0c             	mov    0xc(%ebp),%eax
800000b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    sys_call(&args);
800000ba:	8d 45 ec             	lea    -0x14(%ebp),%eax
800000bd:	50                   	push   %eax
800000be:	e8 4d ff ff ff       	call   80000010 <sys_call>
800000c3:	83 c4 04             	add    $0x4,%esp
}
800000c6:	90                   	nop
800000c7:	c9                   	leave  
800000c8:	c3                   	ret    

800000c9 <fork>:

static inline int fork()
{
800000c9:	55                   	push   %ebp
800000ca:	89 e5                	mov    %esp,%ebp
800000cc:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_fork;
800000cf:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
    return sys_call(&args);
800000d6:	8d 45 ec             	lea    -0x14(%ebp),%eax
800000d9:	50                   	push   %eax
800000da:	e8 31 ff ff ff       	call   80000010 <sys_call>
800000df:	83 c4 04             	add    $0x4,%esp
}
800000e2:	c9                   	leave  
800000e3:	c3                   	ret    

800000e4 <init_task_entry>:
static uint32_t init_task_stack[1024];
static uint32_t init_task_stack_test[1024];

static task_t init_task;
void init_task_entry(void)
{
800000e4:	55                   	push   %ebp
800000e5:	89 e5                	mov    %esp,%ebp
    // 测试1：最简单的死循环
    for(;;) {
        // 什么都不做，看看是否死掉
        print_msg("init task pid: %d\n",getpid());
800000e7:	e8 9a ff ff ff       	call   80000086 <getpid>
800000ec:	50                   	push   %eax
800000ed:	68 84 22 00 80       	push   $0x80002284
800000f2:	e8 aa ff ff ff       	call   800000a1 <print_msg>
800000f7:	83 c4 08             	add    $0x8,%esp
800000fa:	eb eb                	jmp    800000e7 <init_task_entry+0x3>

800000fc <first_task_main>:
    }
} 
int first_task_main()
{
800000fc:	55                   	push   %ebp
800000fd:	89 e5                	mov    %esp,%ebp
800000ff:	83 ec 20             	sub    $0x20,%esp
        // msleep(1000);
        // print_msg("first task pid: %d\n",pid);
        //sys_sleep(1000);
        //schedule_next_task(task_current(), &init_task);
        //sys_sleep(1000);
    int count = 3;
80000102:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
    int pid = getpid();
80000109:	e8 78 ff ff ff       	call   80000086 <getpid>
8000010e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    print_msg("parent task pid: %d\n",pid);
80000111:	ff 75 f8             	pushl  -0x8(%ebp)
80000114:	68 97 22 00 80       	push   $0x80002297
80000119:	e8 83 ff ff ff       	call   800000a1 <print_msg>
8000011e:	83 c4 08             	add    $0x8,%esp
    pid = fork();
80000121:	e8 a3 ff ff ff       	call   800000c9 <fork>
80000126:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(pid < 0)
80000129:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
8000012d:	79 11                	jns    80000140 <first_task_main+0x44>
    {
        print_msg("fork failed :%d\n",0);
8000012f:	6a 00                	push   $0x0
80000131:	68 ac 22 00 80       	push   $0x800022ac
80000136:	e8 66 ff ff ff       	call   800000a1 <print_msg>
8000013b:	83 c4 08             	add    $0x8,%esp
8000013e:	eb 61                	jmp    800001a1 <first_task_main+0xa5>
    }
    else if(pid == 0)
80000140:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
80000144:	75 42                	jne    80000188 <first_task_main+0x8c>
    {
        char * argv[] = {"arg0","arg1","arg2","arg3"};
80000146:	c7 45 e8 bd 22 00 80 	movl   $0x800022bd,-0x18(%ebp)
8000014d:	c7 45 ec c2 22 00 80 	movl   $0x800022c2,-0x14(%ebp)
80000154:	c7 45 f0 c7 22 00 80 	movl   $0x800022c7,-0x10(%ebp)
8000015b:	c7 45 f4 cc 22 00 80 	movl   $0x800022cc,-0xc(%ebp)
        //execve("/shell.elf",argv,(char **)0);
        for(;;)
        {
            print_msg("child task count: %d\n",count++);
80000162:	8b 45 fc             	mov    -0x4(%ebp),%eax
80000165:	8d 50 01             	lea    0x1(%eax),%edx
80000168:	89 55 fc             	mov    %edx,-0x4(%ebp)
8000016b:	50                   	push   %eax
8000016c:	68 d1 22 00 80       	push   $0x800022d1
80000171:	e8 2b ff ff ff       	call   800000a1 <print_msg>
80000176:	83 c4 08             	add    $0x8,%esp
            msleep(1000);
80000179:	68 e8 03 00 00       	push   $0x3e8
8000017e:	e8 d9 fe ff ff       	call   8000005c <msleep>
80000183:	83 c4 04             	add    $0x4,%esp
            print_msg("child task count: %d\n",count++);
80000186:	eb da                	jmp    80000162 <first_task_main+0x66>
    else
    {
        for(;;)
        {
            //print_msg("child task pid: %d\n",pid);
            print_msg("parent task count: %d\n",count++);
80000188:	8b 45 fc             	mov    -0x4(%ebp),%eax
8000018b:	8d 50 01             	lea    0x1(%eax),%edx
8000018e:	89 55 fc             	mov    %edx,-0x4(%ebp)
80000191:	50                   	push   %eax
80000192:	68 e7 22 00 80       	push   $0x800022e7
80000197:	e8 05 ff ff ff       	call   800000a1 <print_msg>
8000019c:	83 c4 08             	add    $0x8,%esp
8000019f:	eb e7                	jmp    80000188 <first_task_main+0x8c>
        }
        
    }
    for(;;)
    {
        msleep(3000);
800001a1:	68 b8 0b 00 00       	push   $0xbb8
800001a6:	e8 b1 fe ff ff       	call   8000005c <msleep>
800001ab:	83 c4 04             	add    $0x4,%esp
800001ae:	eb f1                	jmp    800001a1 <first_task_main+0xa5>
800001b0:	66 90                	xchg   %ax,%ax
800001b2:	66 90                	xchg   %ax,%ax
800001b4:	66 90                	xchg   %ax,%ax
800001b6:	66 90                	xchg   %ax,%ax
800001b8:	66 90                	xchg   %ax,%ax
800001ba:	66 90                	xchg   %ax,%ax
800001bc:	66 90                	xchg   %ax,%ax
800001be:	66 90                	xchg   %ax,%ax

800001c0 <init_task_stack>:
	...

800011c0 <init_task_stack_test>:
	...

800021c0 <init_task>:
	...
80002284:	69 6e 69 74 20 74 61 73 6b 20 70 69 64 3a 20 25     init task pid: %
80002294:	64 0a 00 70 61 72 65 6e 74 20 74 61 73 6b 20 70     d..parent task p
800022a4:	69 64 3a 20 25 64 0a 00 66 6f 72 6b 20 66 61 69     id: %d..fork fai
800022b4:	6c 65 64 20 3a 25 64 0a 00 61 72 67 30 00 61 72     led :%d..arg0.ar
800022c4:	67 31 00 61 72 67 32 00 61 72 67 33 00 63 68 69     g1.arg2.arg3.chi
800022d4:	6c 64 20 74 61 73 6b 20 63 6f 75 6e 74 3a 20 25     ld task count: %
800022e4:	64 0a 00 70 61 72 65 6e 74 20 74 61 73 6b 20 63     d..parent task c
800022f4:	6f 75 6e 74 3a 20 25 64 0a 00                       ount: %d..
