
E:/ubuntu/diy-x86os/start/start/build/source/kernel/kernel.elf:     file format elf32-i386
E:/ubuntu/diy-x86os/start/start/build/source/kernel/kernel.elf
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00010000

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x000025e4 memsz 0x000085e0 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002211  00010000  00010000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       000003cc  00012214  00012214  00003214  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00000004  000125e0  000125e0  000035e0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00005fe0  00012600  00012600  000035e4  2**5
                  ALLOC
  4 .debug_line   000014a4  00000000  00000000  000035e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00003305  00000000  00000000  00004a88  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000d83  00000000  00000000  00007d8d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000160  00000000  00000000  00008b10  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    00000d37  00000000  00000000  00008c70  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      00000011  00000000  00000000  000099a7  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000f30  00000000  00000000  000099b8  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
00012214 l    d  .rodata	00000000 .rodata
000125e0 l    d  .data	00000000 .data
00012600 l    d  .bss	00000000 .bss
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 source/kernel/CMakeFiles/kernel.dir/init/start.S.obj
00010013 l       .text	00000000 gdt_reload
00000000 l    df *ABS*	00000000 task.c
000102f8 l     F .text	0000001b list_node_init
00010313 l     F .text	0000000b list_node_next
0001031e l     F .text	0000000b list_count
00010329 l     F .text	0000000a list_first
00010333 l     F .text	00000007 hlt
0001033a l     F .text	00000017 write_tr
00012620 l     O .bss	000001a4 task_manager
000127e0 l     O .bss	00001000 idle_task_stack
00010351 l     F .text	00000104 tss_init
00010593 l     F .text	0000000a idle_task_entry
00000000 l    df *ABS*	00000000 cpu.c
000109f7 l     F .text	00000028 lgdt
00010a1f l     F .text	0000001a far_jump
000137e0 l     O .bss	00000800 gdt_table
00013fe0 l     O .bss	00000014 gdt_mutex
00000000 l    df *ABS*	00000000 irq.c
00010c0d l     F .text	0000001d inb
00010c2a l     F .text	0000001f outb
00010c49 l     F .text	00000007 cli
00010c50 l     F .text	00000007 sti
00010c57 l     F .text	00000028 lidt
00010c7f l     F .text	00000007 hlt
00010c86 l     F .text	00000010 read_eflags
00010c96 l     F .text	0000000b write_eflags
00014000 l     O .bss	00000400 idt_table
00010ca1 l     F .text	000000e3 dump_core_regs
00010d84 l     F .text	0000003e do_default_handler
0001100e l     F .text	00000093 init_pic
00000000 l    df *ABS*	00000000 time.c
00011421 l     F .text	0000001f outb
00014400 l     O .bss	00000004 sys_tick
00011468 l     F .text	00000060 init_pit
00000000 l    df *ABS*	00000000 init.c
00014420 l     O .bss	000000b8 init_task
000144e0 l     O .bss	00001000 init_task_stack
000154e0 l     O .bss	000000b8 test_task
000155a0 l     O .bss	00001000 test_task_stack
000165a0 l     O .bss	00000010 sem
000165b0 l     O .bss	00000014 mutex
000165c4 l     O .bss	00000004 gobal_count
00000000 l    df *ABS*	00000000 mutex.c
000116c6 l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 sem.c
00011847 l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 klib.c
0001198b l     F .text	00000007 hlt
000125e0 l     O .data	00000004 num2ch.1895
00000000 l    df *ABS*	00000000 list.c
00011e78 l     F .text	00000013 list_is_empty
00000000 l    df *ABS*	00000000 log.c
0001206e l     F .text	0000001d inb
0001208b l     F .text	0000001f outb
000165c8 l     O .bss	00000014 log_mutex
00010fba g     F .text	0000001c do_handler_simd_floating_point
00011ae4 g     F .text	0000004f kernel_memcpy
000106e1 g     F .text	0000000a task_current
000113c2 g     F .text	0000000b irq_enable_global
00011f0f g     F .text	00000064 list_insert_last
00010ef6 g     F .text	0000001c do_handler_segment_not_present
00010681 g     F .text	00000035 task_set_ready
00011b33 g     F .text	0000003a kernel_memset
000102ca g       .text	00000000 interrupt_switch
000100ac g       .text	00000000 exception_handler_nmi
00010bdb g     F .text	0000001e cpu_init
000120aa g     F .text	0000009d log_init
000115c6 g     F .text	00000100 init_main
00010233 g       .text	00000000 exception_handler_alignment_check
000102ad g       .text	00000000 exception_handler_security
000108f1 g     F .text	0000004e do_schedule_switch
00011992 g     F .text	00000033 kernel_strcpy
00012600 g     O .bss	00000004 need_reschedule
000112a1 g     F .text	0000008b irq_enable
0001004f g       .text	00000000 exception_handler_unknown
000100cb g       .text	00000000 exception_handler_breakpoint
00010e86 g     F .text	0000001c do_handler_invalid_op
00010e4e g     F .text	0000001c do_handler_overflow
0001026f g       .text	00000000 exception_handler_simd_floating_point
00010f82 g     F .text	0000001c do_handler_alignment_check
000101da g       .text	00000000 exception_handler_general_protection
00010f2e g     F .text	0000001c do_handler_general_protection
00011962 g     F .text	00000029 sem_count
00010dde g     F .text	0000001c do_handler_divider
00010ebe g     F .text	0000001c do_handler_double_fault
00011502 g     F .text	00000062 init_task_entry
00010f4a g     F .text	0000001c do_handler_page_fault
00010166 g       .text	00000000 exception_handler_double_fault
000113cd g     F .text	0000002b pic_send_eoi
00010677 g     F .text	0000000a task_first_task
00011875 g     F .text	0000006b sem_wait
00010ff2 g     F .text	0000001c do_handler_security
000101bd g       .text	00000000 exception_handler_stack_segment_fault
000100ea g       .text	00000000 exception_handler_overflow
000102e1 g       .text	00000000 simple_switch
0001002b g       .text	00000000 exception_handler_time
00010dfa g     F .text	0000001c do_handler_debug
000165e0 g     O .bss	00002000 stack
0001066d g     F .text	0000000a task_is_need_reschedule
0001099a g     F .text	0000005d sys_sleep
0001079c g     F .text	00000013 schedule_switch
00011564 g     F .text	00000062 test_task_entry
000118e0 g     F .text	00000082 sem_notify
00010183 g       .text	00000000 exception_handler_invalid_tss
0001061c g     F .text	0000003d task_first_init
00010f9e g     F .text	0000001c do_handler_machine_check
00011eb0 g     F .text	0000005f list_insert_first
0001097a g     F .text	00000020 task_set_wakeup
0001006e g       .text	00000000 exception_handler_divider
000119c5 g     F .text	0000006a kernel_strncpy
000113b7 g     F .text	0000000b irq_disable_global
000106eb g     F .text	00000061 sys_sched_yield
000114e0 g     F .text	00000022 kernel_init
00011852 g     F .text	00000023 sem_init
00010000 g       .text	00000000 _start
00011cd4 g     F .text	0000014b kernel_vsprintf
00010659 g     F .text	0000000a get_from_task
000116fd g     F .text	00000090 mutex_lock
00010250 g       .text	00000000 exception_handler_machine_check
00010663 g     F .text	0000000a get_to_task
00010eda g     F .text	0000001c do_handler_invalid_tss
0001093f g     F .text	0000003b task_set_sleep
00011e1f g     F .text	00000059 panic
00011261 g     F .text	00000040 irq_install
00010b6e g     F .text	0000006d init_gdt
00010e16 g     F .text	0000001c do_handler_nmi
000113f8 g     F .text	00000018 irq_enter_protection
000116d1 g     F .text	0000002c mutex_init
0001028e g       .text	00000000 exception_handler_virtualization
0001132c g     F .text	0000008b irq_disable
00010ea2 g     F .text	0000001c do_handler_device_not_available
000107af g     F .text	00000065 task_dispatch
00010bf9 g     F .text	00000014 switch_to_tss
00010e6a g     F .text	0000001c do_handler_bounds
0001074c g     F .text	00000050 task_next_run
00011b6d g     F .text	00000064 kernel_memcmp
00011e8b g     F .text	00000025 list_init
000101f7 g       .text	00000000 exception_handler_page_fault
000106b6 g     F .text	0000002b task_set_block
00010dc2 g     F .text	0000001c do_handler_unknown
00010575 g     F .text	0000001e task_switch_from_to
000110a1 g     F .text	000001c0 irq_init
0001178d g     F .text	000000ba mutex_unlock
00010fd6 g     F .text	0000001c do_handler_virtualization
00011410 g     F .text	00000011 irq_leave_protection
00010f66 g     F .text	0000001c do_handler_x87_floating_point
00011aa9 g     F .text	0000003b kernel_strlen
0001008d g       .text	00000000 exception_handler_debug
00010a39 g     F .text	00000083 segment_desc_set
00010128 g       .text	00000000 exception_handler_invalid_op
00011f73 g     F .text	00000077 list_remove_first
00011a2f g     F .text	0000007a kernel_strncmp
000101a0 g       .text	00000000 exception_handler_segment_not_present
0001059d g     F .text	0000007f task_manager_init
00010814 g     F .text	000000dd task_time_tick
00010f12 g     F .text	0000001c do_handler_stack_segment_fault
00010e32 g     F .text	0000001c do_handler_breakpoint
00012147 g     F .text	000000ca log_printf
00010455 g     F .text	00000120 task_init
00010214 g       .text	00000000 exception_handler_x87_floating_point
00011cb0 g     F .text	00000024 kernel_sprintf
00010b03 g     F .text	0000006b gdt_alloc_desc
00011bd1 g     F .text	000000df kernel_itoa
00011fea g     F .text	00000084 list_remove
00010abc g     F .text	00000047 gate_desc_set
00010109 g       .text	00000000 exception_handler_bounds
00010147 g       .text	00000000 exception_handler_device_not_available
00011440 g     F .text	00000028 do_handler_time
000114c8 g     F .text	00000018 time_init



Disassembly of section .text:

00010000 <_start>:
    .extern kernel_init
    .global _start
    .extern init_main
    .extern need_reschedule
_start:
    push %ebp
   10000:	55                   	push   %ebp
    mov %esp, %ebp
   10001:	89 e5                	mov    %esp,%ebp
    mov 0x8(%ebp), %eax
   10003:	8b 45 08             	mov    0x8(%ebp),%eax

    # mov 4(%esp), %eax

    push %eax 
   10006:	50                   	push   %eax
    call kernel_init
   10007:	e8 d4 14 00 00       	call   114e0 <kernel_init>

    jmp $KERNEL_SELECTOR_CS, $gdt_reload
   1000c:	ea 13 00 01 00 08 00 	ljmp   $0x8,$0x10013

00010013 <gdt_reload>:

gdt_reload:
    mov $KERNEL_SELECTOR_DS, %ax
   10013:	66 b8 10 00          	mov    $0x10,%ax
    mov %ax, %ds
   10017:	8e d8                	mov    %eax,%ds
    mov %ax, %es
   10019:	8e c0                	mov    %eax,%es
    mov %ax, %fs
   1001b:	8e e0                	mov    %eax,%fs
    mov %ax, %gs
   1001d:	8e e8                	mov    %eax,%gs
    mov %ax, %ss    
   1001f:	8e d0                	mov    %eax,%ss
    
    mov $(stack + KERNEL_STACK_SIZE), %esp
   10021:	bc e0 85 01 00       	mov    $0x185e0,%esp
    jmp init_main
   10026:	e9 9b 15 00 00       	jmp    115c6 <init_main>

0001002b <exception_handler_time>:

.text
    .extern do_handler_time
    .global exception_handler_time
exception_handler_time:
    push $0
   1002b:	6a 00                	push   $0x0

    push $0x20
   1002d:	6a 20                	push   $0x20
    pusha
   1002f:	60                   	pusha  
    push %ds
   10030:	1e                   	push   %ds
    push %es
   10031:	06                   	push   %es
    push %fs
   10032:	0f a0                	push   %fs
    push %gs
   10034:	0f a8                	push   %gs
    push %esp
   10036:	54                   	push   %esp
    call do_handler_time
   10037:	e8 04 14 00 00       	call   11440 <do_handler_time>
    add $(1*4), %esp
   1003c:	83 c4 04             	add    $0x4,%esp
    pop %gs
   1003f:	0f a9                	pop    %gs
    pop %fs
   10041:	0f a1                	pop    %fs
    pop %es
   10043:	07                   	pop    %es
    pop %ds
   10044:	1f                   	pop    %ds
    popa
   10045:	61                   	popa   

    add $(2*4), %esp
   10046:	83 c4 08             	add    $0x8,%esp
    call do_schedule_switch
   10049:	e8 a3 08 00 00       	call   108f1 <do_schedule_switch>

    iret 
   1004e:	cf                   	iret   

0001004f <exception_handler_unknown>:

exception_handler unknown,-1,0
   1004f:	6a 00                	push   $0x0
   10051:	6a ff                	push   $0xffffffff
   10053:	60                   	pusha  
   10054:	1e                   	push   %ds
   10055:	06                   	push   %es
   10056:	0f a0                	push   %fs
   10058:	0f a8                	push   %gs
   1005a:	54                   	push   %esp
   1005b:	e8 62 0d 00 00       	call   10dc2 <do_handler_unknown>
   10060:	83 c4 04             	add    $0x4,%esp
   10063:	0f a9                	pop    %gs
   10065:	0f a1                	pop    %fs
   10067:	07                   	pop    %es
   10068:	1f                   	pop    %ds
   10069:	61                   	popa   
   1006a:	83 c4 08             	add    $0x8,%esp
   1006d:	cf                   	iret   

0001006e <exception_handler_divider>:
exception_handler divider,0,0
   1006e:	6a 00                	push   $0x0
   10070:	6a 00                	push   $0x0
   10072:	60                   	pusha  
   10073:	1e                   	push   %ds
   10074:	06                   	push   %es
   10075:	0f a0                	push   %fs
   10077:	0f a8                	push   %gs
   10079:	54                   	push   %esp
   1007a:	e8 5f 0d 00 00       	call   10dde <do_handler_divider>
   1007f:	83 c4 04             	add    $0x4,%esp
   10082:	0f a9                	pop    %gs
   10084:	0f a1                	pop    %fs
   10086:	07                   	pop    %es
   10087:	1f                   	pop    %ds
   10088:	61                   	popa   
   10089:	83 c4 08             	add    $0x8,%esp
   1008c:	cf                   	iret   

0001008d <exception_handler_debug>:
exception_handler debug,1,0
   1008d:	6a 00                	push   $0x0
   1008f:	6a 01                	push   $0x1
   10091:	60                   	pusha  
   10092:	1e                   	push   %ds
   10093:	06                   	push   %es
   10094:	0f a0                	push   %fs
   10096:	0f a8                	push   %gs
   10098:	54                   	push   %esp
   10099:	e8 5c 0d 00 00       	call   10dfa <do_handler_debug>
   1009e:	83 c4 04             	add    $0x4,%esp
   100a1:	0f a9                	pop    %gs
   100a3:	0f a1                	pop    %fs
   100a5:	07                   	pop    %es
   100a6:	1f                   	pop    %ds
   100a7:	61                   	popa   
   100a8:	83 c4 08             	add    $0x8,%esp
   100ab:	cf                   	iret   

000100ac <exception_handler_nmi>:
exception_handler nmi,2,0
   100ac:	6a 00                	push   $0x0
   100ae:	6a 02                	push   $0x2
   100b0:	60                   	pusha  
   100b1:	1e                   	push   %ds
   100b2:	06                   	push   %es
   100b3:	0f a0                	push   %fs
   100b5:	0f a8                	push   %gs
   100b7:	54                   	push   %esp
   100b8:	e8 59 0d 00 00       	call   10e16 <do_handler_nmi>
   100bd:	83 c4 04             	add    $0x4,%esp
   100c0:	0f a9                	pop    %gs
   100c2:	0f a1                	pop    %fs
   100c4:	07                   	pop    %es
   100c5:	1f                   	pop    %ds
   100c6:	61                   	popa   
   100c7:	83 c4 08             	add    $0x8,%esp
   100ca:	cf                   	iret   

000100cb <exception_handler_breakpoint>:
exception_handler breakpoint,3,0
   100cb:	6a 00                	push   $0x0
   100cd:	6a 03                	push   $0x3
   100cf:	60                   	pusha  
   100d0:	1e                   	push   %ds
   100d1:	06                   	push   %es
   100d2:	0f a0                	push   %fs
   100d4:	0f a8                	push   %gs
   100d6:	54                   	push   %esp
   100d7:	e8 56 0d 00 00       	call   10e32 <do_handler_breakpoint>
   100dc:	83 c4 04             	add    $0x4,%esp
   100df:	0f a9                	pop    %gs
   100e1:	0f a1                	pop    %fs
   100e3:	07                   	pop    %es
   100e4:	1f                   	pop    %ds
   100e5:	61                   	popa   
   100e6:	83 c4 08             	add    $0x8,%esp
   100e9:	cf                   	iret   

000100ea <exception_handler_overflow>:
exception_handler overflow,4,0
   100ea:	6a 00                	push   $0x0
   100ec:	6a 04                	push   $0x4
   100ee:	60                   	pusha  
   100ef:	1e                   	push   %ds
   100f0:	06                   	push   %es
   100f1:	0f a0                	push   %fs
   100f3:	0f a8                	push   %gs
   100f5:	54                   	push   %esp
   100f6:	e8 53 0d 00 00       	call   10e4e <do_handler_overflow>
   100fb:	83 c4 04             	add    $0x4,%esp
   100fe:	0f a9                	pop    %gs
   10100:	0f a1                	pop    %fs
   10102:	07                   	pop    %es
   10103:	1f                   	pop    %ds
   10104:	61                   	popa   
   10105:	83 c4 08             	add    $0x8,%esp
   10108:	cf                   	iret   

00010109 <exception_handler_bounds>:
exception_handler bounds,5,0
   10109:	6a 00                	push   $0x0
   1010b:	6a 05                	push   $0x5
   1010d:	60                   	pusha  
   1010e:	1e                   	push   %ds
   1010f:	06                   	push   %es
   10110:	0f a0                	push   %fs
   10112:	0f a8                	push   %gs
   10114:	54                   	push   %esp
   10115:	e8 50 0d 00 00       	call   10e6a <do_handler_bounds>
   1011a:	83 c4 04             	add    $0x4,%esp
   1011d:	0f a9                	pop    %gs
   1011f:	0f a1                	pop    %fs
   10121:	07                   	pop    %es
   10122:	1f                   	pop    %ds
   10123:	61                   	popa   
   10124:	83 c4 08             	add    $0x8,%esp
   10127:	cf                   	iret   

00010128 <exception_handler_invalid_op>:
exception_handler invalid_op,6,0
   10128:	6a 00                	push   $0x0
   1012a:	6a 06                	push   $0x6
   1012c:	60                   	pusha  
   1012d:	1e                   	push   %ds
   1012e:	06                   	push   %es
   1012f:	0f a0                	push   %fs
   10131:	0f a8                	push   %gs
   10133:	54                   	push   %esp
   10134:	e8 4d 0d 00 00       	call   10e86 <do_handler_invalid_op>
   10139:	83 c4 04             	add    $0x4,%esp
   1013c:	0f a9                	pop    %gs
   1013e:	0f a1                	pop    %fs
   10140:	07                   	pop    %es
   10141:	1f                   	pop    %ds
   10142:	61                   	popa   
   10143:	83 c4 08             	add    $0x8,%esp
   10146:	cf                   	iret   

00010147 <exception_handler_device_not_available>:
exception_handler device_not_available,7,0
   10147:	6a 00                	push   $0x0
   10149:	6a 07                	push   $0x7
   1014b:	60                   	pusha  
   1014c:	1e                   	push   %ds
   1014d:	06                   	push   %es
   1014e:	0f a0                	push   %fs
   10150:	0f a8                	push   %gs
   10152:	54                   	push   %esp
   10153:	e8 4a 0d 00 00       	call   10ea2 <do_handler_device_not_available>
   10158:	83 c4 04             	add    $0x4,%esp
   1015b:	0f a9                	pop    %gs
   1015d:	0f a1                	pop    %fs
   1015f:	07                   	pop    %es
   10160:	1f                   	pop    %ds
   10161:	61                   	popa   
   10162:	83 c4 08             	add    $0x8,%esp
   10165:	cf                   	iret   

00010166 <exception_handler_double_fault>:
exception_handler double_fault,8,1
   10166:	6a 08                	push   $0x8
   10168:	60                   	pusha  
   10169:	1e                   	push   %ds
   1016a:	06                   	push   %es
   1016b:	0f a0                	push   %fs
   1016d:	0f a8                	push   %gs
   1016f:	54                   	push   %esp
   10170:	e8 49 0d 00 00       	call   10ebe <do_handler_double_fault>
   10175:	83 c4 04             	add    $0x4,%esp
   10178:	0f a9                	pop    %gs
   1017a:	0f a1                	pop    %fs
   1017c:	07                   	pop    %es
   1017d:	1f                   	pop    %ds
   1017e:	61                   	popa   
   1017f:	83 c4 08             	add    $0x8,%esp
   10182:	cf                   	iret   

00010183 <exception_handler_invalid_tss>:

exception_handler invalid_tss,10,1
   10183:	6a 0a                	push   $0xa
   10185:	60                   	pusha  
   10186:	1e                   	push   %ds
   10187:	06                   	push   %es
   10188:	0f a0                	push   %fs
   1018a:	0f a8                	push   %gs
   1018c:	54                   	push   %esp
   1018d:	e8 48 0d 00 00       	call   10eda <do_handler_invalid_tss>
   10192:	83 c4 04             	add    $0x4,%esp
   10195:	0f a9                	pop    %gs
   10197:	0f a1                	pop    %fs
   10199:	07                   	pop    %es
   1019a:	1f                   	pop    %ds
   1019b:	61                   	popa   
   1019c:	83 c4 08             	add    $0x8,%esp
   1019f:	cf                   	iret   

000101a0 <exception_handler_segment_not_present>:
exception_handler segment_not_present,11,1
   101a0:	6a 0b                	push   $0xb
   101a2:	60                   	pusha  
   101a3:	1e                   	push   %ds
   101a4:	06                   	push   %es
   101a5:	0f a0                	push   %fs
   101a7:	0f a8                	push   %gs
   101a9:	54                   	push   %esp
   101aa:	e8 47 0d 00 00       	call   10ef6 <do_handler_segment_not_present>
   101af:	83 c4 04             	add    $0x4,%esp
   101b2:	0f a9                	pop    %gs
   101b4:	0f a1                	pop    %fs
   101b6:	07                   	pop    %es
   101b7:	1f                   	pop    %ds
   101b8:	61                   	popa   
   101b9:	83 c4 08             	add    $0x8,%esp
   101bc:	cf                   	iret   

000101bd <exception_handler_stack_segment_fault>:
exception_handler stack_segment_fault,12,1
   101bd:	6a 0c                	push   $0xc
   101bf:	60                   	pusha  
   101c0:	1e                   	push   %ds
   101c1:	06                   	push   %es
   101c2:	0f a0                	push   %fs
   101c4:	0f a8                	push   %gs
   101c6:	54                   	push   %esp
   101c7:	e8 46 0d 00 00       	call   10f12 <do_handler_stack_segment_fault>
   101cc:	83 c4 04             	add    $0x4,%esp
   101cf:	0f a9                	pop    %gs
   101d1:	0f a1                	pop    %fs
   101d3:	07                   	pop    %es
   101d4:	1f                   	pop    %ds
   101d5:	61                   	popa   
   101d6:	83 c4 08             	add    $0x8,%esp
   101d9:	cf                   	iret   

000101da <exception_handler_general_protection>:
exception_handler general_protection,13,1
   101da:	6a 0d                	push   $0xd
   101dc:	60                   	pusha  
   101dd:	1e                   	push   %ds
   101de:	06                   	push   %es
   101df:	0f a0                	push   %fs
   101e1:	0f a8                	push   %gs
   101e3:	54                   	push   %esp
   101e4:	e8 45 0d 00 00       	call   10f2e <do_handler_general_protection>
   101e9:	83 c4 04             	add    $0x4,%esp
   101ec:	0f a9                	pop    %gs
   101ee:	0f a1                	pop    %fs
   101f0:	07                   	pop    %es
   101f1:	1f                   	pop    %ds
   101f2:	61                   	popa   
   101f3:	83 c4 08             	add    $0x8,%esp
   101f6:	cf                   	iret   

000101f7 <exception_handler_page_fault>:
exception_handler page_fault,14,1
   101f7:	6a 0e                	push   $0xe
   101f9:	60                   	pusha  
   101fa:	1e                   	push   %ds
   101fb:	06                   	push   %es
   101fc:	0f a0                	push   %fs
   101fe:	0f a8                	push   %gs
   10200:	54                   	push   %esp
   10201:	e8 44 0d 00 00       	call   10f4a <do_handler_page_fault>
   10206:	83 c4 04             	add    $0x4,%esp
   10209:	0f a9                	pop    %gs
   1020b:	0f a1                	pop    %fs
   1020d:	07                   	pop    %es
   1020e:	1f                   	pop    %ds
   1020f:	61                   	popa   
   10210:	83 c4 08             	add    $0x8,%esp
   10213:	cf                   	iret   

00010214 <exception_handler_x87_floating_point>:
exception_handler x87_floating_point,16,0
   10214:	6a 00                	push   $0x0
   10216:	6a 10                	push   $0x10
   10218:	60                   	pusha  
   10219:	1e                   	push   %ds
   1021a:	06                   	push   %es
   1021b:	0f a0                	push   %fs
   1021d:	0f a8                	push   %gs
   1021f:	54                   	push   %esp
   10220:	e8 41 0d 00 00       	call   10f66 <do_handler_x87_floating_point>
   10225:	83 c4 04             	add    $0x4,%esp
   10228:	0f a9                	pop    %gs
   1022a:	0f a1                	pop    %fs
   1022c:	07                   	pop    %es
   1022d:	1f                   	pop    %ds
   1022e:	61                   	popa   
   1022f:	83 c4 08             	add    $0x8,%esp
   10232:	cf                   	iret   

00010233 <exception_handler_alignment_check>:
exception_handler alignment_check,17,1
   10233:	6a 11                	push   $0x11
   10235:	60                   	pusha  
   10236:	1e                   	push   %ds
   10237:	06                   	push   %es
   10238:	0f a0                	push   %fs
   1023a:	0f a8                	push   %gs
   1023c:	54                   	push   %esp
   1023d:	e8 40 0d 00 00       	call   10f82 <do_handler_alignment_check>
   10242:	83 c4 04             	add    $0x4,%esp
   10245:	0f a9                	pop    %gs
   10247:	0f a1                	pop    %fs
   10249:	07                   	pop    %es
   1024a:	1f                   	pop    %ds
   1024b:	61                   	popa   
   1024c:	83 c4 08             	add    $0x8,%esp
   1024f:	cf                   	iret   

00010250 <exception_handler_machine_check>:
exception_handler machine_check,18,0
   10250:	6a 00                	push   $0x0
   10252:	6a 12                	push   $0x12
   10254:	60                   	pusha  
   10255:	1e                   	push   %ds
   10256:	06                   	push   %es
   10257:	0f a0                	push   %fs
   10259:	0f a8                	push   %gs
   1025b:	54                   	push   %esp
   1025c:	e8 3d 0d 00 00       	call   10f9e <do_handler_machine_check>
   10261:	83 c4 04             	add    $0x4,%esp
   10264:	0f a9                	pop    %gs
   10266:	0f a1                	pop    %fs
   10268:	07                   	pop    %es
   10269:	1f                   	pop    %ds
   1026a:	61                   	popa   
   1026b:	83 c4 08             	add    $0x8,%esp
   1026e:	cf                   	iret   

0001026f <exception_handler_simd_floating_point>:
exception_handler simd_floating_point,19,0
   1026f:	6a 00                	push   $0x0
   10271:	6a 13                	push   $0x13
   10273:	60                   	pusha  
   10274:	1e                   	push   %ds
   10275:	06                   	push   %es
   10276:	0f a0                	push   %fs
   10278:	0f a8                	push   %gs
   1027a:	54                   	push   %esp
   1027b:	e8 3a 0d 00 00       	call   10fba <do_handler_simd_floating_point>
   10280:	83 c4 04             	add    $0x4,%esp
   10283:	0f a9                	pop    %gs
   10285:	0f a1                	pop    %fs
   10287:	07                   	pop    %es
   10288:	1f                   	pop    %ds
   10289:	61                   	popa   
   1028a:	83 c4 08             	add    $0x8,%esp
   1028d:	cf                   	iret   

0001028e <exception_handler_virtualization>:
exception_handler virtualization,20,0
   1028e:	6a 00                	push   $0x0
   10290:	6a 14                	push   $0x14
   10292:	60                   	pusha  
   10293:	1e                   	push   %ds
   10294:	06                   	push   %es
   10295:	0f a0                	push   %fs
   10297:	0f a8                	push   %gs
   10299:	54                   	push   %esp
   1029a:	e8 37 0d 00 00       	call   10fd6 <do_handler_virtualization>
   1029f:	83 c4 04             	add    $0x4,%esp
   102a2:	0f a9                	pop    %gs
   102a4:	0f a1                	pop    %fs
   102a6:	07                   	pop    %es
   102a7:	1f                   	pop    %ds
   102a8:	61                   	popa   
   102a9:	83 c4 08             	add    $0x8,%esp
   102ac:	cf                   	iret   

000102ad <exception_handler_security>:
exception_handler security,21,1
   102ad:	6a 15                	push   $0x15
   102af:	60                   	pusha  
   102b0:	1e                   	push   %ds
   102b1:	06                   	push   %es
   102b2:	0f a0                	push   %fs
   102b4:	0f a8                	push   %gs
   102b6:	54                   	push   %esp
   102b7:	e8 36 0d 00 00       	call   10ff2 <do_handler_security>
   102bc:	83 c4 04             	add    $0x4,%esp
   102bf:	0f a9                	pop    %gs
   102c1:	0f a1                	pop    %fs
   102c3:	07                   	pop    %es
   102c4:	1f                   	pop    %ds
   102c5:	61                   	popa   
   102c6:	83 c4 08             	add    $0x8,%esp
   102c9:	cf                   	iret   

000102ca <interrupt_switch>:
*/

    .text  
    .global interrupt_switch
interrupt_switch:
    mov 4(%esp), %eax
   102ca:	8b 44 24 04          	mov    0x4(%esp),%eax
    mov 8(%esp), %edx
   102ce:	8b 54 24 08          	mov    0x8(%esp),%edx

    
    push %ebp
   102d2:	55                   	push   %ebp
    push %ebx
   102d3:	53                   	push   %ebx
    push %esi
   102d4:	56                   	push   %esi
    push %edi
   102d5:	57                   	push   %edi
    pushf                # 保存EFLAGS寄存器
   102d6:	9c                   	pushf  
    mov %esp,(%eax)
   102d7:	89 20                	mov    %esp,(%eax)

    mov %edx,%esp
   102d9:	89 d4                	mov    %edx,%esp
    popf                 # 恢复EFLAGS寄存器
   102db:	9d                   	popf   
    pop %edi
   102dc:	5f                   	pop    %edi
    pop %esi
   102dd:	5e                   	pop    %esi
    pop %ebx
   102de:	5b                   	pop    %ebx
    pop %ebp
   102df:	5d                   	pop    %ebp
    

    ret
   102e0:	c3                   	ret    

000102e1 <simple_switch>:


    .text
    .global simple_switch
simple_switch:
    mov 4(%esp), %eax
   102e1:	8b 44 24 04          	mov    0x4(%esp),%eax
    mov 8(%esp), %edx
   102e5:	8b 54 24 08          	mov    0x8(%esp),%edx

    
    push %ebp
   102e9:	55                   	push   %ebp
    push %ebx
   102ea:	53                   	push   %ebx
    push %esi
   102eb:	56                   	push   %esi
    push %edi
   102ec:	57                   	push   %edi
    pushf                # 保存EFLAGS寄存器
   102ed:	9c                   	pushf  
    mov %esp,(%eax)
   102ee:	89 20                	mov    %esp,(%eax)

    mov %edx,%esp
   102f0:	89 d4                	mov    %edx,%esp
    popf                 # 恢复EFLAGS寄存器
   102f2:	9d                   	popf   
    pop %edi
   102f3:	5f                   	pop    %edi
    pop %esi
   102f4:	5e                   	pop    %esi
    pop %ebx
   102f5:	5b                   	pop    %ebx
    pop %ebp
   102f6:	5d                   	pop    %ebp
    

    ret
   102f7:	c3                   	ret    

000102f8 <list_node_init>:
    struct _list_node_t* next;
}list_node_t;


static inline void list_node_init(list_node_t *node)
{
   102f8:	55                   	push   %ebp
   102f9:	89 e5                	mov    %esp,%ebp
    node->pre = node->next = (list_node_t *)0;
   102fb:	8b 45 08             	mov    0x8(%ebp),%eax
   102fe:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   10305:	8b 45 08             	mov    0x8(%ebp),%eax
   10308:	8b 50 04             	mov    0x4(%eax),%edx
   1030b:	8b 45 08             	mov    0x8(%ebp),%eax
   1030e:	89 10                	mov    %edx,(%eax)
}
   10310:	90                   	nop
   10311:	5d                   	pop    %ebp
   10312:	c3                   	ret    

00010313 <list_node_next>:
static inline list_node_t* list_node_pre(list_node_t* node)
{
    return node->pre;
} 
static inline list_node_t* list_node_next(list_node_t* node)
{
   10313:	55                   	push   %ebp
   10314:	89 e5                	mov    %esp,%ebp
    return node->next;
   10316:	8b 45 08             	mov    0x8(%ebp),%eax
   10319:	8b 40 04             	mov    0x4(%eax),%eax
}
   1031c:	5d                   	pop    %ebp
   1031d:	c3                   	ret    

0001031e <list_count>:
{
    return list->count == 0;
}

static inline int list_count(list_t * list)
{
   1031e:	55                   	push   %ebp
   1031f:	89 e5                	mov    %esp,%ebp
    return list->count;
   10321:	8b 45 08             	mov    0x8(%ebp),%eax
   10324:	8b 40 08             	mov    0x8(%eax),%eax
}
   10327:	5d                   	pop    %ebp
   10328:	c3                   	ret    

00010329 <list_first>:
static inline list_node_t* list_first(list_t * list)
{
   10329:	55                   	push   %ebp
   1032a:	89 e5                	mov    %esp,%ebp
    return list->first;
   1032c:	8b 45 08             	mov    0x8(%ebp),%eax
   1032f:	8b 00                	mov    (%eax),%eax
}
   10331:	5d                   	pop    %ebp
   10332:	c3                   	ret    

00010333 <hlt>:
    uint32_t addr[] = {offset ,selector};
    __asm__ __volatile__("ljmpl *(%[a])"::[a]"r"(addr));
}

static inline void hlt(void)
{
   10333:	55                   	push   %ebp
   10334:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   10336:	f4                   	hlt    
}
   10337:	90                   	nop
   10338:	5d                   	pop    %ebp
   10339:	c3                   	ret    

0001033a <write_tr>:

static inline void write_tr(uint16_t selector)
{
   1033a:	55                   	push   %ebp
   1033b:	89 e5                	mov    %esp,%ebp
   1033d:	83 ec 04             	sub    $0x4,%esp
   10340:	8b 45 08             	mov    0x8(%ebp),%eax
   10343:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    __asm__ __volatile__("ltr %%ax"::"a"(selector));
   10347:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
   1034b:	0f 00 d8             	ltr    %ax
}
   1034e:	90                   	nop
   1034f:	c9                   	leave  
   10350:	c3                   	ret    

00010351 <tss_init>:
#include "cpu/irq.h"
static task_manager_t task_manager;
int need_reschedule = 0;
static uint32_t idle_task_stack[1024];
static int tss_init(task_t *task,uint32_t entry,uint32_t esp)
{
   10351:	55                   	push   %ebp
   10352:	89 e5                	mov    %esp,%ebp
   10354:	83 ec 18             	sub    $0x18,%esp
    int tss_sel = gdt_alloc_desc();
   10357:	e8 a7 07 00 00       	call   10b03 <gdt_alloc_desc>
   1035c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(tss_sel == -1)
   1035f:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
   10363:	75 1a                	jne    1037f <tss_init+0x2e>
    {
        log_printf("tss_init: gdt_alloc_desc failed\n");
   10365:	83 ec 0c             	sub    $0xc,%esp
   10368:	68 14 22 01 00       	push   $0x12214
   1036d:	e8 d5 1d 00 00       	call   12147 <log_printf>
   10372:	83 c4 10             	add    $0x10,%esp
        return -1;
   10375:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1037a:	e9 d4 00 00 00       	jmp    10453 <tss_init+0x102>
    }
    segment_desc_set(tss_sel,(uint32_t)&task->tss,sizeof(tss_t),
   1037f:	8b 45 08             	mov    0x8(%ebp),%eax
   10382:	83 c0 4c             	add    $0x4c,%eax
   10385:	68 89 00 00 00       	push   $0x89
   1038a:	6a 68                	push   $0x68
   1038c:	50                   	push   %eax
   1038d:	ff 75 f4             	pushl  -0xc(%ebp)
   10390:	e8 a4 06 00 00       	call   10a39 <segment_desc_set>
   10395:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL_0 | SEG_TYPE_TSS);
    kernel_memset(&task->tss,0,sizeof(tss_t));
   10398:	8b 45 08             	mov    0x8(%ebp),%eax
   1039b:	83 c0 4c             	add    $0x4c,%eax
   1039e:	83 ec 04             	sub    $0x4,%esp
   103a1:	6a 68                	push   $0x68
   103a3:	6a 00                	push   $0x0
   103a5:	50                   	push   %eax
   103a6:	e8 88 17 00 00       	call   11b33 <kernel_memset>
   103ab:	83 c4 10             	add    $0x10,%esp
    task->tss.eip = entry;
   103ae:	8b 45 08             	mov    0x8(%ebp),%eax
   103b1:	8b 55 0c             	mov    0xc(%ebp),%edx
   103b4:	89 50 6c             	mov    %edx,0x6c(%eax)
    task->tss.esp = task->tss.esp0 = esp;
   103b7:	8b 45 08             	mov    0x8(%ebp),%eax
   103ba:	8b 55 10             	mov    0x10(%ebp),%edx
   103bd:	89 50 50             	mov    %edx,0x50(%eax)
   103c0:	8b 45 08             	mov    0x8(%ebp),%eax
   103c3:	8b 50 50             	mov    0x50(%eax),%edx
   103c6:	8b 45 08             	mov    0x8(%ebp),%eax
   103c9:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
    task->tss.ss = task->tss.ss0 = KERNEL_SELECTOR_DS;
   103cf:	8b 45 08             	mov    0x8(%ebp),%eax
   103d2:	c7 40 54 10 00 00 00 	movl   $0x10,0x54(%eax)
   103d9:	8b 45 08             	mov    0x8(%ebp),%eax
   103dc:	8b 50 54             	mov    0x54(%eax),%edx
   103df:	8b 45 08             	mov    0x8(%ebp),%eax
   103e2:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
    task->tss.es = task->tss.ds = task->tss.fs = task->tss.gs = KERNEL_SELECTOR_DS;
   103e8:	8b 45 08             	mov    0x8(%ebp),%eax
   103eb:	c7 80 a8 00 00 00 10 	movl   $0x10,0xa8(%eax)
   103f2:	00 00 00 
   103f5:	8b 45 08             	mov    0x8(%ebp),%eax
   103f8:	8b 90 a8 00 00 00    	mov    0xa8(%eax),%edx
   103fe:	8b 45 08             	mov    0x8(%ebp),%eax
   10401:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
   10407:	8b 45 08             	mov    0x8(%ebp),%eax
   1040a:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
   10410:	8b 45 08             	mov    0x8(%ebp),%eax
   10413:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
   10419:	8b 45 08             	mov    0x8(%ebp),%eax
   1041c:	8b 90 a0 00 00 00    	mov    0xa0(%eax),%edx
   10422:	8b 45 08             	mov    0x8(%ebp),%eax
   10425:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
    task->tss.cs = KERNEL_SELECTOR_CS;
   1042b:	8b 45 08             	mov    0x8(%ebp),%eax
   1042e:	c7 80 98 00 00 00 08 	movl   $0x8,0x98(%eax)
   10435:	00 00 00 
    task->tss.eflags = EFLAGS_DEFAULT | EFLAGS_IF;
   10438:	8b 45 08             	mov    0x8(%ebp),%eax
   1043b:	c7 40 70 02 02 00 00 	movl   $0x202,0x70(%eax)
    task->tss_sel = tss_sel;
   10442:	8b 45 08             	mov    0x8(%ebp),%eax
   10445:	8b 55 f4             	mov    -0xc(%ebp),%edx
   10448:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
    return 0;
   1044e:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10453:	c9                   	leave  
   10454:	c3                   	ret    

00010455 <task_init>:
int task_init(task_t *task,const char *name,uint32_t entry,uint32_t esp)
{
   10455:	55                   	push   %ebp
   10456:	89 e5                	mov    %esp,%ebp
   10458:	83 ec 18             	sub    $0x18,%esp
    ASSERT(task != (task *)0);
    //tss_init(task,entry,esp);
    uint32_t * pesp = (uint32_t *)esp;
   1045b:	8b 45 14             	mov    0x14(%ebp),%eax
   1045e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(pesp)
   10461:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10465:	74 55                	je     104bc <task_init+0x67>
    {
       *(--pesp) = entry;              // 任务入口地址
   10467:	83 6d f4 04          	subl   $0x4,-0xc(%ebp)
   1046b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1046e:	8b 55 10             	mov    0x10(%ebp),%edx
   10471:	89 10                	mov    %edx,(%eax)
        *(--pesp) = 0;                  // ebp
   10473:	83 6d f4 04          	subl   $0x4,-0xc(%ebp)
   10477:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1047a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        *(--pesp) = 0;                  // ebx
   10480:	83 6d f4 04          	subl   $0x4,-0xc(%ebp)
   10484:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10487:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        *(--pesp) = 0;                  // esi
   1048d:	83 6d f4 04          	subl   $0x4,-0xc(%ebp)
   10491:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10494:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        *(--pesp) = 0;                  // edi
   1049a:	83 6d f4 04          	subl   $0x4,-0xc(%ebp)
   1049e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   104a1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        *(--pesp) = EFLAGS_DEFAULT | EFLAGS_IF; // EFLAGS，允许中断
   104a7:	83 6d f4 04          	subl   $0x4,-0xc(%ebp)
   104ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
   104ae:	c7 00 02 02 00 00    	movl   $0x202,(%eax)
        task->stack = pesp;
   104b4:	8b 45 08             	mov    0x8(%ebp),%eax
   104b7:	8b 55 f4             	mov    -0xc(%ebp),%edx
   104ba:	89 10                	mov    %edx,(%eax)
    }
    kernel_strncpy(task->name,name,TASK_NAME_SIZE);
   104bc:	8b 45 08             	mov    0x8(%ebp),%eax
   104bf:	83 c0 14             	add    $0x14,%eax
   104c2:	83 ec 04             	sub    $0x4,%esp
   104c5:	6a 20                	push   $0x20
   104c7:	ff 75 0c             	pushl  0xc(%ebp)
   104ca:	50                   	push   %eax
   104cb:	e8 f5 14 00 00       	call   119c5 <kernel_strncpy>
   104d0:	83 c4 10             	add    $0x10,%esp
    task->time_ticks = TASK_TIME_SLICE_DEFAULT;
   104d3:	8b 45 08             	mov    0x8(%ebp),%eax
   104d6:	c7 40 10 0a 00 00 00 	movl   $0xa,0x10(%eax)
    task->slice_ticks = task->time_ticks;
   104dd:	8b 45 08             	mov    0x8(%ebp),%eax
   104e0:	8b 50 10             	mov    0x10(%eax),%edx
   104e3:	8b 45 08             	mov    0x8(%ebp),%eax
   104e6:	89 50 0c             	mov    %edx,0xc(%eax)
    task->sleep_ticks = 0;
   104e9:	8b 45 08             	mov    0x8(%ebp),%eax
   104ec:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    task->state = TASK_CREATED;
   104f3:	8b 45 08             	mov    0x8(%ebp),%eax
   104f6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    list_node_init(&task->run_node);
   104fd:	8b 45 08             	mov    0x8(%ebp),%eax
   10500:	83 c0 34             	add    $0x34,%eax
   10503:	83 ec 0c             	sub    $0xc,%esp
   10506:	50                   	push   %eax
   10507:	e8 ec fd ff ff       	call   102f8 <list_node_init>
   1050c:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->all_node);
   1050f:	8b 45 08             	mov    0x8(%ebp),%eax
   10512:	83 c0 3c             	add    $0x3c,%eax
   10515:	83 ec 0c             	sub    $0xc,%esp
   10518:	50                   	push   %eax
   10519:	e8 da fd ff ff       	call   102f8 <list_node_init>
   1051e:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->wait_node);
   10521:	8b 45 08             	mov    0x8(%ebp),%eax
   10524:	83 c0 44             	add    $0x44,%eax
   10527:	83 ec 0c             	sub    $0xc,%esp
   1052a:	50                   	push   %eax
   1052b:	e8 c8 fd ff ff       	call   102f8 <list_node_init>
   10530:	83 c4 10             	add    $0x10,%esp
    irq_state_t state = irq_enter_protection();
   10533:	e8 c0 0e 00 00       	call   113f8 <irq_enter_protection>
   10538:	89 45 f0             	mov    %eax,-0x10(%ebp)
    task_set_ready(task);
   1053b:	83 ec 0c             	sub    $0xc,%esp
   1053e:	ff 75 08             	pushl  0x8(%ebp)
   10541:	e8 3b 01 00 00       	call   10681 <task_set_ready>
   10546:	83 c4 10             	add    $0x10,%esp
    list_insert_last(&task_manager.task_list,&task->all_node);
   10549:	8b 45 08             	mov    0x8(%ebp),%eax
   1054c:	83 c0 3c             	add    $0x3c,%eax
   1054f:	83 ec 08             	sub    $0x8,%esp
   10552:	50                   	push   %eax
   10553:	68 48 26 01 00       	push   $0x12648
   10558:	e8 b2 19 00 00       	call   11f0f <list_insert_last>
   1055d:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(state);
   10560:	83 ec 0c             	sub    $0xc,%esp
   10563:	ff 75 f0             	pushl  -0x10(%ebp)
   10566:	e8 a5 0e 00 00       	call   11410 <irq_leave_protection>
   1056b:	83 c4 10             	add    $0x10,%esp
    return 0;
   1056e:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10573:	c9                   	leave  
   10574:	c3                   	ret    

00010575 <task_switch_from_to>:
void simple_switch(uint32_t ** from,uint32_t *to);
void interrupt_switch(uint32_t ** from,uint32_t *to);
void task_switch_from_to(task_t *from,task_t * to)
{
   10575:	55                   	push   %ebp
   10576:	89 e5                	mov    %esp,%ebp
   10578:	83 ec 08             	sub    $0x8,%esp
    //switch_to_tss(to->tss_sel);
    interrupt_switch(&from->stack,to->stack);
   1057b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1057e:	8b 10                	mov    (%eax),%edx
   10580:	8b 45 08             	mov    0x8(%ebp),%eax
   10583:	83 ec 08             	sub    $0x8,%esp
   10586:	52                   	push   %edx
   10587:	50                   	push   %eax
   10588:	e8 3d fd ff ff       	call   102ca <interrupt_switch>
   1058d:	83 c4 10             	add    $0x10,%esp
}
   10590:	90                   	nop
   10591:	c9                   	leave  
   10592:	c3                   	ret    

00010593 <idle_task_entry>:
static void idle_task_entry(void)
{
   10593:	55                   	push   %ebp
   10594:	89 e5                	mov    %esp,%ebp
    while(1)
    {
        hlt();
   10596:	e8 98 fd ff ff       	call   10333 <hlt>
   1059b:	eb f9                	jmp    10596 <idle_task_entry+0x3>

0001059d <task_manager_init>:
    }
}
void task_manager_init()
{
   1059d:	55                   	push   %ebp
   1059e:	89 e5                	mov    %esp,%ebp
   105a0:	83 ec 08             	sub    $0x8,%esp
    list_init(&task_manager.ready_list);
   105a3:	83 ec 0c             	sub    $0xc,%esp
   105a6:	68 30 26 01 00       	push   $0x12630
   105ab:	e8 db 18 00 00       	call   11e8b <list_init>
   105b0:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.task_list);
   105b3:	83 ec 0c             	sub    $0xc,%esp
   105b6:	68 48 26 01 00       	push   $0x12648
   105bb:	e8 cb 18 00 00       	call   11e8b <list_init>
   105c0:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.sleep_list);
   105c3:	83 ec 0c             	sub    $0xc,%esp
   105c6:	68 3c 26 01 00       	push   $0x1263c
   105cb:	e8 bb 18 00 00       	call   11e8b <list_init>
   105d0:	83 c4 10             	add    $0x10,%esp

    task_manager.current_task = (task_t *)0;
   105d3:	c7 05 2c 26 01 00 00 	movl   $0x0,0x1262c
   105da:	00 00 00 
    task_manager.from_task = (task_t *)0;
   105dd:	c7 05 24 26 01 00 00 	movl   $0x0,0x12624
   105e4:	00 00 00 
    task_manager.to_task = (task_t *)0;
   105e7:	c7 05 28 26 01 00 00 	movl   $0x0,0x12628
   105ee:	00 00 00 
    task_manager.need_reschedule = TASK_NOT_NEED_RESCHEDULE ;
   105f1:	c7 05 20 26 01 00 00 	movl   $0x0,0x12620
   105f8:	00 00 00 

    task_init(&task_manager.idle_task,"idle_task",idle_task_entry,(uint32_t)&idle_task_stack[1024]);
   105fb:	ba e0 37 01 00       	mov    $0x137e0,%edx
   10600:	b8 93 05 01 00       	mov    $0x10593,%eax
   10605:	52                   	push   %edx
   10606:	50                   	push   %eax
   10607:	68 35 22 01 00       	push   $0x12235
   1060c:	68 0c 27 01 00       	push   $0x1270c
   10611:	e8 3f fe ff ff       	call   10455 <task_init>
   10616:	83 c4 10             	add    $0x10,%esp
}
   10619:	90                   	nop
   1061a:	c9                   	leave  
   1061b:	c3                   	ret    

0001061c <task_first_init>:

void task_first_init()
{
   1061c:	55                   	push   %ebp
   1061d:	89 e5                	mov    %esp,%ebp
   1061f:	83 ec 08             	sub    $0x8,%esp
    
    task_init(&task_manager.first_task,"first_task",0,0);
   10622:	6a 00                	push   $0x0
   10624:	6a 00                	push   $0x0
   10626:	68 3f 22 01 00       	push   $0x1223f
   1062b:	68 54 26 01 00       	push   $0x12654
   10630:	e8 20 fe ff ff       	call   10455 <task_init>
   10635:	83 c4 10             	add    $0x10,%esp
    write_tr(task_manager.first_task.tss_sel);
   10638:	a1 08 27 01 00       	mov    0x12708,%eax
   1063d:	0f b7 c0             	movzwl %ax,%eax
   10640:	83 ec 0c             	sub    $0xc,%esp
   10643:	50                   	push   %eax
   10644:	e8 f1 fc ff ff       	call   1033a <write_tr>
   10649:	83 c4 10             	add    $0x10,%esp
    task_manager.current_task = &task_manager.first_task;
   1064c:	c7 05 2c 26 01 00 54 	movl   $0x12654,0x1262c
   10653:	26 01 00 
}
   10656:	90                   	nop
   10657:	c9                   	leave  
   10658:	c3                   	ret    

00010659 <get_from_task>:
task_t * get_from_task()
{
   10659:	55                   	push   %ebp
   1065a:	89 e5                	mov    %esp,%ebp
    return task_manager.from_task;
   1065c:	a1 24 26 01 00       	mov    0x12624,%eax
}
   10661:	5d                   	pop    %ebp
   10662:	c3                   	ret    

00010663 <get_to_task>:
task_t * get_to_task()
{
   10663:	55                   	push   %ebp
   10664:	89 e5                	mov    %esp,%ebp
    return task_manager.to_task;
   10666:	a1 28 26 01 00       	mov    0x12628,%eax
}
   1066b:	5d                   	pop    %ebp
   1066c:	c3                   	ret    

0001066d <task_is_need_reschedule>:
uint32_t task_is_need_reschedule()
{
   1066d:	55                   	push   %ebp
   1066e:	89 e5                	mov    %esp,%ebp
    return task_manager.need_reschedule;
   10670:	a1 20 26 01 00       	mov    0x12620,%eax
}
   10675:	5d                   	pop    %ebp
   10676:	c3                   	ret    

00010677 <task_first_task>:
task_t * task_first_task()
{
   10677:	55                   	push   %ebp
   10678:	89 e5                	mov    %esp,%ebp
    return &task_manager.first_task;
   1067a:	b8 54 26 01 00       	mov    $0x12654,%eax
}
   1067f:	5d                   	pop    %ebp
   10680:	c3                   	ret    

00010681 <task_set_ready>:

void task_set_ready(task_t *task)
{
   10681:	55                   	push   %ebp
   10682:	89 e5                	mov    %esp,%ebp
   10684:	83 ec 08             	sub    $0x8,%esp
    if(task == &task_manager.idle_task)
   10687:	81 7d 08 0c 27 01 00 	cmpl   $0x1270c,0x8(%ebp)
   1068e:	74 23                	je     106b3 <task_set_ready+0x32>
    {
        return;
    }
    list_insert_last(&task_manager.ready_list,&task->run_node);
   10690:	8b 45 08             	mov    0x8(%ebp),%eax
   10693:	83 c0 34             	add    $0x34,%eax
   10696:	83 ec 08             	sub    $0x8,%esp
   10699:	50                   	push   %eax
   1069a:	68 30 26 01 00       	push   $0x12630
   1069f:	e8 6b 18 00 00       	call   11f0f <list_insert_last>
   106a4:	83 c4 10             	add    $0x10,%esp
    task->state = TASK_READY;
   106a7:	8b 45 08             	mov    0x8(%ebp),%eax
   106aa:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
   106b1:	eb 01                	jmp    106b4 <task_set_ready+0x33>
        return;
   106b3:	90                   	nop
}
   106b4:	c9                   	leave  
   106b5:	c3                   	ret    

000106b6 <task_set_block>:

void task_set_block(task_t *task)
{
   106b6:	55                   	push   %ebp
   106b7:	89 e5                	mov    %esp,%ebp
   106b9:	83 ec 08             	sub    $0x8,%esp
    if(task == &task_manager.idle_task)
   106bc:	81 7d 08 0c 27 01 00 	cmpl   $0x1270c,0x8(%ebp)
   106c3:	74 19                	je     106de <task_set_block+0x28>
    {
        return;
    }
    list_remove(&task_manager.ready_list,&task->run_node);
   106c5:	8b 45 08             	mov    0x8(%ebp),%eax
   106c8:	83 c0 34             	add    $0x34,%eax
   106cb:	83 ec 08             	sub    $0x8,%esp
   106ce:	50                   	push   %eax
   106cf:	68 30 26 01 00       	push   $0x12630
   106d4:	e8 11 19 00 00       	call   11fea <list_remove>
   106d9:	83 c4 10             	add    $0x10,%esp
   106dc:	eb 01                	jmp    106df <task_set_block+0x29>
        return;
   106de:	90                   	nop
}
   106df:	c9                   	leave  
   106e0:	c3                   	ret    

000106e1 <task_current>:

task_t * task_current()
{
   106e1:	55                   	push   %ebp
   106e2:	89 e5                	mov    %esp,%ebp
    return task_manager.current_task;
   106e4:	a1 2c 26 01 00       	mov    0x1262c,%eax
}
   106e9:	5d                   	pop    %ebp
   106ea:	c3                   	ret    

000106eb <sys_sched_yield>:
int sys_sched_yield()
{
   106eb:	55                   	push   %ebp
   106ec:	89 e5                	mov    %esp,%ebp
   106ee:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   106f1:	e8 02 0d 00 00       	call   113f8 <irq_enter_protection>
   106f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(list_count(&task_manager.ready_list) > 1)
   106f9:	83 ec 0c             	sub    $0xc,%esp
   106fc:	68 30 26 01 00       	push   $0x12630
   10701:	e8 18 fc ff ff       	call   1031e <list_count>
   10706:	83 c4 10             	add    $0x10,%esp
   10709:	83 f8 01             	cmp    $0x1,%eax
   1070c:	7e 29                	jle    10737 <sys_sched_yield+0x4c>
    {
        task_t * current_task = task_current();
   1070e:	e8 ce ff ff ff       	call   106e1 <task_current>
   10713:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_set_block(current_task);
   10716:	83 ec 0c             	sub    $0xc,%esp
   10719:	ff 75 f0             	pushl  -0x10(%ebp)
   1071c:	e8 95 ff ff ff       	call   106b6 <task_set_block>
   10721:	83 c4 10             	add    $0x10,%esp
        task_set_ready(current_task);
   10724:	83 ec 0c             	sub    $0xc,%esp
   10727:	ff 75 f0             	pushl  -0x10(%ebp)
   1072a:	e8 52 ff ff ff       	call   10681 <task_set_ready>
   1072f:	83 c4 10             	add    $0x10,%esp

        task_dispatch();
   10732:	e8 78 00 00 00       	call   107af <task_dispatch>
    }
    irq_leave_protection(state);
   10737:	83 ec 0c             	sub    $0xc,%esp
   1073a:	ff 75 f4             	pushl  -0xc(%ebp)
   1073d:	e8 ce 0c 00 00       	call   11410 <irq_leave_protection>
   10742:	83 c4 10             	add    $0x10,%esp
    return 0;
   10745:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1074a:	c9                   	leave  
   1074b:	c3                   	ret    

0001074c <task_next_run>:

task_t * task_next_run()
{
   1074c:	55                   	push   %ebp
   1074d:	89 e5                	mov    %esp,%ebp
   1074f:	83 ec 10             	sub    $0x10,%esp
    if(list_count(&task_manager.ready_list) == 0)
   10752:	68 30 26 01 00       	push   $0x12630
   10757:	e8 c2 fb ff ff       	call   1031e <list_count>
   1075c:	83 c4 04             	add    $0x4,%esp
   1075f:	85 c0                	test   %eax,%eax
   10761:	75 07                	jne    1076a <task_next_run+0x1e>
    {
        return &task_manager.idle_task;
   10763:	b8 0c 27 01 00       	mov    $0x1270c,%eax
   10768:	eb 30                	jmp    1079a <task_next_run+0x4e>
    }
    list_node_t * node = list_first(&task_manager.ready_list);
   1076a:	68 30 26 01 00       	push   $0x12630
   1076f:	e8 b5 fb ff ff       	call   10329 <list_first>
   10774:	83 c4 04             	add    $0x4,%esp
   10777:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(node)
   1077a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1077e:	74 15                	je     10795 <task_next_run+0x49>
    {
        return list_node_parent(node,task_t,run_node);
   10780:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10784:	74 08                	je     1078e <task_next_run+0x42>
   10786:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10789:	83 e8 34             	sub    $0x34,%eax
   1078c:	eb 0c                	jmp    1079a <task_next_run+0x4e>
   1078e:	b8 00 00 00 00       	mov    $0x0,%eax
   10793:	eb 05                	jmp    1079a <task_next_run+0x4e>
    }
    return (task_t *)0;
   10795:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1079a:	c9                   	leave  
   1079b:	c3                   	ret    

0001079c <schedule_switch>:

void schedule_switch()
{
   1079c:	55                   	push   %ebp
   1079d:	89 e5                	mov    %esp,%ebp
   1079f:	83 ec 08             	sub    $0x8,%esp
    task_dispatch();
   107a2:	e8 08 00 00 00       	call   107af <task_dispatch>
    do_schedule_switch();
   107a7:	e8 45 01 00 00       	call   108f1 <do_schedule_switch>
}
   107ac:	90                   	nop
   107ad:	c9                   	leave  
   107ae:	c3                   	ret    

000107af <task_dispatch>:
void task_dispatch()
{
   107af:	55                   	push   %ebp
   107b0:	89 e5                	mov    %esp,%ebp
   107b2:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   107b5:	e8 3e 0c 00 00       	call   113f8 <irq_enter_protection>
   107ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t * next_task = task_next_run();
   107bd:	e8 8a ff ff ff       	call   1074c <task_next_run>
   107c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(next_task != task_current())
   107c5:	e8 17 ff ff ff       	call   106e1 <task_current>
   107ca:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   107cd:	74 34                	je     10803 <task_dispatch+0x54>
    {
        task_t * from = task_current();
   107cf:	e8 0d ff ff ff       	call   106e1 <task_current>
   107d4:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_manager.current_task = next_task;
   107d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   107da:	a3 2c 26 01 00       	mov    %eax,0x1262c
        next_task->state = TASK_RUNNING;
   107df:	8b 45 f0             	mov    -0x10(%ebp),%eax
   107e2:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
        task_manager.need_reschedule = TASK_NEED_RESCHEDULE;
   107e9:	c7 05 20 26 01 00 01 	movl   $0x1,0x12620
   107f0:	00 00 00 
        task_manager.from_task = from;
   107f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   107f6:	a3 24 26 01 00       	mov    %eax,0x12624
        task_manager.to_task = next_task;
   107fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   107fe:	a3 28 26 01 00       	mov    %eax,0x12628
    }
    irq_leave_protection(state);
   10803:	83 ec 0c             	sub    $0xc,%esp
   10806:	ff 75 f4             	pushl  -0xc(%ebp)
   10809:	e8 02 0c 00 00       	call   11410 <irq_leave_protection>
   1080e:	83 c4 10             	add    $0x10,%esp
}
   10811:	90                   	nop
   10812:	c9                   	leave  
   10813:	c3                   	ret    

00010814 <task_time_tick>:

void task_time_tick()
{
   10814:	55                   	push   %ebp
   10815:	89 e5                	mov    %esp,%ebp
   10817:	83 ec 18             	sub    $0x18,%esp
    if(task_manager.need_reschedule)
   1081a:	a1 20 26 01 00       	mov    0x12620,%eax
   1081f:	85 c0                	test   %eax,%eax
   10821:	0f 85 c7 00 00 00    	jne    108ee <task_time_tick+0xda>
    {
        return; 
    }
    list_node_t * curr = list_first(&task_manager.sleep_list);
   10827:	68 3c 26 01 00       	push   $0x1263c
   1082c:	e8 f8 fa ff ff       	call   10329 <list_first>
   10831:	83 c4 04             	add    $0x4,%esp
   10834:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(curr)
   10837:	eb 5f                	jmp    10898 <task_time_tick+0x84>
    {
        list_node_t * next = list_node_next(curr);
   10839:	ff 75 f4             	pushl  -0xc(%ebp)
   1083c:	e8 d2 fa ff ff       	call   10313 <list_node_next>
   10841:	83 c4 04             	add    $0x4,%esp
   10844:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_t * task = list_node_parent(curr,task_t,run_node);
   10847:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1084b:	74 08                	je     10855 <task_time_tick+0x41>
   1084d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10850:	83 e8 34             	sub    $0x34,%eax
   10853:	eb 05                	jmp    1085a <task_time_tick+0x46>
   10855:	b8 00 00 00 00       	mov    $0x0,%eax
   1085a:	89 45 e8             	mov    %eax,-0x18(%ebp)
        task->sleep_ticks--;
   1085d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10860:	8b 40 08             	mov    0x8(%eax),%eax
   10863:	8d 50 ff             	lea    -0x1(%eax),%edx
   10866:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10869:	89 50 08             	mov    %edx,0x8(%eax)
        if(task->sleep_ticks <= 0)
   1086c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1086f:	8b 40 08             	mov    0x8(%eax),%eax
   10872:	85 c0                	test   %eax,%eax
   10874:	7f 1c                	jg     10892 <task_time_tick+0x7e>
        {
            task_set_wakeup(task);
   10876:	83 ec 0c             	sub    $0xc,%esp
   10879:	ff 75 e8             	pushl  -0x18(%ebp)
   1087c:	e8 f9 00 00 00       	call   1097a <task_set_wakeup>
   10881:	83 c4 10             	add    $0x10,%esp
            task_set_ready(task);
   10884:	83 ec 0c             	sub    $0xc,%esp
   10887:	ff 75 e8             	pushl  -0x18(%ebp)
   1088a:	e8 f2 fd ff ff       	call   10681 <task_set_ready>
   1088f:	83 c4 10             	add    $0x10,%esp
        }
        curr = next;
   10892:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10895:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(curr)
   10898:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1089c:	75 9b                	jne    10839 <task_time_tick+0x25>
    }
    task_t * current_task = task_current();
   1089e:	e8 3e fe ff ff       	call   106e1 <task_current>
   108a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    current_task->slice_ticks--;
   108a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   108a9:	8b 40 0c             	mov    0xc(%eax),%eax
   108ac:	8d 50 ff             	lea    -0x1(%eax),%edx
   108af:	8b 45 f0             	mov    -0x10(%ebp),%eax
   108b2:	89 50 0c             	mov    %edx,0xc(%eax)
    if(current_task->slice_ticks <= 0)
   108b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   108b8:	8b 40 0c             	mov    0xc(%eax),%eax
   108bb:	85 c0                	test   %eax,%eax
   108bd:	7f 30                	jg     108ef <task_time_tick+0xdb>
    {
        current_task->slice_ticks = current_task->time_ticks;
   108bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   108c2:	8b 50 10             	mov    0x10(%eax),%edx
   108c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   108c8:	89 50 0c             	mov    %edx,0xc(%eax)
        task_set_block(current_task);
   108cb:	83 ec 0c             	sub    $0xc,%esp
   108ce:	ff 75 f0             	pushl  -0x10(%ebp)
   108d1:	e8 e0 fd ff ff       	call   106b6 <task_set_block>
   108d6:	83 c4 10             	add    $0x10,%esp
        task_set_ready(current_task);
   108d9:	83 ec 0c             	sub    $0xc,%esp
   108dc:	ff 75 f0             	pushl  -0x10(%ebp)
   108df:	e8 9d fd ff ff       	call   10681 <task_set_ready>
   108e4:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   108e7:	e8 c3 fe ff ff       	call   107af <task_dispatch>
   108ec:	eb 01                	jmp    108ef <task_time_tick+0xdb>
        return; 
   108ee:	90                   	nop
    }
}
   108ef:	c9                   	leave  
   108f0:	c3                   	ret    

000108f1 <do_schedule_switch>:
void do_schedule_switch(void)
{
   108f1:	55                   	push   %ebp
   108f2:	89 e5                	mov    %esp,%ebp
   108f4:	83 ec 08             	sub    $0x8,%esp
    if (task_manager.need_reschedule) {
   108f7:	a1 20 26 01 00       	mov    0x12620,%eax
   108fc:	85 c0                	test   %eax,%eax
   108fe:	74 3c                	je     1093c <do_schedule_switch+0x4b>
        task_manager.need_reschedule = TASK_NOT_NEED_RESCHEDULE;
   10900:	c7 05 20 26 01 00 00 	movl   $0x0,0x12620
   10907:	00 00 00 
        if (task_manager.from_task && task_manager.from_task != task_manager.to_task) {
   1090a:	a1 24 26 01 00       	mov    0x12624,%eax
   1090f:	85 c0                	test   %eax,%eax
   10911:	74 29                	je     1093c <do_schedule_switch+0x4b>
   10913:	8b 15 24 26 01 00    	mov    0x12624,%edx
   10919:	a1 28 26 01 00       	mov    0x12628,%eax
   1091e:	39 c2                	cmp    %eax,%edx
   10920:	74 1a                	je     1093c <do_schedule_switch+0x4b>
            // 在这里进行任务切换
            // 使用简单的栈切换，避免复杂的中断上下文切换
            simple_switch(&task_manager.from_task->stack, task_manager.to_task->stack);
   10922:	a1 28 26 01 00       	mov    0x12628,%eax
   10927:	8b 00                	mov    (%eax),%eax
   10929:	8b 15 24 26 01 00    	mov    0x12624,%edx
   1092f:	83 ec 08             	sub    $0x8,%esp
   10932:	50                   	push   %eax
   10933:	52                   	push   %edx
   10934:	e8 a8 f9 ff ff       	call   102e1 <simple_switch>
   10939:	83 c4 10             	add    $0x10,%esp
        }
    }
}
   1093c:	90                   	nop
   1093d:	c9                   	leave  
   1093e:	c3                   	ret    

0001093f <task_set_sleep>:

void task_set_sleep(task_t *task,uint32_t ticks)
{
   1093f:	55                   	push   %ebp
   10940:	89 e5                	mov    %esp,%ebp
   10942:	83 ec 08             	sub    $0x8,%esp
    if(ticks == 0)
   10945:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10949:	74 2c                	je     10977 <task_set_sleep+0x38>
    {
        return;
    }
    task->sleep_ticks = ticks;
   1094b:	8b 55 0c             	mov    0xc(%ebp),%edx
   1094e:	8b 45 08             	mov    0x8(%ebp),%eax
   10951:	89 50 08             	mov    %edx,0x8(%eax)
    task->state = TASK_SLEEP;
   10954:	8b 45 08             	mov    0x8(%ebp),%eax
   10957:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
    list_insert_last(&task_manager.sleep_list,&task->run_node);
   1095e:	8b 45 08             	mov    0x8(%ebp),%eax
   10961:	83 c0 34             	add    $0x34,%eax
   10964:	83 ec 08             	sub    $0x8,%esp
   10967:	50                   	push   %eax
   10968:	68 3c 26 01 00       	push   $0x1263c
   1096d:	e8 9d 15 00 00       	call   11f0f <list_insert_last>
   10972:	83 c4 10             	add    $0x10,%esp
   10975:	eb 01                	jmp    10978 <task_set_sleep+0x39>
        return;
   10977:	90                   	nop
}
   10978:	c9                   	leave  
   10979:	c3                   	ret    

0001097a <task_set_wakeup>:

void task_set_wakeup(task_t *task)
{
   1097a:	55                   	push   %ebp
   1097b:	89 e5                	mov    %esp,%ebp
   1097d:	83 ec 08             	sub    $0x8,%esp
    list_remove(&task_manager.sleep_list,&task->run_node);
   10980:	8b 45 08             	mov    0x8(%ebp),%eax
   10983:	83 c0 34             	add    $0x34,%eax
   10986:	83 ec 08             	sub    $0x8,%esp
   10989:	50                   	push   %eax
   1098a:	68 3c 26 01 00       	push   $0x1263c
   1098f:	e8 56 16 00 00       	call   11fea <list_remove>
   10994:	83 c4 10             	add    $0x10,%esp

    //task->state = TASK_READY;
}
   10997:	90                   	nop
   10998:	c9                   	leave  
   10999:	c3                   	ret    

0001099a <sys_sleep>:

void sys_sleep(uint32_t ms)
{
   1099a:	55                   	push   %ebp
   1099b:	89 e5                	mov    %esp,%ebp
   1099d:	53                   	push   %ebx
   1099e:	83 ec 14             	sub    $0x14,%esp
    irq_state_t state = irq_enter_protection();
   109a1:	e8 52 0a 00 00       	call   113f8 <irq_enter_protection>
   109a6:	89 45 f4             	mov    %eax,-0xc(%ebp)

    
    task_set_block(task_current());
   109a9:	e8 33 fd ff ff       	call   106e1 <task_current>
   109ae:	83 ec 0c             	sub    $0xc,%esp
   109b1:	50                   	push   %eax
   109b2:	e8 ff fc ff ff       	call   106b6 <task_set_block>
   109b7:	83 c4 10             	add    $0x10,%esp

    task_set_sleep(task_current(),(ms + (OS_TICK_MS - 1)) / OS_TICK_MS);
   109ba:	8b 45 08             	mov    0x8(%ebp),%eax
   109bd:	83 c0 18             	add    $0x18,%eax
   109c0:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
   109c5:	f7 e2                	mul    %edx
   109c7:	89 d3                	mov    %edx,%ebx
   109c9:	c1 eb 03             	shr    $0x3,%ebx
   109cc:	e8 10 fd ff ff       	call   106e1 <task_current>
   109d1:	83 ec 08             	sub    $0x8,%esp
   109d4:	53                   	push   %ebx
   109d5:	50                   	push   %eax
   109d6:	e8 64 ff ff ff       	call   1093f <task_set_sleep>
   109db:	83 c4 10             	add    $0x10,%esp

    schedule_switch();
   109de:	e8 b9 fd ff ff       	call   1079c <schedule_switch>
    irq_leave_protection(state);
   109e3:	83 ec 0c             	sub    $0xc,%esp
   109e6:	ff 75 f4             	pushl  -0xc(%ebp)
   109e9:	e8 22 0a 00 00       	call   11410 <irq_leave_protection>
   109ee:	83 c4 10             	add    $0x10,%esp
}
   109f1:	90                   	nop
   109f2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   109f5:	c9                   	leave  
   109f6:	c3                   	ret    

000109f7 <lgdt>:
{
   109f7:	55                   	push   %ebp
   109f8:	89 e5                	mov    %esp,%ebp
   109fa:	83 ec 10             	sub    $0x10,%esp
    gdt.start31_16 = start >> 16;
   109fd:	8b 45 08             	mov    0x8(%ebp),%eax
   10a00:	c1 e8 10             	shr    $0x10,%eax
   10a03:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    gdt.start15_0 = start & 0xffff;
   10a07:	8b 45 08             	mov    0x8(%ebp),%eax
   10a0a:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    gdt.limit = size - 1;
   10a0e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a11:	83 e8 01             	sub    $0x1,%eax
   10a14:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__("lgdt %[g]"::[g]"m"(gdt));
   10a18:	0f 01 55 fa          	lgdtl  -0x6(%ebp)
}
   10a1c:	90                   	nop
   10a1d:	c9                   	leave  
   10a1e:	c3                   	ret    

00010a1f <far_jump>:
{
   10a1f:	55                   	push   %ebp
   10a20:	89 e5                	mov    %esp,%ebp
   10a22:	83 ec 10             	sub    $0x10,%esp
    uint32_t addr[] = {offset ,selector};
   10a25:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a28:	89 45 f8             	mov    %eax,-0x8(%ebp)
   10a2b:	8b 45 08             	mov    0x8(%ebp),%eax
   10a2e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    __asm__ __volatile__("ljmpl *(%[a])"::[a]"r"(addr));
   10a31:	8d 45 f8             	lea    -0x8(%ebp),%eax
   10a34:	ff 28                	ljmp   *(%eax)
}
   10a36:	90                   	nop
   10a37:	c9                   	leave  
   10a38:	c3                   	ret    

00010a39 <segment_desc_set>:
#include "ipc/mutex.h"
static segment_desc_t gdt_table[GDT_TABLE_SIZE];
static mutex_t gdt_mutex;

void segment_desc_set(int selector, uint32_t base, uint32_t limit, uint16_t attr)
{
   10a39:	55                   	push   %ebp
   10a3a:	89 e5                	mov    %esp,%ebp
   10a3c:	83 ec 14             	sub    $0x14,%esp
   10a3f:	8b 45 14             	mov    0x14(%ebp),%eax
   10a42:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    segment_desc_t *desc = gdt_table + selector / sizeof(segment_desc_t);
   10a46:	8b 45 08             	mov    0x8(%ebp),%eax
   10a49:	83 e0 f8             	and    $0xfffffff8,%eax
   10a4c:	05 e0 37 01 00       	add    $0x137e0,%eax
   10a51:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(limit > 0xfffff)
   10a54:	81 7d 10 ff ff 0f 00 	cmpl   $0xfffff,0x10(%ebp)
   10a5b:	76 0f                	jbe    10a6c <segment_desc_set+0x33>
    {
        limit /= 0x1000;
   10a5d:	8b 45 10             	mov    0x10(%ebp),%eax
   10a60:	c1 e8 0c             	shr    $0xc,%eax
   10a63:	89 45 10             	mov    %eax,0x10(%ebp)
        attr |= SEG_G;
   10a66:	66 81 4d ec 00 80    	orw    $0x8000,-0x14(%ebp)
    }
    desc->limit15_0 = limit & 0xffff;
   10a6c:	8b 45 10             	mov    0x10(%ebp),%eax
   10a6f:	89 c2                	mov    %eax,%edx
   10a71:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10a74:	66 89 10             	mov    %dx,(%eax)
    desc->base15_0 = base & 0xffff;
   10a77:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a7a:	89 c2                	mov    %eax,%edx
   10a7c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10a7f:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->base23_16 = (base >> 16) & 0xff;
   10a83:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a86:	c1 e8 10             	shr    $0x10,%eax
   10a89:	89 c2                	mov    %eax,%edx
   10a8b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10a8e:	88 50 04             	mov    %dl,0x4(%eax)
    desc->attr = attr | (((limit >> 16) & 0x0f) << 8);
   10a91:	8b 45 10             	mov    0x10(%ebp),%eax
   10a94:	c1 e8 10             	shr    $0x10,%eax
   10a97:	c1 e0 08             	shl    $0x8,%eax
   10a9a:	66 25 00 0f          	and    $0xf00,%ax
   10a9e:	66 0b 45 ec          	or     -0x14(%ebp),%ax
   10aa2:	89 c2                	mov    %eax,%edx
   10aa4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10aa7:	66 89 50 05          	mov    %dx,0x5(%eax)
    desc->base31_24 = (base >> 24) & 0xff;
   10aab:	8b 45 0c             	mov    0xc(%ebp),%eax
   10aae:	c1 e8 18             	shr    $0x18,%eax
   10ab1:	89 c2                	mov    %eax,%edx
   10ab3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10ab6:	88 50 07             	mov    %dl,0x7(%eax)
}
   10ab9:	90                   	nop
   10aba:	c9                   	leave  
   10abb:	c3                   	ret    

00010abc <gate_desc_set>:
void gate_desc_set(gate_desc_t * gate_desc, uint16_t selector, uint32_t offset, uint16_t attr)
{
   10abc:	55                   	push   %ebp
   10abd:	89 e5                	mov    %esp,%ebp
   10abf:	83 ec 08             	sub    $0x8,%esp
   10ac2:	8b 55 0c             	mov    0xc(%ebp),%edx
   10ac5:	8b 45 14             	mov    0x14(%ebp),%eax
   10ac8:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   10acc:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    gate_desc->selector = selector;
   10ad0:	8b 45 08             	mov    0x8(%ebp),%eax
   10ad3:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   10ad7:	66 89 50 02          	mov    %dx,0x2(%eax)
    gate_desc->offset15_0 = offset & 0xffff;
   10adb:	8b 45 10             	mov    0x10(%ebp),%eax
   10ade:	89 c2                	mov    %eax,%edx
   10ae0:	8b 45 08             	mov    0x8(%ebp),%eax
   10ae3:	66 89 10             	mov    %dx,(%eax)
    gate_desc->offset31_16 = (offset >> 16) & 0xffff;
   10ae6:	8b 45 10             	mov    0x10(%ebp),%eax
   10ae9:	c1 e8 10             	shr    $0x10,%eax
   10aec:	89 c2                	mov    %eax,%edx
   10aee:	8b 45 08             	mov    0x8(%ebp),%eax
   10af1:	66 89 50 06          	mov    %dx,0x6(%eax)
    gate_desc->attr = attr;
   10af5:	8b 45 08             	mov    0x8(%ebp),%eax
   10af8:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
   10afc:	66 89 50 04          	mov    %dx,0x4(%eax)
}
   10b00:	90                   	nop
   10b01:	c9                   	leave  
   10b02:	c3                   	ret    

00010b03 <gdt_alloc_desc>:

int gdt_alloc_desc(void)
{
   10b03:	55                   	push   %ebp
   10b04:	89 e5                	mov    %esp,%ebp
   10b06:	83 ec 18             	sub    $0x18,%esp
    mutex_lock(&gdt_mutex);
   10b09:	83 ec 0c             	sub    $0xc,%esp
   10b0c:	68 e0 3f 01 00       	push   $0x13fe0
   10b11:	e8 e7 0b 00 00       	call   116fd <mutex_lock>
   10b16:	83 c4 10             	add    $0x10,%esp
    for (int i = 1; i < GDT_TABLE_SIZE; i++)
   10b19:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   10b20:	eb 2c                	jmp    10b4e <gdt_alloc_desc+0x4b>
    {
        if(gdt_table[i].attr == 0)
   10b22:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10b25:	0f b7 04 c5 e5 37 01 	movzwl 0x137e5(,%eax,8),%eax
   10b2c:	00 
   10b2d:	66 85 c0             	test   %ax,%ax
   10b30:	75 18                	jne    10b4a <gdt_alloc_desc+0x47>
        {
            mutex_unlock(&gdt_mutex);
   10b32:	83 ec 0c             	sub    $0xc,%esp
   10b35:	68 e0 3f 01 00       	push   $0x13fe0
   10b3a:	e8 4e 0c 00 00       	call   1178d <mutex_unlock>
   10b3f:	83 c4 10             	add    $0x10,%esp
            return i * sizeof(segment_desc_t);
   10b42:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10b45:	c1 e0 03             	shl    $0x3,%eax
   10b48:	eb 22                	jmp    10b6c <gdt_alloc_desc+0x69>
    for (int i = 1; i < GDT_TABLE_SIZE; i++)
   10b4a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10b4e:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   10b55:	7e cb                	jle    10b22 <gdt_alloc_desc+0x1f>
        }
        
    }
    mutex_unlock(&gdt_mutex);
   10b57:	83 ec 0c             	sub    $0xc,%esp
   10b5a:	68 e0 3f 01 00       	push   $0x13fe0
   10b5f:	e8 29 0c 00 00       	call   1178d <mutex_unlock>
   10b64:	83 c4 10             	add    $0x10,%esp
    return -1;
   10b67:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   10b6c:	c9                   	leave  
   10b6d:	c3                   	ret    

00010b6e <init_gdt>:
void init_gdt(void)
{
   10b6e:	55                   	push   %ebp
   10b6f:	89 e5                	mov    %esp,%ebp
   10b71:	83 ec 10             	sub    $0x10,%esp
    for (int i = 0; i < GDT_TABLE_SIZE; i++)
   10b74:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10b7b:	eb 19                	jmp    10b96 <init_gdt+0x28>
    {
        segment_desc_set(i * sizeof(segment_desc_t), 0, 0, 0);
   10b7d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10b80:	c1 e0 03             	shl    $0x3,%eax
   10b83:	6a 00                	push   $0x0
   10b85:	6a 00                	push   $0x0
   10b87:	6a 00                	push   $0x0
   10b89:	50                   	push   %eax
   10b8a:	e8 aa fe ff ff       	call   10a39 <segment_desc_set>
   10b8f:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < GDT_TABLE_SIZE; i++)
   10b92:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10b96:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
   10b9d:	7e de                	jle    10b7d <init_gdt+0xf>
    }

    segment_desc_set(KERNEL_SELECTOR_CS, 0, 0xffffffff, SEG_P_PRESENT | SEG_DPL_0 | SEG_S_NORMAL | SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D);
   10b9f:	68 9a 40 00 00       	push   $0x409a
   10ba4:	6a ff                	push   $0xffffffff
   10ba6:	6a 00                	push   $0x0
   10ba8:	6a 08                	push   $0x8
   10baa:	e8 8a fe ff ff       	call   10a39 <segment_desc_set>
   10baf:	83 c4 10             	add    $0x10,%esp
    segment_desc_set(KERNEL_SELECTOR_DS, 0, 0xffffffff, SEG_P_PRESENT | SEG_DPL_0 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D);
   10bb2:	68 92 40 00 00       	push   $0x4092
   10bb7:	6a ff                	push   $0xffffffff
   10bb9:	6a 00                	push   $0x0
   10bbb:	6a 10                	push   $0x10
   10bbd:	e8 77 fe ff ff       	call   10a39 <segment_desc_set>
   10bc2:	83 c4 10             	add    $0x10,%esp

    lgdt((uint32_t)gdt_table, sizeof(gdt_table));
   10bc5:	b8 e0 37 01 00       	mov    $0x137e0,%eax
   10bca:	68 00 08 00 00       	push   $0x800
   10bcf:	50                   	push   %eax
   10bd0:	e8 22 fe ff ff       	call   109f7 <lgdt>
   10bd5:	83 c4 08             	add    $0x8,%esp
}
   10bd8:	90                   	nop
   10bd9:	c9                   	leave  
   10bda:	c3                   	ret    

00010bdb <cpu_init>:

void cpu_init(void)
{
   10bdb:	55                   	push   %ebp
   10bdc:	89 e5                	mov    %esp,%ebp
   10bde:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&gdt_mutex);
   10be1:	83 ec 0c             	sub    $0xc,%esp
   10be4:	68 e0 3f 01 00       	push   $0x13fe0
   10be9:	e8 e3 0a 00 00       	call   116d1 <mutex_init>
   10bee:	83 c4 10             	add    $0x10,%esp
    init_gdt();
   10bf1:	e8 78 ff ff ff       	call   10b6e <init_gdt>
    
}
   10bf6:	90                   	nop
   10bf7:	c9                   	leave  
   10bf8:	c3                   	ret    

00010bf9 <switch_to_tss>:

void switch_to_tss (int tss_sel)
{
   10bf9:	55                   	push   %ebp
   10bfa:	89 e5                	mov    %esp,%ebp
    far_jump(tss_sel,0);
   10bfc:	8b 45 08             	mov    0x8(%ebp),%eax
   10bff:	6a 00                	push   $0x0
   10c01:	50                   	push   %eax
   10c02:	e8 18 fe ff ff       	call   10a1f <far_jump>
   10c07:	83 c4 08             	add    $0x8,%esp
   10c0a:	90                   	nop
   10c0b:	c9                   	leave  
   10c0c:	c3                   	ret    

00010c0d <inb>:
{
   10c0d:	55                   	push   %ebp
   10c0e:	89 e5                	mov    %esp,%ebp
   10c10:	83 ec 14             	sub    $0x14,%esp
   10c13:	8b 45 08             	mov    0x8(%ebp),%eax
   10c16:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[p], %[v]":[v] "=a"(rv) : [p]"d"(port));
   10c1a:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   10c1e:	89 c2                	mov    %eax,%edx
   10c20:	ec                   	in     (%dx),%al
   10c21:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   10c24:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   10c28:	c9                   	leave  
   10c29:	c3                   	ret    

00010c2a <outb>:
{
   10c2a:	55                   	push   %ebp
   10c2b:	89 e5                	mov    %esp,%ebp
   10c2d:	83 ec 08             	sub    $0x8,%esp
   10c30:	8b 55 08             	mov    0x8(%ebp),%edx
   10c33:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c36:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   10c3a:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]"::[p]"d"(port),[v]"a"(data));
   10c3d:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   10c41:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   10c45:	ee                   	out    %al,(%dx)
}
   10c46:	90                   	nop
   10c47:	c9                   	leave  
   10c48:	c3                   	ret    

00010c49 <cli>:
{
   10c49:	55                   	push   %ebp
   10c4a:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile("cli");
   10c4c:	fa                   	cli    
}
   10c4d:	90                   	nop
   10c4e:	5d                   	pop    %ebp
   10c4f:	c3                   	ret    

00010c50 <sti>:
{
   10c50:	55                   	push   %ebp
   10c51:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile("sti");
   10c53:	fb                   	sti    
}
   10c54:	90                   	nop
   10c55:	5d                   	pop    %ebp
   10c56:	c3                   	ret    

00010c57 <lidt>:
{
   10c57:	55                   	push   %ebp
   10c58:	89 e5                	mov    %esp,%ebp
   10c5a:	83 ec 10             	sub    $0x10,%esp
    idt.start31_16 = start >> 16;
   10c5d:	8b 45 08             	mov    0x8(%ebp),%eax
   10c60:	c1 e8 10             	shr    $0x10,%eax
   10c63:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    idt.start15_0 = start & 0xffff;
   10c67:	8b 45 08             	mov    0x8(%ebp),%eax
   10c6a:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    idt.limit = size - 1;
   10c6e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c71:	83 e8 01             	sub    $0x1,%eax
   10c74:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__("lidt %[i]"::[i]"m"(idt));
   10c78:	0f 01 5d fa          	lidtl  -0x6(%ebp)
}
   10c7c:	90                   	nop
   10c7d:	c9                   	leave  
   10c7e:	c3                   	ret    

00010c7f <hlt>:
{
   10c7f:	55                   	push   %ebp
   10c80:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   10c82:	f4                   	hlt    
}
   10c83:	90                   	nop
   10c84:	5d                   	pop    %ebp
   10c85:	c3                   	ret    

00010c86 <read_eflags>:

static inline uint32_t read_eflags(void)
{
   10c86:	55                   	push   %ebp
   10c87:	89 e5                	mov    %esp,%ebp
   10c89:	83 ec 10             	sub    $0x10,%esp
    uint32_t eflags;
    __asm__ __volatile__("pushf\n\tpop %%eax":"=a"(eflags));
   10c8c:	9c                   	pushf  
   10c8d:	58                   	pop    %eax
   10c8e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return eflags;
   10c91:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10c94:	c9                   	leave  
   10c95:	c3                   	ret    

00010c96 <write_eflags>:

static inline void write_eflags(uint32_t eflags)
{
   10c96:	55                   	push   %ebp
   10c97:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("push %%eax\n\tpopf"::"a"(eflags));
   10c99:	8b 45 08             	mov    0x8(%ebp),%eax
   10c9c:	50                   	push   %eax
   10c9d:	9d                   	popf   
}
   10c9e:	90                   	nop
   10c9f:	5d                   	pop    %ebp
   10ca0:	c3                   	ret    

00010ca1 <dump_core_regs>:
#include "os_cfg.h"
#include "tools/log.h"
#define IRQ_TABLE_NU 128
static gate_desc_t idt_table[IRQ_TABLE_NU];
static dump_core_regs(exception_frame_t *frame)
{
   10ca1:	55                   	push   %ebp
   10ca2:	89 e5                	mov    %esp,%ebp
   10ca4:	57                   	push   %edi
   10ca5:	56                   	push   %esi
   10ca6:	53                   	push   %ebx
   10ca7:	83 ec 0c             	sub    $0xc,%esp
    log_printf("IRQ: %d, error code: %d\n",frame->irq_num,frame->error_code);
   10caa:	8b 45 08             	mov    0x8(%ebp),%eax
   10cad:	8b 50 34             	mov    0x34(%eax),%edx
   10cb0:	8b 45 08             	mov    0x8(%ebp),%eax
   10cb3:	8b 40 30             	mov    0x30(%eax),%eax
   10cb6:	83 ec 04             	sub    $0x4,%esp
   10cb9:	52                   	push   %edx
   10cba:	50                   	push   %eax
   10cbb:	68 4c 22 01 00       	push   $0x1224c
   10cc0:	e8 82 14 00 00       	call   12147 <log_printf>
   10cc5:	83 c4 10             	add    $0x10,%esp
    log_printf("CS: %d DS: %d ES: %d SS: %d FS: %d GS: %d\n",frame->cs,frame->ds,frame->es,frame->ds,frame->fs,frame->gs);
   10cc8:	8b 45 08             	mov    0x8(%ebp),%eax
   10ccb:	8b 38                	mov    (%eax),%edi
   10ccd:	8b 45 08             	mov    0x8(%ebp),%eax
   10cd0:	8b 70 04             	mov    0x4(%eax),%esi
   10cd3:	8b 45 08             	mov    0x8(%ebp),%eax
   10cd6:	8b 58 0c             	mov    0xc(%eax),%ebx
   10cd9:	8b 45 08             	mov    0x8(%ebp),%eax
   10cdc:	8b 48 08             	mov    0x8(%eax),%ecx
   10cdf:	8b 45 08             	mov    0x8(%ebp),%eax
   10ce2:	8b 50 0c             	mov    0xc(%eax),%edx
   10ce5:	8b 45 08             	mov    0x8(%ebp),%eax
   10ce8:	8b 40 3c             	mov    0x3c(%eax),%eax
   10ceb:	83 ec 04             	sub    $0x4,%esp
   10cee:	57                   	push   %edi
   10cef:	56                   	push   %esi
   10cf0:	53                   	push   %ebx
   10cf1:	51                   	push   %ecx
   10cf2:	52                   	push   %edx
   10cf3:	50                   	push   %eax
   10cf4:	68 68 22 01 00       	push   $0x12268
   10cf9:	e8 49 14 00 00       	call   12147 <log_printf>
   10cfe:	83 c4 20             	add    $0x20,%esp
    log_printf("EAX: 0x%x EBX: 0x%x ECX: 0x%x EDX: 0x%x\n",frame->eax,frame->ebx,frame->ecx,frame->edx);
   10d01:	8b 45 08             	mov    0x8(%ebp),%eax
   10d04:	8b 58 24             	mov    0x24(%eax),%ebx
   10d07:	8b 45 08             	mov    0x8(%ebp),%eax
   10d0a:	8b 48 28             	mov    0x28(%eax),%ecx
   10d0d:	8b 45 08             	mov    0x8(%ebp),%eax
   10d10:	8b 50 20             	mov    0x20(%eax),%edx
   10d13:	8b 45 08             	mov    0x8(%ebp),%eax
   10d16:	8b 40 2c             	mov    0x2c(%eax),%eax
   10d19:	83 ec 0c             	sub    $0xc,%esp
   10d1c:	53                   	push   %ebx
   10d1d:	51                   	push   %ecx
   10d1e:	52                   	push   %edx
   10d1f:	50                   	push   %eax
   10d20:	68 94 22 01 00       	push   $0x12294
   10d25:	e8 1d 14 00 00       	call   12147 <log_printf>
   10d2a:	83 c4 20             	add    $0x20,%esp
    log_printf("EIP: 0x%x EFLAGS: 0x%x ESP: 0x%x EBP: 0x%x\n",frame->eip,frame->eflags,frame->esp,frame->ebp);
   10d2d:	8b 45 08             	mov    0x8(%ebp),%eax
   10d30:	8b 58 18             	mov    0x18(%eax),%ebx
   10d33:	8b 45 08             	mov    0x8(%ebp),%eax
   10d36:	8b 48 1c             	mov    0x1c(%eax),%ecx
   10d39:	8b 45 08             	mov    0x8(%ebp),%eax
   10d3c:	8b 50 40             	mov    0x40(%eax),%edx
   10d3f:	8b 45 08             	mov    0x8(%ebp),%eax
   10d42:	8b 40 38             	mov    0x38(%eax),%eax
   10d45:	83 ec 0c             	sub    $0xc,%esp
   10d48:	53                   	push   %ebx
   10d49:	51                   	push   %ecx
   10d4a:	52                   	push   %edx
   10d4b:	50                   	push   %eax
   10d4c:	68 c0 22 01 00       	push   $0x122c0
   10d51:	e8 f1 13 00 00       	call   12147 <log_printf>
   10d56:	83 c4 20             	add    $0x20,%esp
    log_printf("EDI: 0x%x ESI: 0x%x EDI: 0x%x\n",frame->edi,frame->esi,frame->edi);
   10d59:	8b 45 08             	mov    0x8(%ebp),%eax
   10d5c:	8b 48 10             	mov    0x10(%eax),%ecx
   10d5f:	8b 45 08             	mov    0x8(%ebp),%eax
   10d62:	8b 50 14             	mov    0x14(%eax),%edx
   10d65:	8b 45 08             	mov    0x8(%ebp),%eax
   10d68:	8b 40 10             	mov    0x10(%eax),%eax
   10d6b:	51                   	push   %ecx
   10d6c:	52                   	push   %edx
   10d6d:	50                   	push   %eax
   10d6e:	68 ec 22 01 00       	push   $0x122ec
   10d73:	e8 cf 13 00 00       	call   12147 <log_printf>
   10d78:	83 c4 10             	add    $0x10,%esp
}
   10d7b:	90                   	nop
   10d7c:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10d7f:	5b                   	pop    %ebx
   10d80:	5e                   	pop    %esi
   10d81:	5f                   	pop    %edi
   10d82:	5d                   	pop    %ebp
   10d83:	c3                   	ret    

00010d84 <do_default_handler>:
static void do_default_handler(exception_frame_t *frame,const char *message)
{
   10d84:	55                   	push   %ebp
   10d85:	89 e5                	mov    %esp,%ebp
   10d87:	83 ec 08             	sub    $0x8,%esp
    log_printf("---------------------\n");
   10d8a:	83 ec 0c             	sub    $0xc,%esp
   10d8d:	68 0b 23 01 00       	push   $0x1230b
   10d92:	e8 b0 13 00 00       	call   12147 <log_printf>
   10d97:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: %s\n",message);
   10d9a:	83 ec 08             	sub    $0x8,%esp
   10d9d:	ff 75 0c             	pushl  0xc(%ebp)
   10da0:	68 22 23 01 00       	push   $0x12322
   10da5:	e8 9d 13 00 00       	call   12147 <log_printf>
   10daa:	83 c4 10             	add    $0x10,%esp

    dump_core_regs(frame);
   10dad:	83 ec 0c             	sub    $0xc,%esp
   10db0:	ff 75 08             	pushl  0x8(%ebp)
   10db3:	e8 e9 fe ff ff       	call   10ca1 <dump_core_regs>
   10db8:	83 c4 10             	add    $0x10,%esp
    for(;;)
    {
        hlt();
   10dbb:	e8 bf fe ff ff       	call   10c7f <hlt>
   10dc0:	eb f9                	jmp    10dbb <do_default_handler+0x37>

00010dc2 <do_handler_unknown>:
    }
}
void do_handler_unknown(exception_frame_t *frame)
{
   10dc2:	55                   	push   %ebp
   10dc3:	89 e5                	mov    %esp,%ebp
   10dc5:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"unknown exception");
   10dc8:	83 ec 08             	sub    $0x8,%esp
   10dcb:	68 3d 23 01 00       	push   $0x1233d
   10dd0:	ff 75 08             	pushl  0x8(%ebp)
   10dd3:	e8 ac ff ff ff       	call   10d84 <do_default_handler>
   10dd8:	83 c4 10             	add    $0x10,%esp
}
   10ddb:	90                   	nop
   10ddc:	c9                   	leave  
   10ddd:	c3                   	ret    

00010dde <do_handler_divider>:
void do_handler_divider(exception_frame_t *frame)
{
   10dde:	55                   	push   %ebp
   10ddf:	89 e5                	mov    %esp,%ebp
   10de1:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"divider exception");
   10de4:	83 ec 08             	sub    $0x8,%esp
   10de7:	68 4f 23 01 00       	push   $0x1234f
   10dec:	ff 75 08             	pushl  0x8(%ebp)
   10def:	e8 90 ff ff ff       	call   10d84 <do_default_handler>
   10df4:	83 c4 10             	add    $0x10,%esp
}
   10df7:	90                   	nop
   10df8:	c9                   	leave  
   10df9:	c3                   	ret    

00010dfa <do_handler_debug>:
void do_handler_debug(exception_frame_t *frame)
{
   10dfa:	55                   	push   %ebp
   10dfb:	89 e5                	mov    %esp,%ebp
   10dfd:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"debug exception");
   10e00:	83 ec 08             	sub    $0x8,%esp
   10e03:	68 61 23 01 00       	push   $0x12361
   10e08:	ff 75 08             	pushl  0x8(%ebp)
   10e0b:	e8 74 ff ff ff       	call   10d84 <do_default_handler>
   10e10:	83 c4 10             	add    $0x10,%esp
}
   10e13:	90                   	nop
   10e14:	c9                   	leave  
   10e15:	c3                   	ret    

00010e16 <do_handler_nmi>:
void do_handler_nmi(exception_frame_t *frame)   
{
   10e16:	55                   	push   %ebp
   10e17:	89 e5                	mov    %esp,%ebp
   10e19:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"nmi exception");
   10e1c:	83 ec 08             	sub    $0x8,%esp
   10e1f:	68 71 23 01 00       	push   $0x12371
   10e24:	ff 75 08             	pushl  0x8(%ebp)
   10e27:	e8 58 ff ff ff       	call   10d84 <do_default_handler>
   10e2c:	83 c4 10             	add    $0x10,%esp
}
   10e2f:	90                   	nop
   10e30:	c9                   	leave  
   10e31:	c3                   	ret    

00010e32 <do_handler_breakpoint>:
void do_handler_breakpoint(exception_frame_t *frame)
{
   10e32:	55                   	push   %ebp
   10e33:	89 e5                	mov    %esp,%ebp
   10e35:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"breakpoint exception");
   10e38:	83 ec 08             	sub    $0x8,%esp
   10e3b:	68 7f 23 01 00       	push   $0x1237f
   10e40:	ff 75 08             	pushl  0x8(%ebp)
   10e43:	e8 3c ff ff ff       	call   10d84 <do_default_handler>
   10e48:	83 c4 10             	add    $0x10,%esp
}
   10e4b:	90                   	nop
   10e4c:	c9                   	leave  
   10e4d:	c3                   	ret    

00010e4e <do_handler_overflow>:
void do_handler_overflow(exception_frame_t *frame)
{
   10e4e:	55                   	push   %ebp
   10e4f:	89 e5                	mov    %esp,%ebp
   10e51:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"overflow exception");
   10e54:	83 ec 08             	sub    $0x8,%esp
   10e57:	68 94 23 01 00       	push   $0x12394
   10e5c:	ff 75 08             	pushl  0x8(%ebp)
   10e5f:	e8 20 ff ff ff       	call   10d84 <do_default_handler>
   10e64:	83 c4 10             	add    $0x10,%esp
}
   10e67:	90                   	nop
   10e68:	c9                   	leave  
   10e69:	c3                   	ret    

00010e6a <do_handler_bounds>:
void do_handler_bounds(exception_frame_t *frame)
{
   10e6a:	55                   	push   %ebp
   10e6b:	89 e5                	mov    %esp,%ebp
   10e6d:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"bounds exception");
   10e70:	83 ec 08             	sub    $0x8,%esp
   10e73:	68 a7 23 01 00       	push   $0x123a7
   10e78:	ff 75 08             	pushl  0x8(%ebp)
   10e7b:	e8 04 ff ff ff       	call   10d84 <do_default_handler>
   10e80:	83 c4 10             	add    $0x10,%esp
}
   10e83:	90                   	nop
   10e84:	c9                   	leave  
   10e85:	c3                   	ret    

00010e86 <do_handler_invalid_op>:
void do_handler_invalid_op(exception_frame_t *frame)
{
   10e86:	55                   	push   %ebp
   10e87:	89 e5                	mov    %esp,%ebp
   10e89:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"invalid operation exception");
   10e8c:	83 ec 08             	sub    $0x8,%esp
   10e8f:	68 b8 23 01 00       	push   $0x123b8
   10e94:	ff 75 08             	pushl  0x8(%ebp)
   10e97:	e8 e8 fe ff ff       	call   10d84 <do_default_handler>
   10e9c:	83 c4 10             	add    $0x10,%esp
}
   10e9f:	90                   	nop
   10ea0:	c9                   	leave  
   10ea1:	c3                   	ret    

00010ea2 <do_handler_device_not_available>:
void do_handler_device_not_available(exception_frame_t *frame)
{
   10ea2:	55                   	push   %ebp
   10ea3:	89 e5                	mov    %esp,%ebp
   10ea5:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"device not available exception");
   10ea8:	83 ec 08             	sub    $0x8,%esp
   10eab:	68 d4 23 01 00       	push   $0x123d4
   10eb0:	ff 75 08             	pushl  0x8(%ebp)
   10eb3:	e8 cc fe ff ff       	call   10d84 <do_default_handler>
   10eb8:	83 c4 10             	add    $0x10,%esp
}
   10ebb:	90                   	nop
   10ebc:	c9                   	leave  
   10ebd:	c3                   	ret    

00010ebe <do_handler_double_fault>:
void do_handler_double_fault(exception_frame_t *frame)
{
   10ebe:	55                   	push   %ebp
   10ebf:	89 e5                	mov    %esp,%ebp
   10ec1:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"double fault exception");
   10ec4:	83 ec 08             	sub    $0x8,%esp
   10ec7:	68 f3 23 01 00       	push   $0x123f3
   10ecc:	ff 75 08             	pushl  0x8(%ebp)
   10ecf:	e8 b0 fe ff ff       	call   10d84 <do_default_handler>
   10ed4:	83 c4 10             	add    $0x10,%esp
}
   10ed7:	90                   	nop
   10ed8:	c9                   	leave  
   10ed9:	c3                   	ret    

00010eda <do_handler_invalid_tss>:
void do_handler_invalid_tss(exception_frame_t *frame)
{
   10eda:	55                   	push   %ebp
   10edb:	89 e5                	mov    %esp,%ebp
   10edd:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"invalid tss exception");
   10ee0:	83 ec 08             	sub    $0x8,%esp
   10ee3:	68 0a 24 01 00       	push   $0x1240a
   10ee8:	ff 75 08             	pushl  0x8(%ebp)
   10eeb:	e8 94 fe ff ff       	call   10d84 <do_default_handler>
   10ef0:	83 c4 10             	add    $0x10,%esp
}
   10ef3:	90                   	nop
   10ef4:	c9                   	leave  
   10ef5:	c3                   	ret    

00010ef6 <do_handler_segment_not_present>:
void do_handler_segment_not_present(exception_frame_t *frame)
{
   10ef6:	55                   	push   %ebp
   10ef7:	89 e5                	mov    %esp,%ebp
   10ef9:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"segment not present exception");
   10efc:	83 ec 08             	sub    $0x8,%esp
   10eff:	68 20 24 01 00       	push   $0x12420
   10f04:	ff 75 08             	pushl  0x8(%ebp)
   10f07:	e8 78 fe ff ff       	call   10d84 <do_default_handler>
   10f0c:	83 c4 10             	add    $0x10,%esp
}
   10f0f:	90                   	nop
   10f10:	c9                   	leave  
   10f11:	c3                   	ret    

00010f12 <do_handler_stack_segment_fault>:
void do_handler_stack_segment_fault(exception_frame_t *frame)
{
   10f12:	55                   	push   %ebp
   10f13:	89 e5                	mov    %esp,%ebp
   10f15:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"stack segment fault exception");
   10f18:	83 ec 08             	sub    $0x8,%esp
   10f1b:	68 3e 24 01 00       	push   $0x1243e
   10f20:	ff 75 08             	pushl  0x8(%ebp)
   10f23:	e8 5c fe ff ff       	call   10d84 <do_default_handler>
   10f28:	83 c4 10             	add    $0x10,%esp
}
   10f2b:	90                   	nop
   10f2c:	c9                   	leave  
   10f2d:	c3                   	ret    

00010f2e <do_handler_general_protection>:
void do_handler_general_protection(exception_frame_t *frame)
{
   10f2e:	55                   	push   %ebp
   10f2f:	89 e5                	mov    %esp,%ebp
   10f31:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"general protection exception");
   10f34:	83 ec 08             	sub    $0x8,%esp
   10f37:	68 5c 24 01 00       	push   $0x1245c
   10f3c:	ff 75 08             	pushl  0x8(%ebp)
   10f3f:	e8 40 fe ff ff       	call   10d84 <do_default_handler>
   10f44:	83 c4 10             	add    $0x10,%esp
}
   10f47:	90                   	nop
   10f48:	c9                   	leave  
   10f49:	c3                   	ret    

00010f4a <do_handler_page_fault>:
void do_handler_page_fault(exception_frame_t *frame)
{
   10f4a:	55                   	push   %ebp
   10f4b:	89 e5                	mov    %esp,%ebp
   10f4d:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"page fault exception");
   10f50:	83 ec 08             	sub    $0x8,%esp
   10f53:	68 79 24 01 00       	push   $0x12479
   10f58:	ff 75 08             	pushl  0x8(%ebp)
   10f5b:	e8 24 fe ff ff       	call   10d84 <do_default_handler>
   10f60:	83 c4 10             	add    $0x10,%esp
}
   10f63:	90                   	nop
   10f64:	c9                   	leave  
   10f65:	c3                   	ret    

00010f66 <do_handler_x87_floating_point>:
void do_handler_x87_floating_point(exception_frame_t *frame)
{   
   10f66:	55                   	push   %ebp
   10f67:	89 e5                	mov    %esp,%ebp
   10f69:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"x87 floating point exception");
   10f6c:	83 ec 08             	sub    $0x8,%esp
   10f6f:	68 8e 24 01 00       	push   $0x1248e
   10f74:	ff 75 08             	pushl  0x8(%ebp)
   10f77:	e8 08 fe ff ff       	call   10d84 <do_default_handler>
   10f7c:	83 c4 10             	add    $0x10,%esp
}
   10f7f:	90                   	nop
   10f80:	c9                   	leave  
   10f81:	c3                   	ret    

00010f82 <do_handler_alignment_check>:
void do_handler_alignment_check(exception_frame_t *frame)
{
   10f82:	55                   	push   %ebp
   10f83:	89 e5                	mov    %esp,%ebp
   10f85:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"alignment check exception");
   10f88:	83 ec 08             	sub    $0x8,%esp
   10f8b:	68 ab 24 01 00       	push   $0x124ab
   10f90:	ff 75 08             	pushl  0x8(%ebp)
   10f93:	e8 ec fd ff ff       	call   10d84 <do_default_handler>
   10f98:	83 c4 10             	add    $0x10,%esp
}
   10f9b:	90                   	nop
   10f9c:	c9                   	leave  
   10f9d:	c3                   	ret    

00010f9e <do_handler_machine_check>:
void do_handler_machine_check(exception_frame_t *frame)
{
   10f9e:	55                   	push   %ebp
   10f9f:	89 e5                	mov    %esp,%ebp
   10fa1:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"machine check exception");
   10fa4:	83 ec 08             	sub    $0x8,%esp
   10fa7:	68 c5 24 01 00       	push   $0x124c5
   10fac:	ff 75 08             	pushl  0x8(%ebp)
   10faf:	e8 d0 fd ff ff       	call   10d84 <do_default_handler>
   10fb4:	83 c4 10             	add    $0x10,%esp
}
   10fb7:	90                   	nop
   10fb8:	c9                   	leave  
   10fb9:	c3                   	ret    

00010fba <do_handler_simd_floating_point>:
void do_handler_simd_floating_point(exception_frame_t *frame)
{
   10fba:	55                   	push   %ebp
   10fbb:	89 e5                	mov    %esp,%ebp
   10fbd:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"simd floating point exception");
   10fc0:	83 ec 08             	sub    $0x8,%esp
   10fc3:	68 dd 24 01 00       	push   $0x124dd
   10fc8:	ff 75 08             	pushl  0x8(%ebp)
   10fcb:	e8 b4 fd ff ff       	call   10d84 <do_default_handler>
   10fd0:	83 c4 10             	add    $0x10,%esp
}
   10fd3:	90                   	nop
   10fd4:	c9                   	leave  
   10fd5:	c3                   	ret    

00010fd6 <do_handler_virtualization>:
void do_handler_virtualization(exception_frame_t *frame)
{
   10fd6:	55                   	push   %ebp
   10fd7:	89 e5                	mov    %esp,%ebp
   10fd9:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"virtualization exception");
   10fdc:	83 ec 08             	sub    $0x8,%esp
   10fdf:	68 fb 24 01 00       	push   $0x124fb
   10fe4:	ff 75 08             	pushl  0x8(%ebp)
   10fe7:	e8 98 fd ff ff       	call   10d84 <do_default_handler>
   10fec:	83 c4 10             	add    $0x10,%esp
}
   10fef:	90                   	nop
   10ff0:	c9                   	leave  
   10ff1:	c3                   	ret    

00010ff2 <do_handler_security>:
void do_handler_security(exception_frame_t *frame)
{
   10ff2:	55                   	push   %ebp
   10ff3:	89 e5                	mov    %esp,%ebp
   10ff5:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"security exception");
   10ff8:	83 ec 08             	sub    $0x8,%esp
   10ffb:	68 14 25 01 00       	push   $0x12514
   11000:	ff 75 08             	pushl  0x8(%ebp)
   11003:	e8 7c fd ff ff       	call   10d84 <do_default_handler>
   11008:	83 c4 10             	add    $0x10,%esp
}
   1100b:	90                   	nop
   1100c:	c9                   	leave  
   1100d:	c3                   	ret    

0001100e <init_pic>:

static void init_pic(void)
{
   1100e:	55                   	push   %ebp
   1100f:	89 e5                	mov    %esp,%ebp
    outb(PIC0_ICW1,PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
   11011:	6a 11                	push   $0x11
   11013:	6a 20                	push   $0x20
   11015:	e8 10 fc ff ff       	call   10c2a <outb>
   1101a:	83 c4 08             	add    $0x8,%esp
    outb(PIC0_ICW2,IRQ_PIC_START);
   1101d:	6a 20                	push   $0x20
   1101f:	6a 21                	push   $0x21
   11021:	e8 04 fc ff ff       	call   10c2a <outb>
   11026:	83 c4 08             	add    $0x8,%esp
    outb(PIC0_ICW3,1 << IRQ2_NMI);
   11029:	6a 04                	push   $0x4
   1102b:	6a 21                	push   $0x21
   1102d:	e8 f8 fb ff ff       	call   10c2a <outb>
   11032:	83 c4 08             	add    $0x8,%esp
    outb(PIC0_ICW4,PIC_ICW4_8086);
   11035:	6a 01                	push   $0x1
   11037:	6a 21                	push   $0x21
   11039:	e8 ec fb ff ff       	call   10c2a <outb>
   1103e:	83 c4 08             	add    $0x8,%esp


    outb(PIC1_ICW1,PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
   11041:	6a 11                	push   $0x11
   11043:	68 a0 00 00 00       	push   $0xa0
   11048:	e8 dd fb ff ff       	call   10c2a <outb>
   1104d:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_ICW2,IRQ_PIC_START + 8);
   11050:	6a 28                	push   $0x28
   11052:	68 a1 00 00 00       	push   $0xa1
   11057:	e8 ce fb ff ff       	call   10c2a <outb>
   1105c:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_ICW3,2);
   1105f:	6a 02                	push   $0x2
   11061:	68 a1 00 00 00       	push   $0xa1
   11066:	e8 bf fb ff ff       	call   10c2a <outb>
   1106b:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_ICW4,PIC_ICW4_8086);
   1106e:	6a 01                	push   $0x1
   11070:	68 a1 00 00 00       	push   $0xa1
   11075:	e8 b0 fb ff ff       	call   10c2a <outb>
   1107a:	83 c4 08             	add    $0x8,%esp

    outb(PIC0_IMR,0xff & ~ (1 << 2));
   1107d:	68 fb 00 00 00       	push   $0xfb
   11082:	6a 21                	push   $0x21
   11084:	e8 a1 fb ff ff       	call   10c2a <outb>
   11089:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_IMR,0xff);
   1108c:	68 ff 00 00 00       	push   $0xff
   11091:	68 a1 00 00 00       	push   $0xa1
   11096:	e8 8f fb ff ff       	call   10c2a <outb>
   1109b:	83 c4 08             	add    $0x8,%esp
}
   1109e:	90                   	nop
   1109f:	c9                   	leave  
   110a0:	c3                   	ret    

000110a1 <irq_init>:

void irq_init(void)
{
   110a1:	55                   	push   %ebp
   110a2:	89 e5                	mov    %esp,%ebp
   110a4:	83 ec 18             	sub    $0x18,%esp
    for(int i = 0; i < IRQ_TABLE_NU; i++)
   110a7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   110ae:	eb 25                	jmp    110d5 <irq_init+0x34>
    {
        gate_desc_set(idt_table + i, KERNEL_SELECTOR_CS, (uint32_t)exception_handler_unknown, 
   110b0:	ba 4f 00 01 00       	mov    $0x1004f,%edx
   110b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   110b8:	c1 e0 03             	shl    $0x3,%eax
   110bb:	05 00 40 01 00       	add    $0x14000,%eax
   110c0:	68 00 8e 00 00       	push   $0x8e00
   110c5:	52                   	push   %edx
   110c6:	6a 08                	push   $0x8
   110c8:	50                   	push   %eax
   110c9:	e8 ee f9 ff ff       	call   10abc <gate_desc_set>
   110ce:	83 c4 10             	add    $0x10,%esp
    for(int i = 0; i < IRQ_TABLE_NU; i++)
   110d1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   110d5:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   110d9:	7e d5                	jle    110b0 <irq_init+0xf>
        GATE_P_PRESENT | GATE_DPL_0 | GATE_TYPE_INT);
    }
    //irq_install(IRQ0_DE,do_handler_divider); 用这个的话能进入do_handler_divider 但是跳不到.S的地方出栈
    irq_install(IRQ0_DE,exception_handler_divider);
   110db:	83 ec 08             	sub    $0x8,%esp
   110de:	68 6e 00 01 00       	push   $0x1006e
   110e3:	6a 00                	push   $0x0
   110e5:	e8 77 01 00 00       	call   11261 <irq_install>
   110ea:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ1_DB,exception_handler_debug);
   110ed:	83 ec 08             	sub    $0x8,%esp
   110f0:	68 8d 00 01 00       	push   $0x1008d
   110f5:	6a 01                	push   $0x1
   110f7:	e8 65 01 00 00       	call   11261 <irq_install>
   110fc:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ2_NMI,exception_handler_nmi);
   110ff:	83 ec 08             	sub    $0x8,%esp
   11102:	68 ac 00 01 00       	push   $0x100ac
   11107:	6a 02                	push   $0x2
   11109:	e8 53 01 00 00       	call   11261 <irq_install>
   1110e:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ3_BP,exception_handler_breakpoint);
   11111:	83 ec 08             	sub    $0x8,%esp
   11114:	68 cb 00 01 00       	push   $0x100cb
   11119:	6a 03                	push   $0x3
   1111b:	e8 41 01 00 00       	call   11261 <irq_install>
   11120:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ4_OF,exception_handler_overflow);
   11123:	83 ec 08             	sub    $0x8,%esp
   11126:	68 ea 00 01 00       	push   $0x100ea
   1112b:	6a 04                	push   $0x4
   1112d:	e8 2f 01 00 00       	call   11261 <irq_install>
   11132:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ5_BR,exception_handler_bounds);
   11135:	83 ec 08             	sub    $0x8,%esp
   11138:	68 09 01 01 00       	push   $0x10109
   1113d:	6a 05                	push   $0x5
   1113f:	e8 1d 01 00 00       	call   11261 <irq_install>
   11144:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ6_UD,exception_handler_invalid_op);
   11147:	83 ec 08             	sub    $0x8,%esp
   1114a:	68 28 01 01 00       	push   $0x10128
   1114f:	6a 06                	push   $0x6
   11151:	e8 0b 01 00 00       	call   11261 <irq_install>
   11156:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ7_NM,exception_handler_device_not_available);
   11159:	83 ec 08             	sub    $0x8,%esp
   1115c:	68 47 01 01 00       	push   $0x10147
   11161:	6a 07                	push   $0x7
   11163:	e8 f9 00 00 00       	call   11261 <irq_install>
   11168:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ8_DF,exception_handler_double_fault);
   1116b:	83 ec 08             	sub    $0x8,%esp
   1116e:	68 66 01 01 00       	push   $0x10166
   11173:	6a 08                	push   $0x8
   11175:	e8 e7 00 00 00       	call   11261 <irq_install>
   1117a:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ10_TS,exception_handler_invalid_tss);
   1117d:	83 ec 08             	sub    $0x8,%esp
   11180:	68 83 01 01 00       	push   $0x10183
   11185:	6a 0a                	push   $0xa
   11187:	e8 d5 00 00 00       	call   11261 <irq_install>
   1118c:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ11_NP,exception_handler_segment_not_present);
   1118f:	83 ec 08             	sub    $0x8,%esp
   11192:	68 a0 01 01 00       	push   $0x101a0
   11197:	6a 0b                	push   $0xb
   11199:	e8 c3 00 00 00       	call   11261 <irq_install>
   1119e:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ12_SS,exception_handler_stack_segment_fault);
   111a1:	83 ec 08             	sub    $0x8,%esp
   111a4:	68 bd 01 01 00       	push   $0x101bd
   111a9:	6a 0c                	push   $0xc
   111ab:	e8 b1 00 00 00       	call   11261 <irq_install>
   111b0:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ13_GP,exception_handler_general_protection);
   111b3:	83 ec 08             	sub    $0x8,%esp
   111b6:	68 da 01 01 00       	push   $0x101da
   111bb:	6a 0d                	push   $0xd
   111bd:	e8 9f 00 00 00       	call   11261 <irq_install>
   111c2:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ14_PF,exception_handler_page_fault);
   111c5:	83 ec 08             	sub    $0x8,%esp
   111c8:	68 f7 01 01 00       	push   $0x101f7
   111cd:	6a 0e                	push   $0xe
   111cf:	e8 8d 00 00 00       	call   11261 <irq_install>
   111d4:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ16_MF,exception_handler_x87_floating_point);
   111d7:	83 ec 08             	sub    $0x8,%esp
   111da:	68 14 02 01 00       	push   $0x10214
   111df:	6a 10                	push   $0x10
   111e1:	e8 7b 00 00 00       	call   11261 <irq_install>
   111e6:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ17_AC,exception_handler_alignment_check);
   111e9:	83 ec 08             	sub    $0x8,%esp
   111ec:	68 33 02 01 00       	push   $0x10233
   111f1:	6a 11                	push   $0x11
   111f3:	e8 69 00 00 00       	call   11261 <irq_install>
   111f8:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ18_MC,exception_handler_machine_check);
   111fb:	83 ec 08             	sub    $0x8,%esp
   111fe:	68 50 02 01 00       	push   $0x10250
   11203:	6a 12                	push   $0x12
   11205:	e8 57 00 00 00       	call   11261 <irq_install>
   1120a:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ19_XM,exception_handler_simd_floating_point);
   1120d:	83 ec 08             	sub    $0x8,%esp
   11210:	68 6f 02 01 00       	push   $0x1026f
   11215:	6a 13                	push   $0x13
   11217:	e8 45 00 00 00       	call   11261 <irq_install>
   1121c:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ20_VE,exception_handler_virtualization);
   1121f:	83 ec 08             	sub    $0x8,%esp
   11222:	68 8e 02 01 00       	push   $0x1028e
   11227:	6a 14                	push   $0x14
   11229:	e8 33 00 00 00       	call   11261 <irq_install>
   1122e:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ21_CP,exception_handler_security);
   11231:	83 ec 08             	sub    $0x8,%esp
   11234:	68 ad 02 01 00       	push   $0x102ad
   11239:	6a 15                	push   $0x15
   1123b:	e8 21 00 00 00       	call   11261 <irq_install>
   11240:	83 c4 10             	add    $0x10,%esp

    lidt((uint32_t)idt_table, sizeof(idt_table));
   11243:	b8 00 40 01 00       	mov    $0x14000,%eax
   11248:	83 ec 08             	sub    $0x8,%esp
   1124b:	68 00 04 00 00       	push   $0x400
   11250:	50                   	push   %eax
   11251:	e8 01 fa ff ff       	call   10c57 <lidt>
   11256:	83 c4 10             	add    $0x10,%esp

    init_pic();
   11259:	e8 b0 fd ff ff       	call   1100e <init_pic>
}
   1125e:	90                   	nop
   1125f:	c9                   	leave  
   11260:	c3                   	ret    

00011261 <irq_install>:

int irq_install(int irq_num,irq_handler_t handler)
{
   11261:	55                   	push   %ebp
   11262:	89 e5                	mov    %esp,%ebp
   11264:	83 ec 08             	sub    $0x8,%esp
    if(irq_num < 0 || irq_num >= IRQ_TABLE_NU)
   11267:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1126b:	78 06                	js     11273 <irq_install+0x12>
   1126d:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   11271:	7e 07                	jle    1127a <irq_install+0x19>
    {
        return -1;
   11273:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11278:	eb 25                	jmp    1129f <irq_install+0x3e>
    }
    gate_desc_set(idt_table + irq_num, KERNEL_SELECTOR_CS, (uint32_t)handler, 
   1127a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1127d:	8b 55 08             	mov    0x8(%ebp),%edx
   11280:	c1 e2 03             	shl    $0x3,%edx
   11283:	81 c2 00 40 01 00    	add    $0x14000,%edx
   11289:	68 00 8e 00 00       	push   $0x8e00
   1128e:	50                   	push   %eax
   1128f:	6a 08                	push   $0x8
   11291:	52                   	push   %edx
   11292:	e8 25 f8 ff ff       	call   10abc <gate_desc_set>
   11297:	83 c4 10             	add    $0x10,%esp
    GATE_P_PRESENT | GATE_DPL_0 | GATE_TYPE_INT);
    return 0;
   1129a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1129f:	c9                   	leave  
   112a0:	c3                   	ret    

000112a1 <irq_enable>:

void irq_enable(int irq_num)
{
   112a1:	55                   	push   %ebp
   112a2:	89 e5                	mov    %esp,%ebp
   112a4:	53                   	push   %ebx
   112a5:	83 ec 10             	sub    $0x10,%esp
    if(irq_num < IRQ_PIC_START)
   112a8:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   112ac:	7e 78                	jle    11326 <irq_enable+0x85>
    {
        return;
    }
    irq_num -= IRQ_PIC_START;
   112ae:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if(irq_num < 8)
   112b2:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   112b6:	7f 32                	jg     112ea <irq_enable+0x49>
    {
        uint8_t mask = inb(PIC0_IMR) & ~(1 << irq_num);
   112b8:	6a 21                	push   $0x21
   112ba:	e8 4e f9 ff ff       	call   10c0d <inb>
   112bf:	83 c4 04             	add    $0x4,%esp
   112c2:	89 c2                	mov    %eax,%edx
   112c4:	8b 45 08             	mov    0x8(%ebp),%eax
   112c7:	bb 01 00 00 00       	mov    $0x1,%ebx
   112cc:	89 c1                	mov    %eax,%ecx
   112ce:	d3 e3                	shl    %cl,%ebx
   112d0:	89 d8                	mov    %ebx,%eax
   112d2:	f7 d0                	not    %eax
   112d4:	21 d0                	and    %edx,%eax
   112d6:	88 45 fa             	mov    %al,-0x6(%ebp)
        outb(PIC0_IMR,mask);
   112d9:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   112dd:	50                   	push   %eax
   112de:	6a 21                	push   $0x21
   112e0:	e8 45 f9 ff ff       	call   10c2a <outb>
   112e5:	83 c4 08             	add    $0x8,%esp
   112e8:	eb 3d                	jmp    11327 <irq_enable+0x86>
    }
    else
    {
        irq_num -= 8;
   112ea:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
        uint8_t mask = inb(PIC1_IMR) & ~(1 << (irq_num));
   112ee:	68 a1 00 00 00       	push   $0xa1
   112f3:	e8 15 f9 ff ff       	call   10c0d <inb>
   112f8:	83 c4 04             	add    $0x4,%esp
   112fb:	89 c2                	mov    %eax,%edx
   112fd:	8b 45 08             	mov    0x8(%ebp),%eax
   11300:	bb 01 00 00 00       	mov    $0x1,%ebx
   11305:	89 c1                	mov    %eax,%ecx
   11307:	d3 e3                	shl    %cl,%ebx
   11309:	89 d8                	mov    %ebx,%eax
   1130b:	f7 d0                	not    %eax
   1130d:	21 d0                	and    %edx,%eax
   1130f:	88 45 fb             	mov    %al,-0x5(%ebp)
        outb(PIC1_IMR,mask);
   11312:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   11316:	50                   	push   %eax
   11317:	68 a1 00 00 00       	push   $0xa1
   1131c:	e8 09 f9 ff ff       	call   10c2a <outb>
   11321:	83 c4 08             	add    $0x8,%esp
   11324:	eb 01                	jmp    11327 <irq_enable+0x86>
        return;
   11326:	90                   	nop
    }
}
   11327:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1132a:	c9                   	leave  
   1132b:	c3                   	ret    

0001132c <irq_disable>:

void irq_disable(int irq_num)
{
   1132c:	55                   	push   %ebp
   1132d:	89 e5                	mov    %esp,%ebp
   1132f:	53                   	push   %ebx
   11330:	83 ec 10             	sub    $0x10,%esp
    if(irq_num < IRQ_PIC_START)
   11333:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   11337:	7e 78                	jle    113b1 <irq_disable+0x85>
    {
        return;
    }
    irq_num -= IRQ_PIC_START;
   11339:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if(irq_num < 8)
   1133d:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   11341:	7f 32                	jg     11375 <irq_disable+0x49>
    {
        uint8_t mask = inb(PIC0_IMR) | ~(1 << irq_num);
   11343:	6a 21                	push   $0x21
   11345:	e8 c3 f8 ff ff       	call   10c0d <inb>
   1134a:	83 c4 04             	add    $0x4,%esp
   1134d:	89 c3                	mov    %eax,%ebx
   1134f:	8b 45 08             	mov    0x8(%ebp),%eax
   11352:	ba 01 00 00 00       	mov    $0x1,%edx
   11357:	89 c1                	mov    %eax,%ecx
   11359:	d3 e2                	shl    %cl,%edx
   1135b:	89 d0                	mov    %edx,%eax
   1135d:	f7 d0                	not    %eax
   1135f:	09 d8                	or     %ebx,%eax
   11361:	88 45 fa             	mov    %al,-0x6(%ebp)
        outb(PIC0_IMR,mask);
   11364:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   11368:	50                   	push   %eax
   11369:	6a 21                	push   $0x21
   1136b:	e8 ba f8 ff ff       	call   10c2a <outb>
   11370:	83 c4 08             	add    $0x8,%esp
   11373:	eb 3d                	jmp    113b2 <irq_disable+0x86>
    }
    else
    {
        irq_num -= 8;
   11375:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
        uint8_t mask = inb(PIC1_IMR) | ~(1 << (irq_num));
   11379:	68 a1 00 00 00       	push   $0xa1
   1137e:	e8 8a f8 ff ff       	call   10c0d <inb>
   11383:	83 c4 04             	add    $0x4,%esp
   11386:	89 c3                	mov    %eax,%ebx
   11388:	8b 45 08             	mov    0x8(%ebp),%eax
   1138b:	ba 01 00 00 00       	mov    $0x1,%edx
   11390:	89 c1                	mov    %eax,%ecx
   11392:	d3 e2                	shl    %cl,%edx
   11394:	89 d0                	mov    %edx,%eax
   11396:	f7 d0                	not    %eax
   11398:	09 d8                	or     %ebx,%eax
   1139a:	88 45 fb             	mov    %al,-0x5(%ebp)
        outb(PIC1_IMR,mask);
   1139d:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   113a1:	50                   	push   %eax
   113a2:	68 a1 00 00 00       	push   $0xa1
   113a7:	e8 7e f8 ff ff       	call   10c2a <outb>
   113ac:	83 c4 08             	add    $0x8,%esp
   113af:	eb 01                	jmp    113b2 <irq_disable+0x86>
        return;
   113b1:	90                   	nop
    }
}
   113b2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   113b5:	c9                   	leave  
   113b6:	c3                   	ret    

000113b7 <irq_disable_global>:
void irq_disable_global(void)
{
   113b7:	55                   	push   %ebp
   113b8:	89 e5                	mov    %esp,%ebp
    cli();
   113ba:	e8 8a f8 ff ff       	call   10c49 <cli>
}
   113bf:	90                   	nop
   113c0:	5d                   	pop    %ebp
   113c1:	c3                   	ret    

000113c2 <irq_enable_global>:

void irq_enable_global(void)
{
   113c2:	55                   	push   %ebp
   113c3:	89 e5                	mov    %esp,%ebp
    sti();
   113c5:	e8 86 f8 ff ff       	call   10c50 <sti>
}
   113ca:	90                   	nop
   113cb:	5d                   	pop    %ebp
   113cc:	c3                   	ret    

000113cd <pic_send_eoi>:
void pic_send_eoi(int irq_num)
{
   113cd:	55                   	push   %ebp
   113ce:	89 e5                	mov    %esp,%ebp
    irq_num -= IRQ_PIC_START;
   113d0:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if(irq_num >= 8)
   113d4:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   113d8:	7e 0f                	jle    113e9 <pic_send_eoi+0x1c>
    {
        outb(PIC1_OCW2,PIC_OCW2_EOI);
   113da:	6a 20                	push   $0x20
   113dc:	68 a0 00 00 00       	push   $0xa0
   113e1:	e8 44 f8 ff ff       	call   10c2a <outb>
   113e6:	83 c4 08             	add    $0x8,%esp
    }
    outb(PIC0_OCW2,PIC_OCW2_EOI);
   113e9:	6a 20                	push   $0x20
   113eb:	6a 20                	push   $0x20
   113ed:	e8 38 f8 ff ff       	call   10c2a <outb>
   113f2:	83 c4 08             	add    $0x8,%esp
}
   113f5:	90                   	nop
   113f6:	c9                   	leave  
   113f7:	c3                   	ret    

000113f8 <irq_enter_protection>:

irq_state_t irq_enter_protection(void)
{
   113f8:	55                   	push   %ebp
   113f9:	89 e5                	mov    %esp,%ebp
   113fb:	83 ec 10             	sub    $0x10,%esp
    irq_state_t state = read_eflags();
   113fe:	e8 83 f8 ff ff       	call   10c86 <read_eflags>
   11403:	89 45 fc             	mov    %eax,-0x4(%ebp)
    irq_disable_global();
   11406:	e8 ac ff ff ff       	call   113b7 <irq_disable_global>
    return state;
   1140b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1140e:	c9                   	leave  
   1140f:	c3                   	ret    

00011410 <irq_leave_protection>:

void irq_leave_protection(irq_state_t state)
{
   11410:	55                   	push   %ebp
   11411:	89 e5                	mov    %esp,%ebp
    
    write_eflags(state);
   11413:	ff 75 08             	pushl  0x8(%ebp)
   11416:	e8 7b f8 ff ff       	call   10c96 <write_eflags>
   1141b:	83 c4 04             	add    $0x4,%esp
}
   1141e:	90                   	nop
   1141f:	c9                   	leave  
   11420:	c3                   	ret    

00011421 <outb>:
{
   11421:	55                   	push   %ebp
   11422:	89 e5                	mov    %esp,%ebp
   11424:	83 ec 08             	sub    $0x8,%esp
   11427:	8b 55 08             	mov    0x8(%ebp),%edx
   1142a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1142d:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   11431:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]"::[p]"d"(port),[v]"a"(data));
   11434:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   11438:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   1143c:	ee                   	out    %al,(%dx)
}
   1143d:	90                   	nop
   1143e:	c9                   	leave  
   1143f:	c3                   	ret    

00011440 <do_handler_time>:
#include "cpu/irq.h"
#include "os_cfg.h"
#include "comm/cpu_instr.h"
static uint32_t sys_tick;
void do_handler_time(exception_frame_t *frame)
{
   11440:	55                   	push   %ebp
   11441:	89 e5                	mov    %esp,%ebp
   11443:	83 ec 08             	sub    $0x8,%esp
    sys_tick++;
   11446:	a1 00 44 01 00       	mov    0x14400,%eax
   1144b:	83 c0 01             	add    $0x1,%eax
   1144e:	a3 00 44 01 00       	mov    %eax,0x14400
    pic_send_eoi(IRQ0_TIMER);
   11453:	83 ec 0c             	sub    $0xc,%esp
   11456:	6a 20                	push   $0x20
   11458:	e8 70 ff ff ff       	call   113cd <pic_send_eoi>
   1145d:	83 c4 10             	add    $0x10,%esp
    task_time_tick();
   11460:	e8 af f3 ff ff       	call   10814 <task_time_tick>
    
}
   11465:	90                   	nop
   11466:	c9                   	leave  
   11467:	c3                   	ret    

00011468 <init_pit>:
static void init_pit(void)
{
   11468:	55                   	push   %ebp
   11469:	89 e5                	mov    %esp,%ebp
   1146b:	83 ec 18             	sub    $0x18,%esp
    uint32_t reload_count = (PIT_OSC_FREQ * OS_TICK_MS )/ 1000.0;
   1146e:	c7 45 f4 85 74 00 00 	movl   $0x7485,-0xc(%ebp)
    outb(PIT_COMMAND_MODE_PORT,PIT_CHANNEL | PIT_LOAD_LOHI | PIT_MODE3);
   11475:	6a 36                	push   $0x36
   11477:	6a 43                	push   $0x43
   11479:	e8 a3 ff ff ff       	call   11421 <outb>
   1147e:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT,reload_count & 0xff);
   11481:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11484:	0f b6 c0             	movzbl %al,%eax
   11487:	50                   	push   %eax
   11488:	6a 40                	push   $0x40
   1148a:	e8 92 ff ff ff       	call   11421 <outb>
   1148f:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT,(reload_count >> 8) & 0xff);
   11492:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11495:	c1 e8 08             	shr    $0x8,%eax
   11498:	0f b6 c0             	movzbl %al,%eax
   1149b:	50                   	push   %eax
   1149c:	6a 40                	push   $0x40
   1149e:	e8 7e ff ff ff       	call   11421 <outb>
   114a3:	83 c4 08             	add    $0x8,%esp
    irq_install(IRQ0_TIMER,exception_handler_time);
   114a6:	83 ec 08             	sub    $0x8,%esp
   114a9:	68 2b 00 01 00       	push   $0x1002b
   114ae:	6a 20                	push   $0x20
   114b0:	e8 ac fd ff ff       	call   11261 <irq_install>
   114b5:	83 c4 10             	add    $0x10,%esp

    irq_enable(IRQ0_TIMER);
   114b8:	83 ec 0c             	sub    $0xc,%esp
   114bb:	6a 20                	push   $0x20
   114bd:	e8 df fd ff ff       	call   112a1 <irq_enable>
   114c2:	83 c4 10             	add    $0x10,%esp
}
   114c5:	90                   	nop
   114c6:	c9                   	leave  
   114c7:	c3                   	ret    

000114c8 <time_init>:
void time_init(void)
{
   114c8:	55                   	push   %ebp
   114c9:	89 e5                	mov    %esp,%ebp
   114cb:	83 ec 08             	sub    $0x8,%esp
    sys_tick = 0;
   114ce:	c7 05 00 44 01 00 00 	movl   $0x0,0x14400
   114d5:	00 00 00 
    init_pit();
   114d8:	e8 8b ff ff ff       	call   11468 <init_pit>
}
   114dd:	90                   	nop
   114de:	c9                   	leave  
   114df:	c3                   	ret    

000114e0 <kernel_init>:
#include "ipc/sem.h"
#include "ipc/mutex.h"


void kernel_init(boot_info_t * boot_info)
{
   114e0:	55                   	push   %ebp
   114e1:	89 e5                	mov    %esp,%ebp
   114e3:	83 ec 08             	sub    $0x8,%esp
    //ASSERT(boot_info->ram_region_count != 2);
    cpu_init();
   114e6:	e8 f0 f6 ff ff       	call   10bdb <cpu_init>
    log_init(); 
   114eb:	e8 ba 0b 00 00       	call   120aa <log_init>
    irq_init();
   114f0:	e8 ac fb ff ff       	call   110a1 <irq_init>
    time_init();
   114f5:	e8 ce ff ff ff       	call   114c8 <time_init>

    task_manager_init();
   114fa:	e8 9e f0 ff ff       	call   1059d <task_manager_init>
}
   114ff:	90                   	nop
   11500:	c9                   	leave  
   11501:	c3                   	ret    

00011502 <init_task_entry>:

static sem_t sem;
static mutex_t mutex;
static int gobal_count = 0;
void init_task_entry(void)
{
   11502:	55                   	push   %ebp
   11503:	89 e5                	mov    %esp,%ebp
   11505:	83 ec 18             	sub    $0x18,%esp
    //test();
    int count = 0;
   11508:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    for(;;)
    {
        //sys_sleep(3000);
        //sem_wait(&sem);
        mutex_lock(&mutex);
   1150f:	83 ec 0c             	sub    $0xc,%esp
   11512:	68 b0 65 01 00       	push   $0x165b0
   11517:	e8 e1 01 00 00       	call   116fd <mutex_lock>
   1151c:	83 c4 10             	add    $0x10,%esp
        //log_printf("init task count = %d\n", count++);
        gobal_count++;
   1151f:	a1 c4 65 01 00       	mov    0x165c4,%eax
   11524:	83 c0 01             	add    $0x1,%eax
   11527:	a3 c4 65 01 00       	mov    %eax,0x165c4
        log_printf("gobal_count = %d init task\n",gobal_count);
   1152c:	a1 c4 65 01 00       	mov    0x165c4,%eax
   11531:	83 ec 08             	sub    $0x8,%esp
   11534:	50                   	push   %eax
   11535:	68 27 25 01 00       	push   $0x12527
   1153a:	e8 08 0c 00 00       	call   12147 <log_printf>
   1153f:	83 c4 10             	add    $0x10,%esp
        sys_sleep(1000);
   11542:	83 ec 0c             	sub    $0xc,%esp
   11545:	68 e8 03 00 00       	push   $0x3e8
   1154a:	e8 4b f4 ff ff       	call   1099a <sys_sleep>
   1154f:	83 c4 10             	add    $0x10,%esp
        mutex_unlock(&mutex);
   11552:	83 ec 0c             	sub    $0xc,%esp
   11555:	68 b0 65 01 00       	push   $0x165b0
   1155a:	e8 2e 02 00 00       	call   1178d <mutex_unlock>
   1155f:	83 c4 10             	add    $0x10,%esp
        mutex_lock(&mutex);
   11562:	eb ab                	jmp    1150f <init_task_entry+0xd>

00011564 <test_task_entry>:
    }
}

void test_task_entry(void)
{
   11564:	55                   	push   %ebp
   11565:	89 e5                	mov    %esp,%ebp
   11567:	83 ec 18             	sub    $0x18,%esp
    int count = 0;
   1156a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    for(;;)
    {
        //sys_sleep(4000);
        //sem_wait(&sem);
        mutex_lock(&mutex);
   11571:	83 ec 0c             	sub    $0xc,%esp
   11574:	68 b0 65 01 00       	push   $0x165b0
   11579:	e8 7f 01 00 00       	call   116fd <mutex_lock>
   1157e:	83 c4 10             	add    $0x10,%esp
        //log_printf("init idle count = %d\n", count++);
        gobal_count++;
   11581:	a1 c4 65 01 00       	mov    0x165c4,%eax
   11586:	83 c0 01             	add    $0x1,%eax
   11589:	a3 c4 65 01 00       	mov    %eax,0x165c4
        log_printf("gobal_count = %d test task\n",gobal_count);
   1158e:	a1 c4 65 01 00       	mov    0x165c4,%eax
   11593:	83 ec 08             	sub    $0x8,%esp
   11596:	50                   	push   %eax
   11597:	68 43 25 01 00       	push   $0x12543
   1159c:	e8 a6 0b 00 00       	call   12147 <log_printf>
   115a1:	83 c4 10             	add    $0x10,%esp
        sys_sleep(1000);
   115a4:	83 ec 0c             	sub    $0xc,%esp
   115a7:	68 e8 03 00 00       	push   $0x3e8
   115ac:	e8 e9 f3 ff ff       	call   1099a <sys_sleep>
   115b1:	83 c4 10             	add    $0x10,%esp
        mutex_unlock(&mutex);
   115b4:	83 ec 0c             	sub    $0xc,%esp
   115b7:	68 b0 65 01 00       	push   $0x165b0
   115bc:	e8 cc 01 00 00       	call   1178d <mutex_unlock>
   115c1:	83 c4 10             	add    $0x10,%esp
        mutex_lock(&mutex);
   115c4:	eb ab                	jmp    11571 <test_task_entry+0xd>

000115c6 <init_main>:
    }
}

void init_main(void)
{
   115c6:	55                   	push   %ebp
   115c7:	89 e5                	mov    %esp,%ebp
   115c9:	83 ec 18             	sub    $0x18,%esp
    sem_init(&sem,0);
   115cc:	83 ec 08             	sub    $0x8,%esp
   115cf:	6a 00                	push   $0x0
   115d1:	68 a0 65 01 00       	push   $0x165a0
   115d6:	e8 77 02 00 00       	call   11852 <sem_init>
   115db:	83 c4 10             	add    $0x10,%esp
    
    //int a = 3 / 0;
    log_printf("init main\n");
   115de:	83 ec 0c             	sub    $0xc,%esp
   115e1:	68 5f 25 01 00       	push   $0x1255f
   115e6:	e8 5c 0b 00 00       	call   12147 <log_printf>
   115eb:	83 c4 10             	add    $0x10,%esp
    task_init(&init_task,"init_task",(uint32_t)init_task_entry,(uint32_t)&init_task_stack[1024]);
   115ee:	ba e0 54 01 00       	mov    $0x154e0,%edx
   115f3:	b8 02 15 01 00       	mov    $0x11502,%eax
   115f8:	52                   	push   %edx
   115f9:	50                   	push   %eax
   115fa:	68 6a 25 01 00       	push   $0x1256a
   115ff:	68 20 44 01 00       	push   $0x14420
   11604:	e8 4c ee ff ff       	call   10455 <task_init>
   11609:	83 c4 10             	add    $0x10,%esp
    task_init(&test_task,"test_task",(uint32_t)test_task_entry,(uint32_t)&test_task_stack[1024]);
   1160c:	ba a0 65 01 00       	mov    $0x165a0,%edx
   11611:	b8 64 15 01 00       	mov    $0x11564,%eax
   11616:	52                   	push   %edx
   11617:	50                   	push   %eax
   11618:	68 74 25 01 00       	push   $0x12574
   1161d:	68 e0 54 01 00       	push   $0x154e0
   11622:	e8 2e ee ff ff       	call   10455 <task_init>
   11627:	83 c4 10             	add    $0x10,%esp
    task_first_init();
   1162a:	e8 ed ef ff ff       	call   1061c <task_first_init>

    irq_enable_global();
   1162f:	e8 8e fd ff ff       	call   113c2 <irq_enable_global>
    int count = 0;
   11634:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    for(;;)
    {
        mutex_lock(&mutex);
   1163b:	83 ec 0c             	sub    $0xc,%esp
   1163e:	68 b0 65 01 00       	push   $0x165b0
   11643:	e8 b5 00 00 00       	call   116fd <mutex_lock>
   11648:	83 c4 10             	add    $0x10,%esp
        //log_printf("init main count = %d\n", count++);
        //sys_sleep(3000);
        //sem_notify(&sem);
        gobal_count++;
   1164b:	a1 c4 65 01 00       	mov    0x165c4,%eax
   11650:	83 c0 01             	add    $0x1,%eax
   11653:	a3 c4 65 01 00       	mov    %eax,0x165c4
        log_printf("gobal_count = %d init main\n",gobal_count);
   11658:	a1 c4 65 01 00       	mov    0x165c4,%eax
   1165d:	83 ec 08             	sub    $0x8,%esp
   11660:	50                   	push   %eax
   11661:	68 7e 25 01 00       	push   $0x1257e
   11666:	e8 dc 0a 00 00       	call   12147 <log_printf>
   1166b:	83 c4 10             	add    $0x10,%esp
        sys_sleep(1000);
   1166e:	83 ec 0c             	sub    $0xc,%esp
   11671:	68 e8 03 00 00       	push   $0x3e8
   11676:	e8 1f f3 ff ff       	call   1099a <sys_sleep>
   1167b:	83 c4 10             	add    $0x10,%esp
        gobal_count++;
   1167e:	a1 c4 65 01 00       	mov    0x165c4,%eax
   11683:	83 c0 01             	add    $0x1,%eax
   11686:	a3 c4 65 01 00       	mov    %eax,0x165c4
        log_printf("gobal_count = %d init main\n",gobal_count);
   1168b:	a1 c4 65 01 00       	mov    0x165c4,%eax
   11690:	83 ec 08             	sub    $0x8,%esp
   11693:	50                   	push   %eax
   11694:	68 7e 25 01 00       	push   $0x1257e
   11699:	e8 a9 0a 00 00       	call   12147 <log_printf>
   1169e:	83 c4 10             	add    $0x10,%esp
        sys_sleep(1000);
   116a1:	83 ec 0c             	sub    $0xc,%esp
   116a4:	68 e8 03 00 00       	push   $0x3e8
   116a9:	e8 ec f2 ff ff       	call   1099a <sys_sleep>
   116ae:	83 c4 10             	add    $0x10,%esp
        mutex_unlock(&mutex);
   116b1:	83 ec 0c             	sub    $0xc,%esp
   116b4:	68 b0 65 01 00       	push   $0x165b0
   116b9:	e8 cf 00 00 00       	call   1178d <mutex_unlock>
   116be:	83 c4 10             	add    $0x10,%esp
        mutex_lock(&mutex);
   116c1:	e9 75 ff ff ff       	jmp    1163b <init_main+0x75>

000116c6 <list_count>:
{
   116c6:	55                   	push   %ebp
   116c7:	89 e5                	mov    %esp,%ebp
    return list->count;
   116c9:	8b 45 08             	mov    0x8(%ebp),%eax
   116cc:	8b 40 08             	mov    0x8(%eax),%eax
}
   116cf:	5d                   	pop    %ebp
   116d0:	c3                   	ret    

000116d1 <mutex_init>:
 */
#include "ipc/mutex.h"
#include "cpu/irq.h"

void mutex_init(mutex_t *mutex)
{
   116d1:	55                   	push   %ebp
   116d2:	89 e5                	mov    %esp,%ebp
   116d4:	83 ec 08             	sub    $0x8,%esp
    mutex->owner = (task_t *)0;
   116d7:	8b 45 08             	mov    0x8(%ebp),%eax
   116da:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    mutex->locked_count = 0;
   116e1:	8b 45 08             	mov    0x8(%ebp),%eax
   116e4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    list_init(&mutex->wait_list);
   116eb:	8b 45 08             	mov    0x8(%ebp),%eax
   116ee:	83 ec 0c             	sub    $0xc,%esp
   116f1:	50                   	push   %eax
   116f2:	e8 94 07 00 00       	call   11e8b <list_init>
   116f7:	83 c4 10             	add    $0x10,%esp
}
   116fa:	90                   	nop
   116fb:	c9                   	leave  
   116fc:	c3                   	ret    

000116fd <mutex_lock>:

void mutex_lock(mutex_t *mutex)
{
   116fd:	55                   	push   %ebp
   116fe:	89 e5                	mov    %esp,%ebp
   11700:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   11703:	e8 f0 fc ff ff       	call   113f8 <irq_enter_protection>
   11708:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t *curr = task_current();
   1170b:	e8 d1 ef ff ff       	call   106e1 <task_current>
   11710:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(mutex->locked_count == 0)
   11713:	8b 45 08             	mov    0x8(%ebp),%eax
   11716:	8b 40 10             	mov    0x10(%eax),%eax
   11719:	85 c0                	test   %eax,%eax
   1171b:	75 1a                	jne    11737 <mutex_lock+0x3a>
    {
        mutex->locked_count++;
   1171d:	8b 45 08             	mov    0x8(%ebp),%eax
   11720:	8b 40 10             	mov    0x10(%eax),%eax
   11723:	8d 50 01             	lea    0x1(%eax),%edx
   11726:	8b 45 08             	mov    0x8(%ebp),%eax
   11729:	89 50 10             	mov    %edx,0x10(%eax)
        mutex->owner = curr;
   1172c:	8b 45 08             	mov    0x8(%ebp),%eax
   1172f:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11732:	89 50 0c             	mov    %edx,0xc(%eax)
   11735:	eb 45                	jmp    1177c <mutex_lock+0x7f>
    }else if(mutex->owner == curr)
   11737:	8b 45 08             	mov    0x8(%ebp),%eax
   1173a:	8b 40 0c             	mov    0xc(%eax),%eax
   1173d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11740:	75 11                	jne    11753 <mutex_lock+0x56>
    {
        mutex->locked_count++;
   11742:	8b 45 08             	mov    0x8(%ebp),%eax
   11745:	8b 40 10             	mov    0x10(%eax),%eax
   11748:	8d 50 01             	lea    0x1(%eax),%edx
   1174b:	8b 45 08             	mov    0x8(%ebp),%eax
   1174e:	89 50 10             	mov    %edx,0x10(%eax)
   11751:	eb 29                	jmp    1177c <mutex_lock+0x7f>
    }else
    {
        task_set_block(curr);
   11753:	83 ec 0c             	sub    $0xc,%esp
   11756:	ff 75 f0             	pushl  -0x10(%ebp)
   11759:	e8 58 ef ff ff       	call   106b6 <task_set_block>
   1175e:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&mutex->wait_list,&curr->wait_node);
   11761:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11764:	8d 50 44             	lea    0x44(%eax),%edx
   11767:	8b 45 08             	mov    0x8(%ebp),%eax
   1176a:	83 ec 08             	sub    $0x8,%esp
   1176d:	52                   	push   %edx
   1176e:	50                   	push   %eax
   1176f:	e8 9b 07 00 00       	call   11f0f <list_insert_last>
   11774:	83 c4 10             	add    $0x10,%esp
        schedule_switch();
   11777:	e8 20 f0 ff ff       	call   1079c <schedule_switch>
    }
    irq_leave_protection(state);
   1177c:	83 ec 0c             	sub    $0xc,%esp
   1177f:	ff 75 f4             	pushl  -0xc(%ebp)
   11782:	e8 89 fc ff ff       	call   11410 <irq_leave_protection>
   11787:	83 c4 10             	add    $0x10,%esp
}
   1178a:	90                   	nop
   1178b:	c9                   	leave  
   1178c:	c3                   	ret    

0001178d <mutex_unlock>:

void mutex_unlock(mutex_t *mutex)
{
   1178d:	55                   	push   %ebp
   1178e:	89 e5                	mov    %esp,%ebp
   11790:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   11793:	e8 60 fc ff ff       	call   113f8 <irq_enter_protection>
   11798:	89 45 f4             	mov    %eax,-0xc(%ebp)

    task_t * curr = task_current();
   1179b:	e8 41 ef ff ff       	call   106e1 <task_current>
   117a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(mutex->owner == curr)
   117a3:	8b 45 08             	mov    0x8(%ebp),%eax
   117a6:	8b 40 0c             	mov    0xc(%eax),%eax
   117a9:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   117ac:	0f 85 84 00 00 00    	jne    11836 <mutex_unlock+0xa9>
    {
        if(--mutex->locked_count == 0)
   117b2:	8b 45 08             	mov    0x8(%ebp),%eax
   117b5:	8b 40 10             	mov    0x10(%eax),%eax
   117b8:	8d 50 ff             	lea    -0x1(%eax),%edx
   117bb:	8b 45 08             	mov    0x8(%ebp),%eax
   117be:	89 50 10             	mov    %edx,0x10(%eax)
   117c1:	8b 45 08             	mov    0x8(%ebp),%eax
   117c4:	8b 40 10             	mov    0x10(%eax),%eax
   117c7:	85 c0                	test   %eax,%eax
   117c9:	75 6b                	jne    11836 <mutex_unlock+0xa9>
        {
            mutex->owner = (task_t *)0;
   117cb:	8b 45 08             	mov    0x8(%ebp),%eax
   117ce:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
            if(list_count(&mutex->wait_list))
   117d5:	8b 45 08             	mov    0x8(%ebp),%eax
   117d8:	83 ec 0c             	sub    $0xc,%esp
   117db:	50                   	push   %eax
   117dc:	e8 e5 fe ff ff       	call   116c6 <list_count>
   117e1:	83 c4 10             	add    $0x10,%esp
   117e4:	85 c0                	test   %eax,%eax
   117e6:	74 4e                	je     11836 <mutex_unlock+0xa9>
            {
                list_node_t * node = list_remove_first(&mutex->wait_list);
   117e8:	8b 45 08             	mov    0x8(%ebp),%eax
   117eb:	83 ec 0c             	sub    $0xc,%esp
   117ee:	50                   	push   %eax
   117ef:	e8 7f 07 00 00       	call   11f73 <list_remove_first>
   117f4:	83 c4 10             	add    $0x10,%esp
   117f7:	89 45 ec             	mov    %eax,-0x14(%ebp)
                task_t * task = list_node_parent(node,task_t,wait_node);
   117fa:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   117fe:	74 08                	je     11808 <mutex_unlock+0x7b>
   11800:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11803:	83 e8 44             	sub    $0x44,%eax
   11806:	eb 05                	jmp    1180d <mutex_unlock+0x80>
   11808:	b8 00 00 00 00       	mov    $0x0,%eax
   1180d:	89 45 e8             	mov    %eax,-0x18(%ebp)
                task_set_ready(task);
   11810:	83 ec 0c             	sub    $0xc,%esp
   11813:	ff 75 e8             	pushl  -0x18(%ebp)
   11816:	e8 66 ee ff ff       	call   10681 <task_set_ready>
   1181b:	83 c4 10             	add    $0x10,%esp
                mutex->locked_count = 1;
   1181e:	8b 45 08             	mov    0x8(%ebp),%eax
   11821:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
                mutex->owner = task;
   11828:	8b 45 08             	mov    0x8(%ebp),%eax
   1182b:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1182e:	89 50 0c             	mov    %edx,0xc(%eax)
                schedule_switch();
   11831:	e8 66 ef ff ff       	call   1079c <schedule_switch>
            }
        }
    }
    irq_leave_protection(state);
   11836:	83 ec 0c             	sub    $0xc,%esp
   11839:	ff 75 f4             	pushl  -0xc(%ebp)
   1183c:	e8 cf fb ff ff       	call   11410 <irq_leave_protection>
   11841:	83 c4 10             	add    $0x10,%esp
}
   11844:	90                   	nop
   11845:	c9                   	leave  
   11846:	c3                   	ret    

00011847 <list_count>:
{
   11847:	55                   	push   %ebp
   11848:	89 e5                	mov    %esp,%ebp
    return list->count;
   1184a:	8b 45 08             	mov    0x8(%ebp),%eax
   1184d:	8b 40 08             	mov    0x8(%eax),%eax
}
   11850:	5d                   	pop    %ebp
   11851:	c3                   	ret    

00011852 <sem_init>:
#include "ipc/sem.h"
#include "core/task.h"
#include "cpu/irq.h"
void sem_init(sem_t *sem,int count)
{
   11852:	55                   	push   %ebp
   11853:	89 e5                	mov    %esp,%ebp
   11855:	83 ec 08             	sub    $0x8,%esp
    sem->count = count;
   11858:	8b 45 08             	mov    0x8(%ebp),%eax
   1185b:	8b 55 0c             	mov    0xc(%ebp),%edx
   1185e:	89 10                	mov    %edx,(%eax)
    list_init(&sem->wait_list);
   11860:	8b 45 08             	mov    0x8(%ebp),%eax
   11863:	83 c0 04             	add    $0x4,%eax
   11866:	83 ec 0c             	sub    $0xc,%esp
   11869:	50                   	push   %eax
   1186a:	e8 1c 06 00 00       	call   11e8b <list_init>
   1186f:	83 c4 10             	add    $0x10,%esp
}
   11872:	90                   	nop
   11873:	c9                   	leave  
   11874:	c3                   	ret    

00011875 <sem_wait>:

void sem_wait(sem_t *sem)
{
   11875:	55                   	push   %ebp
   11876:	89 e5                	mov    %esp,%ebp
   11878:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   1187b:	e8 78 fb ff ff       	call   113f8 <irq_enter_protection>
   11880:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(sem->count > 0)
   11883:	8b 45 08             	mov    0x8(%ebp),%eax
   11886:	8b 00                	mov    (%eax),%eax
   11888:	85 c0                	test   %eax,%eax
   1188a:	7e 0f                	jle    1189b <sem_wait+0x26>
    {
        sem->count--;
   1188c:	8b 45 08             	mov    0x8(%ebp),%eax
   1188f:	8b 00                	mov    (%eax),%eax
   11891:	8d 50 ff             	lea    -0x1(%eax),%edx
   11894:	8b 45 08             	mov    0x8(%ebp),%eax
   11897:	89 10                	mov    %edx,(%eax)
   11899:	eb 34                	jmp    118cf <sem_wait+0x5a>
    }
    else
    {
        task_t *curr = task_current();
   1189b:	e8 41 ee ff ff       	call   106e1 <task_current>
   118a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_set_block(curr);
   118a3:	83 ec 0c             	sub    $0xc,%esp
   118a6:	ff 75 f0             	pushl  -0x10(%ebp)
   118a9:	e8 08 ee ff ff       	call   106b6 <task_set_block>
   118ae:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&sem->wait_list,&curr->wait_node);
   118b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   118b4:	8d 50 44             	lea    0x44(%eax),%edx
   118b7:	8b 45 08             	mov    0x8(%ebp),%eax
   118ba:	83 c0 04             	add    $0x4,%eax
   118bd:	83 ec 08             	sub    $0x8,%esp
   118c0:	52                   	push   %edx
   118c1:	50                   	push   %eax
   118c2:	e8 48 06 00 00       	call   11f0f <list_insert_last>
   118c7:	83 c4 10             	add    $0x10,%esp
        schedule_switch();
   118ca:	e8 cd ee ff ff       	call   1079c <schedule_switch>
    }
    irq_leave_protection(state);
   118cf:	83 ec 0c             	sub    $0xc,%esp
   118d2:	ff 75 f4             	pushl  -0xc(%ebp)
   118d5:	e8 36 fb ff ff       	call   11410 <irq_leave_protection>
   118da:	83 c4 10             	add    $0x10,%esp
}
   118dd:	90                   	nop
   118de:	c9                   	leave  
   118df:	c3                   	ret    

000118e0 <sem_notify>:


void sem_notify(sem_t *sem)
{
   118e0:	55                   	push   %ebp
   118e1:	89 e5                	mov    %esp,%ebp
   118e3:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   118e6:	e8 0d fb ff ff       	call   113f8 <irq_enter_protection>
   118eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(list_count(&sem->wait_list) > 0)
   118ee:	8b 45 08             	mov    0x8(%ebp),%eax
   118f1:	83 c0 04             	add    $0x4,%eax
   118f4:	83 ec 0c             	sub    $0xc,%esp
   118f7:	50                   	push   %eax
   118f8:	e8 4a ff ff ff       	call   11847 <list_count>
   118fd:	83 c4 10             	add    $0x10,%esp
   11900:	85 c0                	test   %eax,%eax
   11902:	7e 40                	jle    11944 <sem_notify+0x64>
    {
        list_node_t * node = list_remove_first(&sem->wait_list);
   11904:	8b 45 08             	mov    0x8(%ebp),%eax
   11907:	83 c0 04             	add    $0x4,%eax
   1190a:	83 ec 0c             	sub    $0xc,%esp
   1190d:	50                   	push   %eax
   1190e:	e8 60 06 00 00       	call   11f73 <list_remove_first>
   11913:	83 c4 10             	add    $0x10,%esp
   11916:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_t *task = list_node_parent(node,task_t,wait_node);
   11919:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1191d:	74 08                	je     11927 <sem_notify+0x47>
   1191f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11922:	83 e8 44             	sub    $0x44,%eax
   11925:	eb 05                	jmp    1192c <sem_notify+0x4c>
   11927:	b8 00 00 00 00       	mov    $0x0,%eax
   1192c:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_set_ready(task);
   1192f:	83 ec 0c             	sub    $0xc,%esp
   11932:	ff 75 ec             	pushl  -0x14(%ebp)
   11935:	e8 47 ed ff ff       	call   10681 <task_set_ready>
   1193a:	83 c4 10             	add    $0x10,%esp
        schedule_switch();
   1193d:	e8 5a ee ff ff       	call   1079c <schedule_switch>
   11942:	eb 0d                	jmp    11951 <sem_notify+0x71>
    }
    else
    {
        sem->count++;
   11944:	8b 45 08             	mov    0x8(%ebp),%eax
   11947:	8b 00                	mov    (%eax),%eax
   11949:	8d 50 01             	lea    0x1(%eax),%edx
   1194c:	8b 45 08             	mov    0x8(%ebp),%eax
   1194f:	89 10                	mov    %edx,(%eax)
    }
    irq_leave_protection(state);
   11951:	83 ec 0c             	sub    $0xc,%esp
   11954:	ff 75 f4             	pushl  -0xc(%ebp)
   11957:	e8 b4 fa ff ff       	call   11410 <irq_leave_protection>
   1195c:	83 c4 10             	add    $0x10,%esp
}
   1195f:	90                   	nop
   11960:	c9                   	leave  
   11961:	c3                   	ret    

00011962 <sem_count>:
int sem_count(sem_t *sem)
{
   11962:	55                   	push   %ebp
   11963:	89 e5                	mov    %esp,%ebp
   11965:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   11968:	e8 8b fa ff ff       	call   113f8 <irq_enter_protection>
   1196d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int count = sem->count;
   11970:	8b 45 08             	mov    0x8(%ebp),%eax
   11973:	8b 00                	mov    (%eax),%eax
   11975:	89 45 f0             	mov    %eax,-0x10(%ebp)
    irq_leave_protection(state);
   11978:	83 ec 0c             	sub    $0xc,%esp
   1197b:	ff 75 f4             	pushl  -0xc(%ebp)
   1197e:	e8 8d fa ff ff       	call   11410 <irq_leave_protection>
   11983:	83 c4 10             	add    $0x10,%esp
    return count;
   11986:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   11989:	c9                   	leave  
   1198a:	c3                   	ret    

0001198b <hlt>:
{
   1198b:	55                   	push   %ebp
   1198c:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   1198e:	f4                   	hlt    
}
   1198f:	90                   	nop
   11990:	5d                   	pop    %ebp
   11991:	c3                   	ret    

00011992 <kernel_strcpy>:
#include "tools/klib.h"
#include "comm/types.h"
#include "comm/cpu_instr.h"
void kernel_strcpy (char *dest, const char *src)
{
   11992:	55                   	push   %ebp
   11993:	89 e5                	mov    %esp,%ebp
    if(!dest || !src)
   11995:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11999:	74 27                	je     119c2 <kernel_strcpy+0x30>
   1199b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1199f:	74 21                	je     119c2 <kernel_strcpy+0x30>
    {
        return;
    }
    while((*dest++ = *src++) != '\0');
   119a1:	90                   	nop
   119a2:	8b 55 0c             	mov    0xc(%ebp),%edx
   119a5:	8d 42 01             	lea    0x1(%edx),%eax
   119a8:	89 45 0c             	mov    %eax,0xc(%ebp)
   119ab:	8b 45 08             	mov    0x8(%ebp),%eax
   119ae:	8d 48 01             	lea    0x1(%eax),%ecx
   119b1:	89 4d 08             	mov    %ecx,0x8(%ebp)
   119b4:	0f b6 12             	movzbl (%edx),%edx
   119b7:	88 10                	mov    %dl,(%eax)
   119b9:	0f b6 00             	movzbl (%eax),%eax
   119bc:	84 c0                	test   %al,%al
   119be:	75 e2                	jne    119a2 <kernel_strcpy+0x10>
   119c0:	eb 01                	jmp    119c3 <kernel_strcpy+0x31>
        return;
   119c2:	90                   	nop
    //*dest = '\0';
}
   119c3:	5d                   	pop    %ebp
   119c4:	c3                   	ret    

000119c5 <kernel_strncpy>:

void kernel_strncpy (char *dest, const char *src, int size)
{
   119c5:	55                   	push   %ebp
   119c6:	89 e5                	mov    %esp,%ebp
   119c8:	83 ec 10             	sub    $0x10,%esp
    if(!dest || !src)
   119cb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   119cf:	74 5b                	je     11a2c <kernel_strncpy+0x67>
   119d1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   119d5:	74 55                	je     11a2c <kernel_strncpy+0x67>
    {
        return;
    }
    char *d = dest;
   119d7:	8b 45 08             	mov    0x8(%ebp),%eax
   119da:	89 45 fc             	mov    %eax,-0x4(%ebp)
    const char *s = src;
   119dd:	8b 45 0c             	mov    0xc(%ebp),%eax
   119e0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(size-- > 0 && (*s))
   119e3:	eb 17                	jmp    119fc <kernel_strncpy+0x37>
    {
        *d++ = *s++;
   119e5:	8b 55 f8             	mov    -0x8(%ebp),%edx
   119e8:	8d 42 01             	lea    0x1(%edx),%eax
   119eb:	89 45 f8             	mov    %eax,-0x8(%ebp)
   119ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
   119f1:	8d 48 01             	lea    0x1(%eax),%ecx
   119f4:	89 4d fc             	mov    %ecx,-0x4(%ebp)
   119f7:	0f b6 12             	movzbl (%edx),%edx
   119fa:	88 10                	mov    %dl,(%eax)
    while(size-- > 0 && (*s))
   119fc:	8b 45 10             	mov    0x10(%ebp),%eax
   119ff:	8d 50 ff             	lea    -0x1(%eax),%edx
   11a02:	89 55 10             	mov    %edx,0x10(%ebp)
   11a05:	85 c0                	test   %eax,%eax
   11a07:	7e 0a                	jle    11a13 <kernel_strncpy+0x4e>
   11a09:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11a0c:	0f b6 00             	movzbl (%eax),%eax
   11a0f:	84 c0                	test   %al,%al
   11a11:	75 d2                	jne    119e5 <kernel_strncpy+0x20>
    }
    if(size == 0)
   11a13:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11a17:	75 0b                	jne    11a24 <kernel_strncpy+0x5f>
    {
        *(d - 1) = '\0';
   11a19:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11a1c:	83 e8 01             	sub    $0x1,%eax
   11a1f:	c6 00 00             	movb   $0x0,(%eax)
   11a22:	eb 09                	jmp    11a2d <kernel_strncpy+0x68>
    }
    else
    {
        *d = '\0';
   11a24:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11a27:	c6 00 00             	movb   $0x0,(%eax)
   11a2a:	eb 01                	jmp    11a2d <kernel_strncpy+0x68>
        return;
   11a2c:	90                   	nop
    }
}
   11a2d:	c9                   	leave  
   11a2e:	c3                   	ret    

00011a2f <kernel_strncmp>:

int kernel_strncmp (const char *str1, const char *str2, int size)
{
   11a2f:	55                   	push   %ebp
   11a30:	89 e5                	mov    %esp,%ebp
    if(!str1 || !str2)
   11a32:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11a36:	74 06                	je     11a3e <kernel_strncmp+0xf>
   11a38:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11a3c:	75 0f                	jne    11a4d <kernel_strncmp+0x1e>
    {
        return 0;
   11a3e:	b8 00 00 00 00       	mov    $0x0,%eax
   11a43:	eb 62                	jmp    11aa7 <kernel_strncmp+0x78>
    }
    while(*str1 && *str2 && (*str1 == *str2) && size)
    {
        str1++;
   11a45:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        str2++;
   11a49:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
    while(*str1 && *str2 && (*str1 == *str2) && size)
   11a4d:	8b 45 08             	mov    0x8(%ebp),%eax
   11a50:	0f b6 00             	movzbl (%eax),%eax
   11a53:	84 c0                	test   %al,%al
   11a55:	74 20                	je     11a77 <kernel_strncmp+0x48>
   11a57:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a5a:	0f b6 00             	movzbl (%eax),%eax
   11a5d:	84 c0                	test   %al,%al
   11a5f:	74 16                	je     11a77 <kernel_strncmp+0x48>
   11a61:	8b 45 08             	mov    0x8(%ebp),%eax
   11a64:	0f b6 10             	movzbl (%eax),%edx
   11a67:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a6a:	0f b6 00             	movzbl (%eax),%eax
   11a6d:	38 c2                	cmp    %al,%dl
   11a6f:	75 06                	jne    11a77 <kernel_strncmp+0x48>
   11a71:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11a75:	75 ce                	jne    11a45 <kernel_strncmp+0x16>
    }
    return !((*str1 == '\0') || (*str2 == '\0') || (*str1 == *str2));
   11a77:	8b 45 08             	mov    0x8(%ebp),%eax
   11a7a:	0f b6 00             	movzbl (%eax),%eax
   11a7d:	84 c0                	test   %al,%al
   11a7f:	74 21                	je     11aa2 <kernel_strncmp+0x73>
   11a81:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a84:	0f b6 00             	movzbl (%eax),%eax
   11a87:	84 c0                	test   %al,%al
   11a89:	74 17                	je     11aa2 <kernel_strncmp+0x73>
   11a8b:	8b 45 08             	mov    0x8(%ebp),%eax
   11a8e:	0f b6 10             	movzbl (%eax),%edx
   11a91:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a94:	0f b6 00             	movzbl (%eax),%eax
   11a97:	38 c2                	cmp    %al,%dl
   11a99:	74 07                	je     11aa2 <kernel_strncmp+0x73>
   11a9b:	b8 01 00 00 00       	mov    $0x1,%eax
   11aa0:	eb 05                	jmp    11aa7 <kernel_strncmp+0x78>
   11aa2:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11aa7:	5d                   	pop    %ebp
   11aa8:	c3                   	ret    

00011aa9 <kernel_strlen>:

int kernel_strlen (const char *str)
{
   11aa9:	55                   	push   %ebp
   11aaa:	89 e5                	mov    %esp,%ebp
   11aac:	83 ec 10             	sub    $0x10,%esp
    if(!str)
   11aaf:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11ab3:	75 07                	jne    11abc <kernel_strlen+0x13>
    {
        return 0;
   11ab5:	b8 00 00 00 00       	mov    $0x0,%eax
   11aba:	eb 26                	jmp    11ae2 <kernel_strlen+0x39>
    }
    const char *s = str;
   11abc:	8b 45 08             	mov    0x8(%ebp),%eax
   11abf:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int len = 0;
   11ac2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    while(*s++)
   11ac9:	eb 04                	jmp    11acf <kernel_strlen+0x26>
    {
        len++;
   11acb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while(*s++)
   11acf:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11ad2:	8d 50 01             	lea    0x1(%eax),%edx
   11ad5:	89 55 fc             	mov    %edx,-0x4(%ebp)
   11ad8:	0f b6 00             	movzbl (%eax),%eax
   11adb:	84 c0                	test   %al,%al
   11add:	75 ec                	jne    11acb <kernel_strlen+0x22>
    }
    return len;
   11adf:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
   11ae2:	c9                   	leave  
   11ae3:	c3                   	ret    

00011ae4 <kernel_memcpy>:


void kernel_memcpy (void *dest, void *src, int size)
{
   11ae4:	55                   	push   %ebp
   11ae5:	89 e5                	mov    %esp,%ebp
   11ae7:	83 ec 10             	sub    $0x10,%esp
    if(!dest || !src || size <= 0)
   11aea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11aee:	74 40                	je     11b30 <kernel_memcpy+0x4c>
   11af0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11af4:	74 3a                	je     11b30 <kernel_memcpy+0x4c>
   11af6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11afa:	7e 34                	jle    11b30 <kernel_memcpy+0x4c>
    {
        return;
    }
    uint8_t *d = (uint8_t *)dest;
   11afc:	8b 45 08             	mov    0x8(%ebp),%eax
   11aff:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t *s = (uint8_t *)src;
   11b02:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b05:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(size--)
   11b08:	eb 17                	jmp    11b21 <kernel_memcpy+0x3d>
    {
        *d++ = *s++;
   11b0a:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11b0d:	8d 42 01             	lea    0x1(%edx),%eax
   11b10:	89 45 f8             	mov    %eax,-0x8(%ebp)
   11b13:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b16:	8d 48 01             	lea    0x1(%eax),%ecx
   11b19:	89 4d fc             	mov    %ecx,-0x4(%ebp)
   11b1c:	0f b6 12             	movzbl (%edx),%edx
   11b1f:	88 10                	mov    %dl,(%eax)
    while(size--)
   11b21:	8b 45 10             	mov    0x10(%ebp),%eax
   11b24:	8d 50 ff             	lea    -0x1(%eax),%edx
   11b27:	89 55 10             	mov    %edx,0x10(%ebp)
   11b2a:	85 c0                	test   %eax,%eax
   11b2c:	75 dc                	jne    11b0a <kernel_memcpy+0x26>
   11b2e:	eb 01                	jmp    11b31 <kernel_memcpy+0x4d>
        return;
   11b30:	90                   	nop
    }
}
   11b31:	c9                   	leave  
   11b32:	c3                   	ret    

00011b33 <kernel_memset>:

void kernel_memset (void *dest, int c, int size)
{
   11b33:	55                   	push   %ebp
   11b34:	89 e5                	mov    %esp,%ebp
   11b36:	83 ec 10             	sub    $0x10,%esp
    if(!dest || size <= 0)
   11b39:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11b3d:	74 2b                	je     11b6a <kernel_memset+0x37>
   11b3f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11b43:	7e 25                	jle    11b6a <kernel_memset+0x37>
    {
        return;
    }
    uint8_t *d = (uint8_t *)dest;
   11b45:	8b 45 08             	mov    0x8(%ebp),%eax
   11b48:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(size--)
   11b4b:	eb 0e                	jmp    11b5b <kernel_memset+0x28>
    {
        *d++ = (uint8_t)c;
   11b4d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b50:	8d 50 01             	lea    0x1(%eax),%edx
   11b53:	89 55 fc             	mov    %edx,-0x4(%ebp)
   11b56:	8b 55 0c             	mov    0xc(%ebp),%edx
   11b59:	88 10                	mov    %dl,(%eax)
    while(size--)
   11b5b:	8b 45 10             	mov    0x10(%ebp),%eax
   11b5e:	8d 50 ff             	lea    -0x1(%eax),%edx
   11b61:	89 55 10             	mov    %edx,0x10(%ebp)
   11b64:	85 c0                	test   %eax,%eax
   11b66:	75 e5                	jne    11b4d <kernel_memset+0x1a>
   11b68:	eb 01                	jmp    11b6b <kernel_memset+0x38>
        return;
   11b6a:	90                   	nop
    }
}
   11b6b:	c9                   	leave  
   11b6c:	c3                   	ret    

00011b6d <kernel_memcmp>:

int kernel_memcmp (void *d1, void *d2, int size)
{
   11b6d:	55                   	push   %ebp
   11b6e:	89 e5                	mov    %esp,%ebp
   11b70:	83 ec 10             	sub    $0x10,%esp
    if(!d1 || !d2 || !size)
   11b73:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11b77:	74 0c                	je     11b85 <kernel_memcmp+0x18>
   11b79:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11b7d:	74 06                	je     11b85 <kernel_memcmp+0x18>
   11b7f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11b83:	75 07                	jne    11b8c <kernel_memcmp+0x1f>
    {
        return 1;
   11b85:	b8 01 00 00 00       	mov    $0x1,%eax
   11b8a:	eb 43                	jmp    11bcf <kernel_memcmp+0x62>
    }
    uint8_t *p_d1 = (uint8_t *)d1;
   11b8c:	8b 45 08             	mov    0x8(%ebp),%eax
   11b8f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t *p_d2 = (uint8_t *)d2;
   11b92:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b95:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(size--)
   11b98:	eb 23                	jmp    11bbd <kernel_memcmp+0x50>
    {
        if(*p_d1++ != *p_d2++)
   11b9a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b9d:	8d 50 01             	lea    0x1(%eax),%edx
   11ba0:	89 55 fc             	mov    %edx,-0x4(%ebp)
   11ba3:	0f b6 08             	movzbl (%eax),%ecx
   11ba6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11ba9:	8d 50 01             	lea    0x1(%eax),%edx
   11bac:	89 55 f8             	mov    %edx,-0x8(%ebp)
   11baf:	0f b6 00             	movzbl (%eax),%eax
   11bb2:	38 c1                	cmp    %al,%cl
   11bb4:	74 07                	je     11bbd <kernel_memcmp+0x50>
        {
            return 1;
   11bb6:	b8 01 00 00 00       	mov    $0x1,%eax
   11bbb:	eb 12                	jmp    11bcf <kernel_memcmp+0x62>
    while(size--)
   11bbd:	8b 45 10             	mov    0x10(%ebp),%eax
   11bc0:	8d 50 ff             	lea    -0x1(%eax),%edx
   11bc3:	89 55 10             	mov    %edx,0x10(%ebp)
   11bc6:	85 c0                	test   %eax,%eax
   11bc8:	75 d0                	jne    11b9a <kernel_memcmp+0x2d>
        }
    }
    return 0;
   11bca:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11bcf:	c9                   	leave  
   11bd0:	c3                   	ret    

00011bd1 <kernel_itoa>:

void kernel_itoa (char *buf, int num, int base)
{
   11bd1:	55                   	push   %ebp
   11bd2:	89 e5                	mov    %esp,%ebp
   11bd4:	83 ec 10             	sub    $0x10,%esp
    int is_neg = 0;
   11bd7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    is_neg = num < 0 ? 1 : 0;
   11bde:	8b 45 0c             	mov    0xc(%ebp),%eax
   11be1:	c1 e8 1f             	shr    $0x1f,%eax
   11be4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    static const char * num2ch = "0123456789abcdef";
    char *p = buf;
   11be7:	8b 45 08             	mov    0x8(%ebp),%eax
   11bea:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(base != 2 && base != 8 && base != 10 && base != 16)
   11bed:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
   11bf1:	74 1d                	je     11c10 <kernel_itoa+0x3f>
   11bf3:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
   11bf7:	74 17                	je     11c10 <kernel_itoa+0x3f>
   11bf9:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   11bfd:	74 11                	je     11c10 <kernel_itoa+0x3f>
   11bff:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
   11c03:	74 0b                	je     11c10 <kernel_itoa+0x3f>
    {
        *p = '\0';
   11c05:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11c08:	c6 00 00             	movb   $0x0,(%eax)
        return;
   11c0b:	e9 9e 00 00 00       	jmp    11cae <kernel_itoa+0xdd>
    }
    if(num < 0 && base == 10)
   11c10:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11c14:	79 09                	jns    11c1f <kernel_itoa+0x4e>
   11c16:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   11c1a:	75 03                	jne    11c1f <kernel_itoa+0x4e>
    {
        //*p++ = '-';
        num = -num;
   11c1c:	f7 5d 0c             	negl   0xc(%ebp)
    }
    do{
        char ch = num2ch[num % base];
   11c1f:	8b 0d e0 25 01 00    	mov    0x125e0,%ecx
   11c25:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c28:	99                   	cltd   
   11c29:	f7 7d 10             	idivl  0x10(%ebp)
   11c2c:	89 d0                	mov    %edx,%eax
   11c2e:	01 c8                	add    %ecx,%eax
   11c30:	0f b6 00             	movzbl (%eax),%eax
   11c33:	88 45 f3             	mov    %al,-0xd(%ebp)
        *p++ = ch;
   11c36:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11c39:	8d 50 01             	lea    0x1(%eax),%edx
   11c3c:	89 55 fc             	mov    %edx,-0x4(%ebp)
   11c3f:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
   11c43:	88 10                	mov    %dl,(%eax)
        num /= base;
   11c45:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c48:	99                   	cltd   
   11c49:	f7 7d 10             	idivl  0x10(%ebp)
   11c4c:	89 45 0c             	mov    %eax,0xc(%ebp)
    }while (num);
   11c4f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11c53:	75 ca                	jne    11c1f <kernel_itoa+0x4e>
    if(base == 10 && is_neg)
   11c55:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   11c59:	75 12                	jne    11c6d <kernel_itoa+0x9c>
   11c5b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11c5f:	74 0c                	je     11c6d <kernel_itoa+0x9c>
    {
        *p++ = '-';
   11c61:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11c64:	8d 50 01             	lea    0x1(%eax),%edx
   11c67:	89 55 fc             	mov    %edx,-0x4(%ebp)
   11c6a:	c6 00 2d             	movb   $0x2d,(%eax)
    }
    *p-- = '\0';
   11c6d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11c70:	8d 50 ff             	lea    -0x1(%eax),%edx
   11c73:	89 55 fc             	mov    %edx,-0x4(%ebp)
   11c76:	c6 00 00             	movb   $0x0,(%eax)

    char *start = buf;
   11c79:	8b 45 08             	mov    0x8(%ebp),%eax
   11c7c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(start < p)
   11c7f:	eb 25                	jmp    11ca6 <kernel_itoa+0xd5>
    {
        char tmp = *start;
   11c81:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11c84:	0f b6 00             	movzbl (%eax),%eax
   11c87:	88 45 f2             	mov    %al,-0xe(%ebp)
        *start = *p;
   11c8a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11c8d:	0f b6 10             	movzbl (%eax),%edx
   11c90:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11c93:	88 10                	mov    %dl,(%eax)
        *p = tmp;
   11c95:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11c98:	0f b6 55 f2          	movzbl -0xe(%ebp),%edx
   11c9c:	88 10                	mov    %dl,(%eax)
        p--;
   11c9e:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        start++;
   11ca2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while(start < p)
   11ca6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11ca9:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   11cac:	72 d3                	jb     11c81 <kernel_itoa+0xb0>
    }
    
}
   11cae:	c9                   	leave  
   11caf:	c3                   	ret    

00011cb0 <kernel_sprintf>:
void kernel_sprintf (char *buf, const char *fmt, ...)
{
   11cb0:	55                   	push   %ebp
   11cb1:	89 e5                	mov    %esp,%ebp
   11cb3:	83 ec 18             	sub    $0x18,%esp
    va_list args;
    va_start(args, fmt);
   11cb6:	8d 45 10             	lea    0x10(%ebp),%eax
   11cb9:	89 45 f4             	mov    %eax,-0xc(%ebp)

    kernel_vsprintf(buf, fmt, args);
   11cbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11cbf:	83 ec 04             	sub    $0x4,%esp
   11cc2:	50                   	push   %eax
   11cc3:	ff 75 0c             	pushl  0xc(%ebp)
   11cc6:	ff 75 08             	pushl  0x8(%ebp)
   11cc9:	e8 06 00 00 00       	call   11cd4 <kernel_vsprintf>
   11cce:	83 c4 10             	add    $0x10,%esp
    va_end(args);
}
   11cd1:	90                   	nop
   11cd2:	c9                   	leave  
   11cd3:	c3                   	ret    

00011cd4 <kernel_vsprintf>:
void kernel_vsprintf (char *buf, const char *fmt, va_list args)
{
   11cd4:	55                   	push   %ebp
   11cd5:	89 e5                	mov    %esp,%ebp
   11cd7:	83 ec 20             	sub    $0x20,%esp
    enum{
        NORMAL,READ_FMT
    }state = NORMAL;
   11cda:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    char * curr = buf;
   11ce1:	8b 45 08             	mov    0x8(%ebp),%eax
   11ce4:	89 45 f8             	mov    %eax,-0x8(%ebp)
    char ch;
    while((ch = *fmt++))
   11ce7:	e9 17 01 00 00       	jmp    11e03 <kernel_vsprintf+0x12f>
    {
       switch(state)
   11cec:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11cef:	85 c0                	test   %eax,%eax
   11cf1:	74 0a                	je     11cfd <kernel_vsprintf+0x29>
   11cf3:	83 f8 01             	cmp    $0x1,%eax
   11cf6:	74 2b                	je     11d23 <kernel_vsprintf+0x4f>
   11cf8:	e9 06 01 00 00       	jmp    11e03 <kernel_vsprintf+0x12f>
       {
        case NORMAL:
            if(ch == '%')
   11cfd:	80 7d ef 25          	cmpb   $0x25,-0x11(%ebp)
   11d01:	75 0c                	jne    11d0f <kernel_vsprintf+0x3b>
            {
                state = READ_FMT;
   11d03:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
   11d0a:	e9 f4 00 00 00       	jmp    11e03 <kernel_vsprintf+0x12f>
            }
            else
            {
                *curr++ = ch;
   11d0f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11d12:	8d 50 01             	lea    0x1(%eax),%edx
   11d15:	89 55 f8             	mov    %edx,-0x8(%ebp)
   11d18:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
   11d1c:	88 10                	mov    %dl,(%eax)
            }
            break;
   11d1e:	e9 e0 00 00 00       	jmp    11e03 <kernel_vsprintf+0x12f>
        case READ_FMT:
            if(ch == 'd')
   11d23:	80 7d ef 64          	cmpb   $0x64,-0x11(%ebp)
   11d27:	75 31                	jne    11d5a <kernel_vsprintf+0x86>
            {
                int num = va_arg(args,int);
   11d29:	8b 45 10             	mov    0x10(%ebp),%eax
   11d2c:	8d 50 04             	lea    0x4(%eax),%edx
   11d2f:	89 55 10             	mov    %edx,0x10(%ebp)
   11d32:	8b 00                	mov    (%eax),%eax
   11d34:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                kernel_itoa(curr,num,10);
   11d37:	6a 0a                	push   $0xa
   11d39:	ff 75 e4             	pushl  -0x1c(%ebp)
   11d3c:	ff 75 f8             	pushl  -0x8(%ebp)
   11d3f:	e8 8d fe ff ff       	call   11bd1 <kernel_itoa>
   11d44:	83 c4 0c             	add    $0xc,%esp
                curr += kernel_strlen(curr);
   11d47:	ff 75 f8             	pushl  -0x8(%ebp)
   11d4a:	e8 5a fd ff ff       	call   11aa9 <kernel_strlen>
   11d4f:	83 c4 04             	add    $0x4,%esp
   11d52:	01 45 f8             	add    %eax,-0x8(%ebp)
   11d55:	e9 a1 00 00 00       	jmp    11dfb <kernel_vsprintf+0x127>
            }
            else if(ch == 'x')
   11d5a:	80 7d ef 78          	cmpb   $0x78,-0x11(%ebp)
   11d5e:	75 2e                	jne    11d8e <kernel_vsprintf+0xba>
            {
                int num = va_arg(args,int);
   11d60:	8b 45 10             	mov    0x10(%ebp),%eax
   11d63:	8d 50 04             	lea    0x4(%eax),%edx
   11d66:	89 55 10             	mov    %edx,0x10(%ebp)
   11d69:	8b 00                	mov    (%eax),%eax
   11d6b:	89 45 e8             	mov    %eax,-0x18(%ebp)
                kernel_itoa(curr,num,16);
   11d6e:	6a 10                	push   $0x10
   11d70:	ff 75 e8             	pushl  -0x18(%ebp)
   11d73:	ff 75 f8             	pushl  -0x8(%ebp)
   11d76:	e8 56 fe ff ff       	call   11bd1 <kernel_itoa>
   11d7b:	83 c4 0c             	add    $0xc,%esp
                curr += kernel_strlen(curr);
   11d7e:	ff 75 f8             	pushl  -0x8(%ebp)
   11d81:	e8 23 fd ff ff       	call   11aa9 <kernel_strlen>
   11d86:	83 c4 04             	add    $0x4,%esp
   11d89:	01 45 f8             	add    %eax,-0x8(%ebp)
   11d8c:	eb 6d                	jmp    11dfb <kernel_vsprintf+0x127>
            }
            else if(ch == 'c')
   11d8e:	80 7d ef 63          	cmpb   $0x63,-0x11(%ebp)
   11d92:	75 1f                	jne    11db3 <kernel_vsprintf+0xdf>
            {
                char ch = va_arg(args,int);
   11d94:	8b 45 10             	mov    0x10(%ebp),%eax
   11d97:	8d 50 04             	lea    0x4(%eax),%edx
   11d9a:	89 55 10             	mov    %edx,0x10(%ebp)
   11d9d:	8b 00                	mov    (%eax),%eax
   11d9f:	88 45 ee             	mov    %al,-0x12(%ebp)
                *curr++ = ch;
   11da2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11da5:	8d 50 01             	lea    0x1(%eax),%edx
   11da8:	89 55 f8             	mov    %edx,-0x8(%ebp)
   11dab:	0f b6 55 ee          	movzbl -0x12(%ebp),%edx
   11daf:	88 10                	mov    %dl,(%eax)
   11db1:	eb 48                	jmp    11dfb <kernel_vsprintf+0x127>
            }
            else if(ch == 's')
   11db3:	80 7d ef 73          	cmpb   $0x73,-0x11(%ebp)
   11db7:	75 42                	jne    11dfb <kernel_vsprintf+0x127>
            {
                const char *str = va_arg(args,char *);
   11db9:	8b 45 10             	mov    0x10(%ebp),%eax
   11dbc:	8d 50 04             	lea    0x4(%eax),%edx
   11dbf:	89 55 10             	mov    %edx,0x10(%ebp)
   11dc2:	8b 00                	mov    (%eax),%eax
   11dc4:	89 45 f4             	mov    %eax,-0xc(%ebp)
                int len = kernel_strlen(str);
   11dc7:	ff 75 f4             	pushl  -0xc(%ebp)
   11dca:	e8 da fc ff ff       	call   11aa9 <kernel_strlen>
   11dcf:	83 c4 04             	add    $0x4,%esp
   11dd2:	89 45 f0             	mov    %eax,-0x10(%ebp)
                while(len--)
   11dd5:	eb 17                	jmp    11dee <kernel_vsprintf+0x11a>
                {
                    *curr++ = *str++;
   11dd7:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11dda:	8d 42 01             	lea    0x1(%edx),%eax
   11ddd:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11de0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11de3:	8d 48 01             	lea    0x1(%eax),%ecx
   11de6:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   11de9:	0f b6 12             	movzbl (%edx),%edx
   11dec:	88 10                	mov    %dl,(%eax)
                while(len--)
   11dee:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11df1:	8d 50 ff             	lea    -0x1(%eax),%edx
   11df4:	89 55 f0             	mov    %edx,-0x10(%ebp)
   11df7:	85 c0                	test   %eax,%eax
   11df9:	75 dc                	jne    11dd7 <kernel_vsprintf+0x103>
                }
            }
            state = NORMAL;
   11dfb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
            break;
   11e02:	90                   	nop
    while((ch = *fmt++))
   11e03:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e06:	8d 50 01             	lea    0x1(%eax),%edx
   11e09:	89 55 0c             	mov    %edx,0xc(%ebp)
   11e0c:	0f b6 00             	movzbl (%eax),%eax
   11e0f:	88 45 ef             	mov    %al,-0x11(%ebp)
   11e12:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
   11e16:	0f 85 d0 fe ff ff    	jne    11cec <kernel_vsprintf+0x18>
       }
    }
}
   11e1c:	90                   	nop
   11e1d:	c9                   	leave  
   11e1e:	c3                   	ret    

00011e1f <panic>:
void panic(const char *file,int line,const char *func,const char *cond)
{
   11e1f:	55                   	push   %ebp
   11e20:	89 e5                	mov    %esp,%ebp
   11e22:	83 ec 08             	sub    $0x8,%esp
    log_printf("assert failed: %s\n",cond);
   11e25:	83 ec 08             	sub    $0x8,%esp
   11e28:	ff 75 14             	pushl  0x14(%ebp)
   11e2b:	68 9a 25 01 00       	push   $0x1259a
   11e30:	e8 12 03 00 00       	call   12147 <log_printf>
   11e35:	83 c4 10             	add    $0x10,%esp
    log_printf("file: %s\n",file);
   11e38:	83 ec 08             	sub    $0x8,%esp
   11e3b:	ff 75 08             	pushl  0x8(%ebp)
   11e3e:	68 ad 25 01 00       	push   $0x125ad
   11e43:	e8 ff 02 00 00       	call   12147 <log_printf>
   11e48:	83 c4 10             	add    $0x10,%esp
    log_printf("line: %d\n",line);
   11e4b:	83 ec 08             	sub    $0x8,%esp
   11e4e:	ff 75 0c             	pushl  0xc(%ebp)
   11e51:	68 b7 25 01 00       	push   $0x125b7
   11e56:	e8 ec 02 00 00       	call   12147 <log_printf>
   11e5b:	83 c4 10             	add    $0x10,%esp
    log_printf("function: %s\n",func);
   11e5e:	83 ec 08             	sub    $0x8,%esp
   11e61:	ff 75 10             	pushl  0x10(%ebp)
   11e64:	68 c1 25 01 00       	push   $0x125c1
   11e69:	e8 d9 02 00 00       	call   12147 <log_printf>
   11e6e:	83 c4 10             	add    $0x10,%esp
    for(;;){
        hlt();
   11e71:	e8 15 fb ff ff       	call   1198b <hlt>
   11e76:	eb f9                	jmp    11e71 <panic+0x52>

00011e78 <list_is_empty>:
{
   11e78:	55                   	push   %ebp
   11e79:	89 e5                	mov    %esp,%ebp
    return list->count == 0;
   11e7b:	8b 45 08             	mov    0x8(%ebp),%eax
   11e7e:	8b 40 08             	mov    0x8(%eax),%eax
   11e81:	85 c0                	test   %eax,%eax
   11e83:	0f 94 c0             	sete   %al
   11e86:	0f b6 c0             	movzbl %al,%eax
}
   11e89:	5d                   	pop    %ebp
   11e8a:	c3                   	ret    

00011e8b <list_init>:
#include "tools/list.h"

void list_init(list_t *list)
{
   11e8b:	55                   	push   %ebp
   11e8c:	89 e5                	mov    %esp,%ebp
    list->first = list->last = (list_node_t *)0;
   11e8e:	8b 45 08             	mov    0x8(%ebp),%eax
   11e91:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   11e98:	8b 45 08             	mov    0x8(%ebp),%eax
   11e9b:	8b 50 04             	mov    0x4(%eax),%edx
   11e9e:	8b 45 08             	mov    0x8(%ebp),%eax
   11ea1:	89 10                	mov    %edx,(%eax)
    list->count = 0;
   11ea3:	8b 45 08             	mov    0x8(%ebp),%eax
   11ea6:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
   11ead:	90                   	nop
   11eae:	5d                   	pop    %ebp
   11eaf:	c3                   	ret    

00011eb0 <list_insert_first>:

void list_insert_first(list_t * list,list_node_t * node)
{
   11eb0:	55                   	push   %ebp
   11eb1:	89 e5                	mov    %esp,%ebp
    node->next = list->first;
   11eb3:	8b 45 08             	mov    0x8(%ebp),%eax
   11eb6:	8b 10                	mov    (%eax),%edx
   11eb8:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ebb:	89 50 04             	mov    %edx,0x4(%eax)
    node->pre = (list_node_t *)0;
   11ebe:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ec1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(list_is_empty(list))
   11ec7:	ff 75 08             	pushl  0x8(%ebp)
   11eca:	e8 a9 ff ff ff       	call   11e78 <list_is_empty>
   11ecf:	83 c4 04             	add    $0x4,%esp
   11ed2:	85 c0                	test   %eax,%eax
   11ed4:	74 15                	je     11eeb <list_insert_first+0x3b>
    {
        list->last = list->first = node;
   11ed6:	8b 45 08             	mov    0x8(%ebp),%eax
   11ed9:	8b 55 0c             	mov    0xc(%ebp),%edx
   11edc:	89 10                	mov    %edx,(%eax)
   11ede:	8b 45 08             	mov    0x8(%ebp),%eax
   11ee1:	8b 10                	mov    (%eax),%edx
   11ee3:	8b 45 08             	mov    0x8(%ebp),%eax
   11ee6:	89 50 04             	mov    %edx,0x4(%eax)
   11ee9:	eb 12                	jmp    11efd <list_insert_first+0x4d>
    }
    else
    {
        list->first->pre = node;
   11eeb:	8b 45 08             	mov    0x8(%ebp),%eax
   11eee:	8b 00                	mov    (%eax),%eax
   11ef0:	8b 55 0c             	mov    0xc(%ebp),%edx
   11ef3:	89 10                	mov    %edx,(%eax)
        list->first = node;
   11ef5:	8b 45 08             	mov    0x8(%ebp),%eax
   11ef8:	8b 55 0c             	mov    0xc(%ebp),%edx
   11efb:	89 10                	mov    %edx,(%eax)
    }
    list->count++;
   11efd:	8b 45 08             	mov    0x8(%ebp),%eax
   11f00:	8b 40 08             	mov    0x8(%eax),%eax
   11f03:	8d 50 01             	lea    0x1(%eax),%edx
   11f06:	8b 45 08             	mov    0x8(%ebp),%eax
   11f09:	89 50 08             	mov    %edx,0x8(%eax)
}
   11f0c:	90                   	nop
   11f0d:	c9                   	leave  
   11f0e:	c3                   	ret    

00011f0f <list_insert_last>:

void list_insert_last(list_t * list,list_node_t * node)
{
   11f0f:	55                   	push   %ebp
   11f10:	89 e5                	mov    %esp,%ebp
    node->pre = list->last;
   11f12:	8b 45 08             	mov    0x8(%ebp),%eax
   11f15:	8b 50 04             	mov    0x4(%eax),%edx
   11f18:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f1b:	89 10                	mov    %edx,(%eax)
    node->next = (list_node_t *)0;
   11f1d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f20:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if(list_is_empty(list))
   11f27:	ff 75 08             	pushl  0x8(%ebp)
   11f2a:	e8 49 ff ff ff       	call   11e78 <list_is_empty>
   11f2f:	83 c4 04             	add    $0x4,%esp
   11f32:	85 c0                	test   %eax,%eax
   11f34:	74 16                	je     11f4c <list_insert_last+0x3d>
    {
        list->first = list->last = node;
   11f36:	8b 45 08             	mov    0x8(%ebp),%eax
   11f39:	8b 55 0c             	mov    0xc(%ebp),%edx
   11f3c:	89 50 04             	mov    %edx,0x4(%eax)
   11f3f:	8b 45 08             	mov    0x8(%ebp),%eax
   11f42:	8b 50 04             	mov    0x4(%eax),%edx
   11f45:	8b 45 08             	mov    0x8(%ebp),%eax
   11f48:	89 10                	mov    %edx,(%eax)
   11f4a:	eb 15                	jmp    11f61 <list_insert_last+0x52>
    }
    else
    {
        list->last->next = node;
   11f4c:	8b 45 08             	mov    0x8(%ebp),%eax
   11f4f:	8b 40 04             	mov    0x4(%eax),%eax
   11f52:	8b 55 0c             	mov    0xc(%ebp),%edx
   11f55:	89 50 04             	mov    %edx,0x4(%eax)
        list->last = node;
   11f58:	8b 45 08             	mov    0x8(%ebp),%eax
   11f5b:	8b 55 0c             	mov    0xc(%ebp),%edx
   11f5e:	89 50 04             	mov    %edx,0x4(%eax)
    }
    list->count++;
   11f61:	8b 45 08             	mov    0x8(%ebp),%eax
   11f64:	8b 40 08             	mov    0x8(%eax),%eax
   11f67:	8d 50 01             	lea    0x1(%eax),%edx
   11f6a:	8b 45 08             	mov    0x8(%ebp),%eax
   11f6d:	89 50 08             	mov    %edx,0x8(%eax)
}
   11f70:	90                   	nop
   11f71:	c9                   	leave  
   11f72:	c3                   	ret    

00011f73 <list_remove_first>:

list_node_t* list_remove_first(list_t * list)
{
   11f73:	55                   	push   %ebp
   11f74:	89 e5                	mov    %esp,%ebp
   11f76:	83 ec 10             	sub    $0x10,%esp
    if(list_is_empty(list))
   11f79:	ff 75 08             	pushl  0x8(%ebp)
   11f7c:	e8 f7 fe ff ff       	call   11e78 <list_is_empty>
   11f81:	83 c4 04             	add    $0x4,%esp
   11f84:	85 c0                	test   %eax,%eax
   11f86:	74 07                	je     11f8f <list_remove_first+0x1c>
    {
        return (list_node_t *)0;
   11f88:	b8 00 00 00 00       	mov    $0x0,%eax
   11f8d:	eb 59                	jmp    11fe8 <list_remove_first+0x75>
    }
    list_node_t * node = list->first;
   11f8f:	8b 45 08             	mov    0x8(%ebp),%eax
   11f92:	8b 00                	mov    (%eax),%eax
   11f94:	89 45 fc             	mov    %eax,-0x4(%ebp)
    list->first = node->next;
   11f97:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11f9a:	8b 50 04             	mov    0x4(%eax),%edx
   11f9d:	8b 45 08             	mov    0x8(%ebp),%eax
   11fa0:	89 10                	mov    %edx,(%eax)
    if(list->first == (list_node_t *)0)
   11fa2:	8b 45 08             	mov    0x8(%ebp),%eax
   11fa5:	8b 00                	mov    (%eax),%eax
   11fa7:	85 c0                	test   %eax,%eax
   11fa9:	75 0c                	jne    11fb7 <list_remove_first+0x44>
    {
        list->last = (list_node_t *)0;
   11fab:	8b 45 08             	mov    0x8(%ebp),%eax
   11fae:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   11fb5:	eb 0b                	jmp    11fc2 <list_remove_first+0x4f>
    }
    else
    {
        list->first->pre = (list_node_t *)0;
   11fb7:	8b 45 08             	mov    0x8(%ebp),%eax
   11fba:	8b 00                	mov    (%eax),%eax
   11fbc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    node->next = node->pre = (list_node_t *)0;
   11fc2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11fc5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   11fcb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11fce:	8b 10                	mov    (%eax),%edx
   11fd0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11fd3:	89 50 04             	mov    %edx,0x4(%eax)
    list->count--;
   11fd6:	8b 45 08             	mov    0x8(%ebp),%eax
   11fd9:	8b 40 08             	mov    0x8(%eax),%eax
   11fdc:	8d 50 ff             	lea    -0x1(%eax),%edx
   11fdf:	8b 45 08             	mov    0x8(%ebp),%eax
   11fe2:	89 50 08             	mov    %edx,0x8(%eax)
    return node;
   11fe5:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   11fe8:	c9                   	leave  
   11fe9:	c3                   	ret    

00011fea <list_remove>:

list_node_t* list_remove(list_t * list,list_node_t * node)
{
   11fea:	55                   	push   %ebp
   11feb:	89 e5                	mov    %esp,%ebp
    if(node == list->first)
   11fed:	8b 45 08             	mov    0x8(%ebp),%eax
   11ff0:	8b 00                	mov    (%eax),%eax
   11ff2:	39 45 0c             	cmp    %eax,0xc(%ebp)
   11ff5:	75 0b                	jne    12002 <list_remove+0x18>
    {
        list->first = node->next;
   11ff7:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ffa:	8b 50 04             	mov    0x4(%eax),%edx
   11ffd:	8b 45 08             	mov    0x8(%ebp),%eax
   12000:	89 10                	mov    %edx,(%eax)
    }
    if(node == list->last)
   12002:	8b 45 08             	mov    0x8(%ebp),%eax
   12005:	8b 40 04             	mov    0x4(%eax),%eax
   12008:	39 45 0c             	cmp    %eax,0xc(%ebp)
   1200b:	75 0b                	jne    12018 <list_remove+0x2e>
    {
        list->last = node->pre;
   1200d:	8b 45 0c             	mov    0xc(%ebp),%eax
   12010:	8b 10                	mov    (%eax),%edx
   12012:	8b 45 08             	mov    0x8(%ebp),%eax
   12015:	89 50 04             	mov    %edx,0x4(%eax)
    }
    if(node->pre)
   12018:	8b 45 0c             	mov    0xc(%ebp),%eax
   1201b:	8b 00                	mov    (%eax),%eax
   1201d:	85 c0                	test   %eax,%eax
   1201f:	74 0e                	je     1202f <list_remove+0x45>
    {
        node->pre->next = node->next;
   12021:	8b 45 0c             	mov    0xc(%ebp),%eax
   12024:	8b 00                	mov    (%eax),%eax
   12026:	8b 55 0c             	mov    0xc(%ebp),%edx
   12029:	8b 52 04             	mov    0x4(%edx),%edx
   1202c:	89 50 04             	mov    %edx,0x4(%eax)
    }
    if(node->next) 
   1202f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12032:	8b 40 04             	mov    0x4(%eax),%eax
   12035:	85 c0                	test   %eax,%eax
   12037:	74 0d                	je     12046 <list_remove+0x5c>
    {
        node->next->pre = node->pre;
   12039:	8b 45 0c             	mov    0xc(%ebp),%eax
   1203c:	8b 40 04             	mov    0x4(%eax),%eax
   1203f:	8b 55 0c             	mov    0xc(%ebp),%edx
   12042:	8b 12                	mov    (%edx),%edx
   12044:	89 10                	mov    %edx,(%eax)
    }
    node->next = node->pre = (list_node_t *)0;
   12046:	8b 45 0c             	mov    0xc(%ebp),%eax
   12049:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1204f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12052:	8b 10                	mov    (%eax),%edx
   12054:	8b 45 0c             	mov    0xc(%ebp),%eax
   12057:	89 50 04             	mov    %edx,0x4(%eax)
    list->count--;
   1205a:	8b 45 08             	mov    0x8(%ebp),%eax
   1205d:	8b 40 08             	mov    0x8(%eax),%eax
   12060:	8d 50 ff             	lea    -0x1(%eax),%edx
   12063:	8b 45 08             	mov    0x8(%ebp),%eax
   12066:	89 50 08             	mov    %edx,0x8(%eax)
    return node;
   12069:	8b 45 0c             	mov    0xc(%ebp),%eax
}
   1206c:	5d                   	pop    %ebp
   1206d:	c3                   	ret    

0001206e <inb>:
{
   1206e:	55                   	push   %ebp
   1206f:	89 e5                	mov    %esp,%ebp
   12071:	83 ec 14             	sub    $0x14,%esp
   12074:	8b 45 08             	mov    0x8(%ebp),%eax
   12077:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[p], %[v]":[v] "=a"(rv) : [p]"d"(port));
   1207b:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   1207f:	89 c2                	mov    %eax,%edx
   12081:	ec                   	in     (%dx),%al
   12082:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   12085:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   12089:	c9                   	leave  
   1208a:	c3                   	ret    

0001208b <outb>:
{
   1208b:	55                   	push   %ebp
   1208c:	89 e5                	mov    %esp,%ebp
   1208e:	83 ec 08             	sub    $0x8,%esp
   12091:	8b 55 08             	mov    0x8(%ebp),%edx
   12094:	8b 45 0c             	mov    0xc(%ebp),%eax
   12097:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   1209b:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]"::[p]"d"(port),[v]"a"(data));
   1209e:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   120a2:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   120a6:	ee                   	out    %al,(%dx)
}
   120a7:	90                   	nop
   120a8:	c9                   	leave  
   120a9:	c3                   	ret    

000120aa <log_init>:
#include "cpu/irq.h"    
#include "ipc/mutex.h"
#define COM_PORT 0x3f8
static mutex_t log_mutex;
void log_init (void)
{
   120aa:	55                   	push   %ebp
   120ab:	89 e5                	mov    %esp,%ebp
   120ad:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&log_mutex);
   120b0:	83 ec 0c             	sub    $0xc,%esp
   120b3:	68 c8 65 01 00       	push   $0x165c8
   120b8:	e8 14 f6 ff ff       	call   116d1 <mutex_init>
   120bd:	83 c4 10             	add    $0x10,%esp
    outb(COM_PORT + 1, 0x00);
   120c0:	83 ec 08             	sub    $0x8,%esp
   120c3:	6a 00                	push   $0x0
   120c5:	68 f9 03 00 00       	push   $0x3f9
   120ca:	e8 bc ff ff ff       	call   1208b <outb>
   120cf:	83 c4 10             	add    $0x10,%esp
    outb(COM_PORT + 3, 0x80);
   120d2:	83 ec 08             	sub    $0x8,%esp
   120d5:	68 80 00 00 00       	push   $0x80
   120da:	68 fb 03 00 00       	push   $0x3fb
   120df:	e8 a7 ff ff ff       	call   1208b <outb>
   120e4:	83 c4 10             	add    $0x10,%esp
    outb(COM_PORT + 0, 0x03);
   120e7:	83 ec 08             	sub    $0x8,%esp
   120ea:	6a 03                	push   $0x3
   120ec:	68 f8 03 00 00       	push   $0x3f8
   120f1:	e8 95 ff ff ff       	call   1208b <outb>
   120f6:	83 c4 10             	add    $0x10,%esp
    outb(COM_PORT + 1, 0x00);
   120f9:	83 ec 08             	sub    $0x8,%esp
   120fc:	6a 00                	push   $0x0
   120fe:	68 f9 03 00 00       	push   $0x3f9
   12103:	e8 83 ff ff ff       	call   1208b <outb>
   12108:	83 c4 10             	add    $0x10,%esp
    outb(COM_PORT + 3, 0x03);
   1210b:	83 ec 08             	sub    $0x8,%esp
   1210e:	6a 03                	push   $0x3
   12110:	68 fb 03 00 00       	push   $0x3fb
   12115:	e8 71 ff ff ff       	call   1208b <outb>
   1211a:	83 c4 10             	add    $0x10,%esp
    outb(COM_PORT + 2, 0xC7);
   1211d:	83 ec 08             	sub    $0x8,%esp
   12120:	68 c7 00 00 00       	push   $0xc7
   12125:	68 fa 03 00 00       	push   $0x3fa
   1212a:	e8 5c ff ff ff       	call   1208b <outb>
   1212f:	83 c4 10             	add    $0x10,%esp
    outb(COM_PORT + 4, 0x0F);
   12132:	83 ec 08             	sub    $0x8,%esp
   12135:	6a 0f                	push   $0xf
   12137:	68 fc 03 00 00       	push   $0x3fc
   1213c:	e8 4a ff ff ff       	call   1208b <outb>
   12141:	83 c4 10             	add    $0x10,%esp
}
   12144:	90                   	nop
   12145:	c9                   	leave  
   12146:	c3                   	ret    

00012147 <log_printf>:


void log_printf (const char *fmt, ...)
{
   12147:	55                   	push   %ebp
   12148:	89 e5                	mov    %esp,%ebp
   1214a:	81 ec 98 00 00 00    	sub    $0x98,%esp
    char buf[128];
    kernel_memset(buf, 0, sizeof(buf));
   12150:	83 ec 04             	sub    $0x4,%esp
   12153:	68 80 00 00 00       	push   $0x80
   12158:	6a 00                	push   $0x0
   1215a:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   12160:	50                   	push   %eax
   12161:	e8 cd f9 ff ff       	call   11b33 <kernel_memset>
   12166:	83 c4 10             	add    $0x10,%esp

    va_list args;
    va_start(args, fmt);
   12169:	8d 45 0c             	lea    0xc(%ebp),%eax
   1216c:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)

    kernel_vsprintf(buf, fmt, args);
   12172:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
   12178:	83 ec 04             	sub    $0x4,%esp
   1217b:	50                   	push   %eax
   1217c:	ff 75 08             	pushl  0x8(%ebp)
   1217f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   12185:	50                   	push   %eax
   12186:	e8 49 fb ff ff       	call   11cd4 <kernel_vsprintf>
   1218b:	83 c4 10             	add    $0x10,%esp
    va_end(args);

    mutex_lock(&log_mutex);
   1218e:	83 ec 0c             	sub    $0xc,%esp
   12191:	68 c8 65 01 00       	push   $0x165c8
   12196:	e8 62 f5 ff ff       	call   116fd <mutex_lock>
   1219b:	83 c4 10             	add    $0x10,%esp
    const char *p = buf;
   1219e:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   121a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while (*p != '\0')
   121a7:	eb 39                	jmp    121e2 <log_printf+0x9b>
    {
        while ((inb(COM_PORT + 5) & (1 << 6)) == 0);
   121a9:	90                   	nop
   121aa:	83 ec 0c             	sub    $0xc,%esp
   121ad:	68 fd 03 00 00       	push   $0x3fd
   121b2:	e8 b7 fe ff ff       	call   1206e <inb>
   121b7:	83 c4 10             	add    $0x10,%esp
   121ba:	0f b6 c0             	movzbl %al,%eax
   121bd:	83 e0 40             	and    $0x40,%eax
   121c0:	85 c0                	test   %eax,%eax
   121c2:	74 e6                	je     121aa <log_printf+0x63>
        outb(COM_PORT, *p);
   121c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   121c7:	0f b6 00             	movzbl (%eax),%eax
   121ca:	0f b6 c0             	movzbl %al,%eax
   121cd:	83 ec 08             	sub    $0x8,%esp
   121d0:	50                   	push   %eax
   121d1:	68 f8 03 00 00       	push   $0x3f8
   121d6:	e8 b0 fe ff ff       	call   1208b <outb>
   121db:	83 c4 10             	add    $0x10,%esp
        p++;
   121de:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    while (*p != '\0')
   121e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   121e5:	0f b6 00             	movzbl (%eax),%eax
   121e8:	84 c0                	test   %al,%al
   121ea:	75 bd                	jne    121a9 <log_printf+0x62>
    }

    outb(COM_PORT, '\r');
   121ec:	83 ec 08             	sub    $0x8,%esp
   121ef:	6a 0d                	push   $0xd
   121f1:	68 f8 03 00 00       	push   $0x3f8
   121f6:	e8 90 fe ff ff       	call   1208b <outb>
   121fb:	83 c4 10             	add    $0x10,%esp
    //outb(COM_PORT, '\n');
    mutex_unlock(&log_mutex);
   121fe:	83 ec 0c             	sub    $0xc,%esp
   12201:	68 c8 65 01 00       	push   $0x165c8
   12206:	e8 82 f5 ff ff       	call   1178d <mutex_unlock>
   1220b:	83 c4 10             	add    $0x10,%esp
}
   1220e:	90                   	nop
   1220f:	c9                   	leave  
   12210:	c3                   	ret    
