
E:/ubuntu/diy-x86os/start/start/build/source/shell/shell.elf:     file format elf32-i386
E:/ubuntu/diy-x86os/start/start/build/source/shell/shell.elf
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x810000ce

Program Header:
    LOAD off    0x00001000 vaddr 0x81000000 paddr 0x81000000 align 2**12
         filesz 0x0000010f memsz 0x0000010f flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000f8  81000000  81000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000017  810000f8  810000f8  000010f8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .debug_info   000002af  00000000  00000000  0000110f  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_abbrev 00000187  00000000  00000000  000013be  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000060  00000000  00000000  00001548  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_line   000001db  00000000  00000000  000015a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_str    000001a7  00000000  00000000  00001783  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .comment      00000011  00000000  00000000  0000192a  2**0
                  CONTENTS, READONLY
  8 .debug_frame  000000ac  00000000  00000000  0000193c  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
81000000 l    d  .text	00000000 .text
810000f8 l    d  .rodata	00000000 .rodata
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 main.c
81000000 l     F .text	0000004c sys_call
8100004c l     F .text	00000028 print_msg
00000000 l    df *ABS*	00000000 cstart.c
810000ce g       .text	00000000 _start
810000de g     F .text	0000001a cstart
81000074 g     F .text	0000005a main



Disassembly of section .text:

81000000 <sys_call>:
}syscall_args_t;



static inline int sys_call(syscall_args_t *args)
{
81000000:	55                   	push   %ebp
81000001:	89 e5                	mov    %esp,%ebp
81000003:	57                   	push   %edi
81000004:	56                   	push   %esi
81000005:	53                   	push   %ebx
81000006:	83 ec 10             	sub    $0x10,%esp
    int ret;
    uint32_t addr[] = {0,SELECTOR_SYSCALL | 0};
81000009:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
81000010:	c7 45 ec 28 00 00 00 	movl   $0x28,-0x14(%ebp)
            "push %[arg1]\n\t"
            "push %[arg0]\n\t"
            "push %[id]\n\t"
            "lcalll *(%[a])"
            :"=a"(ret)
            :[arg3]"r"(args->arg3), [arg2]"r"(args->arg2), [arg1]"r"(args->arg1),
81000017:	8b 45 08             	mov    0x8(%ebp),%eax
8100001a:	8b 40 10             	mov    0x10(%eax),%eax
8100001d:	8b 55 08             	mov    0x8(%ebp),%edx
81000020:	8b 52 0c             	mov    0xc(%edx),%edx
81000023:	8b 4d 08             	mov    0x8(%ebp),%ecx
81000026:	8b 49 08             	mov    0x8(%ecx),%ecx
            [arg0]"r"(args->arg0), [id]"r"(args->id),
81000029:	8b 5d 08             	mov    0x8(%ebp),%ebx
8100002c:	8b 5b 04             	mov    0x4(%ebx),%ebx
8100002f:	8b 75 08             	mov    0x8(%ebp),%esi
81000032:	8b 36                	mov    (%esi),%esi
    __asm__ __volatile__(
81000034:	8d 7d e8             	lea    -0x18(%ebp),%edi
81000037:	50                   	push   %eax
81000038:	52                   	push   %edx
81000039:	51                   	push   %ecx
8100003a:	53                   	push   %ebx
8100003b:	56                   	push   %esi
8100003c:	ff 1f                	lcall  *(%edi)
8100003e:	89 45 f0             	mov    %eax,-0x10(%ebp)
            [a]"r"(addr));
    return ret;
81000041:	8b 45 f0             	mov    -0x10(%ebp),%eax

}
81000044:	83 c4 10             	add    $0x10,%esp
81000047:	5b                   	pop    %ebx
81000048:	5e                   	pop    %esi
81000049:	5f                   	pop    %edi
8100004a:	5d                   	pop    %ebp
8100004b:	c3                   	ret    

8100004c <print_msg>:
    syscall_args_t args;
    args.id = SYS_getpid;
    return sys_call(&args);
}
static inline void print_msg(const char *msg,int arg)
{
8100004c:	55                   	push   %ebp
8100004d:	89 e5                	mov    %esp,%ebp
8100004f:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_print_msg;
81000052:	c7 45 ec 64 00 00 00 	movl   $0x64,-0x14(%ebp)
    args.arg0 = (int)msg;
81000059:	8b 45 08             	mov    0x8(%ebp),%eax
8100005c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = arg;
8100005f:	8b 45 0c             	mov    0xc(%ebp),%eax
81000062:	89 45 f4             	mov    %eax,-0xc(%ebp)
    sys_call(&args);
81000065:	8d 45 ec             	lea    -0x14(%ebp),%eax
81000068:	50                   	push   %eax
81000069:	e8 92 ff ff ff       	call   81000000 <sys_call>
8100006e:	83 c4 04             	add    $0x4,%esp
}
81000071:	90                   	nop
81000072:	c9                   	leave  
81000073:	c3                   	ret    

81000074 <main>:
#include "lib_syscall.h"

int main(int argc,char **argv)
{
81000074:	55                   	push   %ebp
81000075:	89 e5                	mov    %esp,%ebp
81000077:	83 ec 10             	sub    $0x10,%esp
    int count = 0;
8100007a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for(int i = 0; i < argc; i++)
81000081:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
81000088:	eb 23                	jmp    810000ad <main+0x39>
    {
        print_msg("argv = %s\n",argv[i]);
8100008a:	8b 45 f8             	mov    -0x8(%ebp),%eax
8100008d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
81000094:	8b 45 0c             	mov    0xc(%ebp),%eax
81000097:	01 d0                	add    %edx,%eax
81000099:	8b 00                	mov    (%eax),%eax
8100009b:	50                   	push   %eax
8100009c:	68 f8 00 00 81       	push   $0x810000f8
810000a1:	e8 a6 ff ff ff       	call   8100004c <print_msg>
810000a6:	83 c4 08             	add    $0x8,%esp
    for(int i = 0; i < argc; i++)
810000a9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
810000ad:	8b 45 f8             	mov    -0x8(%ebp),%eax
810000b0:	3b 45 08             	cmp    0x8(%ebp),%eax
810000b3:	7c d5                	jl     8100008a <main+0x16>
    }
    for(;;)
    {
        print_msg("count = %d\n",count++);
810000b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
810000b8:	8d 50 01             	lea    0x1(%eax),%edx
810000bb:	89 55 fc             	mov    %edx,-0x4(%ebp)
810000be:	50                   	push   %eax
810000bf:	68 03 01 00 81       	push   $0x81000103
810000c4:	e8 83 ff ff ff       	call   8100004c <print_msg>
810000c9:	83 c4 08             	add    $0x8,%esp
810000cc:	eb e7                	jmp    810000b5 <main+0x41>

810000ce <_start>:
    .text
    .global _start
    .extern cstart
_start:
    mov %ss, %ax
810000ce:	66 8c d0             	mov    %ss,%ax
	mov %ax, %ds
810000d1:	8e d8                	mov    %eax,%ds
	mov %ax, %es
810000d3:	8e c0                	mov    %eax,%es
	mov %ax, %fs
810000d5:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
810000d7:	8e e8                	mov    %eax,%gs
	
810000d9:	e9 00 00 00 00       	jmp    810000de <cstart>

810000de <cstart>:
int main(int argc,char **argv);

void cstart(int argc,char **argv)
{
810000de:	55                   	push   %ebp
810000df:	89 e5                	mov    %esp,%ebp
810000e1:	83 ec 08             	sub    $0x8,%esp
    main(argc,argv);
810000e4:	83 ec 08             	sub    $0x8,%esp
810000e7:	ff 75 0c             	pushl  0xc(%ebp)
810000ea:	ff 75 08             	pushl  0x8(%ebp)
810000ed:	e8 82 ff ff ff       	call   81000074 <main>
810000f2:	83 c4 10             	add    $0x10,%esp
810000f5:	90                   	nop
810000f6:	c9                   	leave  
810000f7:	c3                   	ret    
